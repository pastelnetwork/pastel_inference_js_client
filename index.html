<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pastel Inference Client UI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sira-ui/tailwind/dist/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/json.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.9.3/sha3.min.js"></script>
  <style>
    .ground-glass {
      background-color: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
    }

    body {
      font-family: Montserrat, sans-serif;
    }

    .btn.success.outline {
      border-color: #4caf50;
      color: #4caf50;
    }

    .btn.success.outline:hover {
      background-color: #4caf50;
      color: #ffffff;
    }

    .btn.success.outline:active {
      background-color: #388e3c;
      border-color: #388e3c;
      color: #ffffff;
    }

    .icon-large {
      font-size: 1.5rem;
      /* Adjust this size as needed */
    }

    .xterm {
      width: 100% !important;
      border-radius: 0.5rem;
      /* Adds rounded corners */
    }

    .table-container {
      overflow-x: auto;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .table th,
    .table td {
      padding: 0.5rem;
      border: 1px solid #ccc;
    }

    .table th:last-child,
    .table td:last-child {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 150px;
    }

    .table td:last-child:hover {
      white-space: normal;
    }

    [data-theme="dark"] {
      background-color: #121212;
      color: #ffffff;
    }

    [data-theme="dark"] .bg-white {
      background-color: #333333;
    }

    [data-theme="dark"] .text-bw-50 {
      color: #cccccc;
    }

    [data-theme="dark"] .text-bw-600 {
      color: #ffffff;
    }

    [data-theme="dark"] .text-bw-700 {
      color: #eeeeee;
    }

    [data-theme="dark"] .text-bw-800 {
      color: #ffffff;
    }

    [data-theme="dark"] .bg-bw-50 {
      background-color: #333333;
    }

    [data-theme="dark"] .btn.outline.bw {
      border-color: #ffffff;
      color: #ffffff;
    }

    [data-theme="dark"] .btn.outline.bw:hover {
      background-color: #ffffff;
      color: #000000;
    }

    [data-theme="dark"] .table .bg-gray-200 {
      background-color: #333333;
      color: #ffffff;
      /* This needs to be adjusted */
    }

    [data-theme="dark"] .table .bg-gray-200.selected-row {
      color: #000000;
      /* Adjust this color to be dark for legibility */
    }

    [data-theme="dark"] #previousRequestsList {
      background-color: #333333;
      color: #ffffff;
    }

    [data-theme="dark"] .delete-btn {
      color: #ffffff;
      border-color: #ffffff;
    }

    .table-responsive {
      overflow-x: auto;
    }

    .truncate {
      max-width: 150px;
      /* Adjust as needed */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .prompt.success.xs {
      display: inline-block;
      flex-grow: 1;
      /* Allow it to take up the remaining space */
      max-width: calc(100% - 2rem);
      /* Leave some padding for better readability */
      word-wrap: break-word;
      /* Ensure the text wraps correctly */
      height: 333px;
      /* Set a fixed height */
      overflow-y: auto;
      /* Add a scrollbar if the content exceeds the height */
      padding: 0.5rem;
      /* Add padding for better readability */
      border: 1px solid #ccc;
      /* Optional: Add a border for better visibility */
      border-radius: 0.5rem;
      /* Optional: Add rounded corners */
      background-color: #F2F9FF;
    }

    .prompt.success.xs .content {
      overflow-wrap: break-word;
    }

    .flex {
      display: flex;
    }

    .items-center {
      align-items: center;
    }

    .gap-4 {
      gap: 1rem;
      /* Adjust gap as needed */
    }

    .hidden {
      display: none;
    }

    #previousRequestsList {
      background-color: #f9f9f9;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1rem;
      max-height: 1200px;
      overflow-y: auto;
    }

    #requestPreview {
      background-color: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1.5rem;
    }

    .delete-btn {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      transition: box-shadow 0.3s;
    }

    .delete-btn:hover {
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    #exportRequestsButton {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: auto;
    }

    .align-middle {
      vertical-align: middle;
    }

    .credit-pack-details-container {
      width: 100%;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .new-ticket-table th {
      width: 25%;
      /* As we have 4 columns, each gets 25% width */
    }

    .tooltip-icon {
      margin-left: 5px;
      font-size: 14px;
      color: #6b7280;
    }

    .select-column {
      width: 6%;
    }

    .initial-credits-column {
      width: 16%;
    }

    .current-credit-balance-column {
      width: 16.5%;
    }

    .tracking-address-column {
      width: 25%;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
    }

    .registration-txid-column {
      width: 25%;
    }

    .sha3256-hash-of-credit-pack-column {
      width: 30%;
    }

    .responding-supernode-pastelid-column {
      width: 30%;
    }

    .outcome-column {
      width: 15%;
    }
    .bg-gray-50 {
      background-color: #f9fafb;
    }
    [data-theme="dark"] .bg-gray-50 {
      background-color: #404040;
    }
    .light-logo,
    [data-theme="dark"] .dark-logo {
      display: none;
    }
    [data-theme="dark"] .light-logo {
      display: block;
    }
    .border-color {
      border: 1px solid #EDF2F7;
    }
    .w-72px {
      width: 72px;
    }
    .pt-18px {
      padding-top: 18px;
    }
    .menu-item {
      transition: all 0.3s ease-in-out;
    }
    .main-content {
      min-height: calc(100vh - 117px);
    }
    .menu-item:hover {
      background-color: #e6e8ec;
      color: #23262f;
    }
    .text-neutrals-600 {
      color: #777e90;
    }
    .site-name {
      font-size: 12.5px;
    }
    .button-contained {
      position: relative;
      display: inline-flex;
      width: 100%;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem;
      border-width: 1px;
      border-color: transparent;
      background-color: #1f2937;
      padding: 12px 20px;
      font-size: 16px;
      line-height: 1.1;
      font-weight: 600;
      color: #f3f4f6;
      transition-property: all;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-duration: 500ms;
      white-space: nowrap;
    }
    .button-contained:hover {
      --tw-border-opacity: 1;
      border-color: rgb(31 41 55 / var(--tw-border-opacity));
      background-color: transparent;
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity));
      --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
    }
    .button-contained:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
    }
    .button-contained:disabled,
    .button-outlined:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
    .button-outlined {
      position: relative;
      display: inline-flex;
      width: 100%;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem;
      border-width: 1px;
      --tw-border-opacity: 1;
      border-color: rgb(31 41 55 / var(--tw-border-opacity));
      background-color: transparent;
      padding: 12px 20px;
      font-size: 16px;
      line-height: 1.1;
      font-weight: 600;
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity));
      transition-property: all;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-duration: 500ms;
      white-space: nowrap;
    }

    .button-outlined:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(31 41 55 / var(--tw-bg-opacity));
      --tw-text-opacity: 1;
      color: rgb(243 244 246 / var(--tw-text-opacity));
      --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
    }
    .button-outlined:focus {
      outline: 2px solid transparent;
      outline-offset: 2px;
    }
    .label {
      margin-bottom: 8px;
      display: block;
      text-align: left;
      font-size: 16px;
      line-height: 1.1;
      font-weight: 500;
      --tw-text-opacity: 1;
      color: rgb(55 65 81 / var(--tw-text-opacity));
    }
    .text-box {
      display: block;
      width: 100%;
      border-radius: 8px;
      border-width: 1px;
      --tw-border-opacity: 1;
      border-color: rgb(230 232 236 / var(--tw-border-opacity));
      padding: 5px 10px;
      font-size: 14px;
      --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      outline: 2px solid transparent;
      outline-offset: 2px;
      background-color: #f4f5f6;
    }
    .text-box:disabled {
      cursor: not-allowed;
    }
    .prompt.success.xs {
      max-width: 100%;
    }
    .prompt.success.xs.small {
      height: 150px;
    }
    .p-20px {
      padding: 20px;
    }
    .box {
      padding: 16px;
      background: #E1D2F5;
      border-radius: 8px;
      overflow: hidden;
    }
    .custom-select {
      background-image: url(./caret-down.svg);
      background-position: right 6px center;
      background-repeat: no-repeat;
      background-color: #f4f5f6;
      background-size: 16px 16px;
      padding: 5px 26px 5px 10px;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
      appearance: none;
      font-size: 14px;
      border-radius: 8px;
      --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      outline: 2px solid transparent;
      outline-offset: 2px;
    }
    .sub-menu {
      display: none;
      width: 320px;
      top: 100%;
    }
    .main-menu-item:hover {
      color: #7850C8;
    }
    .main-menu-item:hover .sub-menu {
      display: block;
    }
    .social-link {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      padding: 4px;
      border-radius: 100%;
      border: 1px solid rgb(45, 55, 72);
      transition: 0.5s;
      font-size: 16px;
    }
    .social-link svg {
      max-width: 100%;
      fill: rgb(45, 55, 72);
      transition: 0.5s;
    }
    .social-link:hover {
      border-color: #7850C8;
      background: none;
    }
    .social-link:hover svg {
      fill: #7850C8;
    }
    .main-logo {
      height: 25px;
    }
    header {
      position: sticky;
      top: 0;
      left: 0;
      right: 0;
      height: 65px;
      z-index: 9999;
    }
    * {
        scroll-margin-top: 65px;
    }
    .h-113px {
      height: 112px;
    }
  </style>
</head>

<body class="flex flex-col transition-all duration-300 bg-bw-50 overflow-x-hidden">
  <div class="block w-full h-full">
    <div class="flex-1 bg-white">
      <header class="py-2 p-20px bg-white flex justify-between items-center shadow-lg">
        <div class="">
          <a href="/" class="w-full flex items-end gap-2">
            <img src="/pastel-logo.svg" alt="Pastel Inference Client" class="main-logo dark-logo w-full" />
            <img src="/pastel-logo-white.svg" alt="Pastel Inference Client" class="main-logo light-logo w-full" />
            <span class="text-right block site-name text-base whitespace-nowrap leading-none">Inference Client</span>
          </a>
        </div>
        <div class="flex items-center gap-4">
          <ul class="flex items-center gap-4">
            <li class="main-menu-item">
              <a href="https://github.com/pastelnetwork/pastel_inference_js_client?tab=readme-ov-file#pastel-inference-javascript-client" target="_blank" rel="noopener">What is the Pastel Inference Client?</a>
            </li>
            <li class="main-menu-item inline-flex relative">
              <a href="#" class="inline-flex items-center gap-1 text-base">
                User Information
                <img src="./caret-down.svg" alt="Other" class="ml-1" />
              </a>
              <ul class="space-y-1 sub-menu origin-top-right absolute border shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none z-20 right-1 rounded-lg">
                <li>
                  <a href="#userInformation" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>User Information</span>
                  </a>
                </li>
                <li>
                  <a href="#createNewCreditPackTicket" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Create New Credit Pack Ticket</span>
                  </a>
                </li>
                <li>
                  <a href="#creditPackTicket" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Credit Pack Ticket</span>
                  </a>
                </li>
                <li>
                  <a href="#createNewInferenceRequest" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Create New Inference Request</span>
                  </a>
                </li>
                <li>
                  <a href="#inferenceRequests" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>View Previous Inference Requests</span>
                  </a>
                </li>
                <li>
                  <a href="#sendAndReceiveMessages" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Send and Receive Messages</span>
                  </a>
                </li>
                <li>
                  <a href="#manageWallet" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Manage Wallet</span>
                  </a>
                </li>
                <li>
                  <a href="#terminal" class="menu-item flex items-center gap-1.5 block p-3 text-neutrals-600 font-normal">
                    <span>Terminal</span>
                  </a>
                </li>
              </ul>
            </li>
          </ul>
          <div class="w-auto flex items-center">
            <input id="theme-toggle" class="switch success lg" data-content="☀" type="checkbox" onchange="toggleDarkMode()" />
          </div>
          <div class="w-auto">
            <ul class="w-auto flex gap-2">
                <li class="">
                    <a class="social-link" tabindex="0" target="_blank" href="https://t.me/PastelNetwork">
                        <svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M22.9977 3.1448C22.6238 2.83952 22.0366 2.79584 21.4295 3.03056H21.4285C20.79 3.27728 3.35378 10.4792 2.64398 10.7734C2.51487 10.8166 1.38735 11.2218 1.5035 12.1242C1.60718 12.9378 2.51338 13.2747 2.62404 13.3136L7.05686 14.7752C7.35095 15.7179 8.4351 19.196 8.67486 19.939C8.8244 20.4022 9.06815 21.0109 9.49533 21.1362C9.87017 21.2754 10.243 21.1482 10.4843 20.9658L13.1944 18.5451L17.5694 21.8307L17.6736 21.8907C17.9707 22.0174 18.2553 22.0808 18.527 22.0808C18.7368 22.0808 18.9382 22.0429 19.1306 21.967C19.7861 21.7078 20.0483 21.1064 20.0757 21.0382L23.3436 4.68128C23.543 3.80768 23.2658 3.3632 22.9977 3.1448ZM10.9663 15.3598L9.4709 19.1998L7.97552 14.3998L19.4401 6.23984L10.9663 15.3598Z"
                            ></path>
                        </svg>
                    </a>
                </li>
                <li class="">
                    <a class="social-link" tabindex="0" target="_blank" href="https://twitter.com/pastelnetwork">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g clip-path="url(#clip0_3535_1221)">
                                <path
                                    d="M24.0298 5.01102C23.1429 5.40477 22.1923 5.66914 21.1929 5.78914C22.2129 5.17789 22.9967 4.21039 23.3642 3.05914C22.4117 3.62352 21.3523 4.03414 20.2292 4.25539C19.3292 3.29539 18.0467 2.69727 16.6273 2.69727C13.9011 2.69727 11.6904 4.90602 11.6904 7.63227C11.6904 8.01852 11.7354 8.39539 11.8198 8.75727C7.71731 8.55102 4.08168 6.58602 1.64605 3.59914C1.22043 4.33039 0.978555 5.17789 0.978555 6.08164C0.978555 7.79352 1.84855 9.30477 3.17418 10.1916C2.36418 10.1654 1.60293 9.94227 0.937305 9.57289C0.937305 9.59352 0.937305 9.61414 0.937305 9.63477C0.937305 12.0273 2.6398 14.0204 4.89543 14.476C4.48293 14.5885 4.04605 14.6485 3.59606 14.6485C3.2773 14.6485 2.96793 14.6185 2.66605 14.5585C3.29606 16.5179 5.11856 17.9485 7.27668 17.9879C5.58918 19.3116 3.46106 20.0991 1.1473 20.0991C0.74793 20.0991 0.356055 20.0766 -0.0283203 20.0298C2.15418 21.4323 4.74918 22.2479 7.5373 22.2479C16.6161 22.2479 21.5811 14.7273 21.5811 8.20602C21.5811 7.99227 21.5754 7.77664 21.5679 7.56664C22.5317 6.87102 23.3679 6.00102 24.0298 5.01102Z"
                                ></path>
                            </g>
                        </svg>
                    </a>
                </li>
                <li class="">
                    <a class="social-link" tabindex="0" target="_blank" href="https://discord.com/invite/qudewKS3kp">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M19.98 5.16924C18.0693 3.63174 15.0468 3.37111 14.9175 3.36174C14.7168 3.34486 14.5256 3.45736 14.4431 3.64299C14.4356 3.65424 14.37 3.80611 14.2968 4.04236C15.5606 4.25611 17.1131 4.68549 18.5175 5.55736C18.7425 5.69611 18.8118 5.99236 18.6731 6.21736C18.5812 6.36549 18.4256 6.44611 18.2643 6.44611C18.1781 6.44611 18.09 6.42174 18.0112 6.37299C15.5962 4.87486 12.5812 4.79986 12 4.79986C11.4187 4.79986 8.40184 4.87486 5.98871 6.37299C5.76371 6.51361 5.46746 6.44424 5.32871 6.21924C5.18809 5.99236 5.25746 5.69799 5.48246 5.55736C6.88684 4.68736 8.43934 4.25611 9.70309 4.04424C9.62996 3.80611 9.56433 3.65611 9.55871 3.64299C9.47433 3.45736 9.28496 3.34111 9.08246 3.36174C8.95309 3.37111 5.93059 3.63174 3.99371 5.18986C2.98309 6.12549 0.959961 11.593 0.959961 16.3199C0.959961 16.4042 0.982461 16.4849 1.02371 16.558C2.41871 19.0105 6.22684 19.6517 7.09496 19.6799C7.09871 19.6799 7.10434 19.6799 7.10996 19.6799C7.26371 19.6799 7.40809 19.6067 7.49809 19.483L8.37559 18.2755C6.00746 17.6642 4.79809 16.6255 4.72871 16.5636C4.52996 16.3892 4.51121 16.0855 4.68746 15.8867C4.86184 15.688 5.16559 15.6692 5.36434 15.8436C5.39246 15.8699 7.61996 17.7599 12 17.7599C16.3875 17.7599 18.615 15.8624 18.6375 15.8436C18.8362 15.6711 19.1381 15.688 19.3143 15.8886C19.4887 16.0874 19.47 16.3892 19.2712 16.5636C19.2018 16.6255 17.9925 17.6642 15.6243 18.2755L16.5018 19.483C16.5918 19.6067 16.7362 19.6799 16.89 19.6799C16.8956 19.6799 16.9012 19.6799 16.905 19.6799C17.7731 19.6517 21.5812 19.0105 22.9762 16.558C23.0175 16.4849 23.04 16.4042 23.04 16.3199C23.04 11.593 21.0168 6.12549 19.98 5.16924ZM8.87996 14.3999C7.95184 14.3999 7.19996 13.5411 7.19996 12.4799C7.19996 11.4186 7.95184 10.5599 8.87996 10.5599C9.80809 10.5599 10.56 11.4186 10.56 12.4799C10.56 13.5411 9.80809 14.3999 8.87996 14.3999ZM15.12 14.3999C14.1918 14.3999 13.44 13.5411 13.44 12.4799C13.44 11.4186 14.1918 10.5599 15.12 10.5599C16.0481 10.5599 16.8 11.4186 16.8 12.4799C16.8 13.5411 16.0481 14.3999 15.12 14.3999Z"
                            ></path>
                        </svg>
                    </a>
                </li>
                <li class="">
                    <a class="social-link" tabindex="0" target="_blank" href="https://medium.com/pastelnetwork">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M1.43998 2.88086L3.35998 5.32492V16.9377L0.47998 20.6409H7.19998L4.31998 16.9377V6.60086L10.56 20.6409L10.559 20.6474L16.32 6.50242V18.7209L14.4 20.6409H22.56L20.64 18.7209L20.6269 5.04273L22.4944 2.88742H16.7259L12.2906 13.798L7.43811 2.88086H1.43998Z"
                            ></path>
                        </svg>
                    </a>
                </li>
            </ul>
          </div>
        </div>
      </header>
      <main class="py-2 p-20px mt-3 main-content">
        <div class="fixed z-20 top-0 left-0 w-screen h-screen hidden" id="createPastelIDLoading">
          <div class="position z-10 bg-slate-400 top-0 left-0 w-screen h-screen opacity-95"></div>
          <div class="absolute z-20 w-screen h-screen flex items-center justify-center top-0 left-0">
            <div class="text-center max-w-3xl px-4">
              <div class="btn is-loading">Loading...</div>
              <div class="text-lg font-bold" id="createPastelIDLoadingText"></div>
            </div>
          </div>
        </div>

        <div class="grid gap-4 grid-cols-2">
          <!--User Information-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="userInformation">
            <h2 class="text-xl font-bold text-bw-800">User Information</h2>
            <div class="col-span-full mt-3">
              <div>
                <label class="label">Wallet Balance (PSL):</label>
                <span id="walletBalance" class="text-base text-bw-700">
                  Loading...
                  <script>
                    document.addEventListener("DOMContentLoaded", async () => {
                      try {
                        const walletInfoResponse = await axios.get(
                          "/get-wallet-info"
                        );
                        const walletInfo = walletInfoResponse.data.result;
                        const formattedWalletBalance =
                          walletInfo.balance.toLocaleString(undefined, {
                            minimumFractionDigits: 1,
                            maximumFractionDigits: 1,
                          });
                        document.getElementById(
                          "walletBalance"
                        ).textContent = `${formattedWalletBalance} PSL`;
                      } catch (error) {
                        console.error("Error retrieving wallet info:", error);
                        document.getElementById("walletBalance").textContent =
                          "Failed to load balance";
                      }
                    });
                  </script>
                </span>
              </div>
      
              <div class="mt-4">
                <label class="label">My PSL Address:</label>
                <span id="myPslAddress" class="text-base text-bw-700"></span>
                <button id="copyAddressButton" class="ml-2 tooltip" data-tooltip="Copy address to clipboard">
                  📋
                </button>
              </div>

              <div class="mt-4" id="">
                <label class="label">Your Currently Selected PastelID:</label>
                <span id="userPastelID" class="text-base text-bw-700 truncate block max-w-full">Loading...</span>
              </div>
              <div class="mt-4">
                <div id="pastelIDDropdownContainer" class="mt-4 hidden">
                  <label class="label">Select Existing PastelID to Use:</label>
                  <select id="pastelIDDropdown" class="custom-select w-full">
                    <!-- Options will be dynamically populated -->
                  </select>
                </div>
                <div class="mt-4">
                  <button id="changePastelIDButton" class="button-contained" onclick="togglePastelIDDropdown()">
                    Switch to a Different PastelID
                  </button>
                </div>
              </div>
              <div id="noPastelIDContainer" class="hidden mt-8">
                <p class="text-bw-700 text-base font-bold">
                  No PastelID found. Would you like to create a new one for 1,000
                  PSL?
                </p>
                <form id="createPastelIDForm" class="box mt-4">
                  <label class="label" for="newPastelIDPassphrase">
                    Enter Passphrase (min 6 characters):
                  </label>
                  <input id="newPastelIDPassphrase" class="text-box w-full" type="password" placeholder="Enter passphrase"
                    minlength="6" required />
                  <button type="submit" class="button-contained mt-4">
                    Create PastelID
                  </button>
                </form>
                <div class="mt-4 box">
                  <p class="label">
                    Already have an existing PastelID? Import the file here:
                  </p>
                  <input id="importPastelIDFile" class="text-box w-full" type="file" />
                  <button id="importPastelIDButton" class="button-contained mt-4">
                    Import PastelID
                  </button>
                </div>
              </div>
              <div class="mt-4 hidden" id="passphraseContainer">
                <label class="block text-bw-700 font-bold mb-2" for="pastelIDPassphrase">Enter Passphrase:</label>
                <input id="pastelIDPassphrase" class="input w-full" type="password" placeholder="Enter passphrase"
                  minlength="6" required />
                <div class="mt-2">
                  <input type="checkbox" id="rememberPassphrase" />
                  <label for="rememberPassphrase" class="text-bw-700">Remember password?</label>
                </div>
                <button id="submitPassphraseButton" class="btn success outline mt-4">
                  Submit
                </button>
                <div id="messageContainer" class="my-4"></div>
                <!-- Container for messages -->
              </div>
              <button id="createPastelIDButton" class="btn success outline m-4 hidden">
                Create a PastelID so you can make inference requests? (Costs 1,000
                PSL)
              </button>
            </div>
          </div>

          <!--Create New Credit Pack Ticket-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="createNewCreditPackTicket">
            <h2 class="text-xl font-bold text-bw-800">Create New Credit Pack Ticket</h2>
            <form id="createTicketForm" class="mt-3">
              <div class="grid gap-4 grid-cols-2">
                <div>
                  <label class="label" for="numCredits">Number of Credits</label>
                  <input class="text-box" id="numCredits" type="text" placeholder="Enter number of credits" value="1500"
                    data-raw-value="1500" />
                </div>
                <div>
                  <label class="label" for="maxTotalPrice">Maximum Total Price (PSL)</label>
                  <input class="text-box" id="maxTotalPrice" type="text" placeholder="Enter maximum total price"
                    value="150000" data-raw-value="150000" />
                </div>
              </div>
              <div class="grid gap-4 grid-cols-2 mt-4">
                <div class="">
                  <label class="label" for="maxPerCreditPrice">Maximum Per Credit Price (PSL)</label>
                  <input class="text-box" id="maxPerCreditPrice" type="text" placeholder="Enter maximum per credit price"
                    value="100.0" data-raw-value="100.0" />
                </div>
              </div>
              <div class="mt-4">
                <button class="button-contained" type="submit" id="createCreditPackButton">
                  Create Credit Pack
                </button>
                <div id="loaderContainer" class="text-center"></div>
              </div>
              <!-- Add this div for the loader -->
              <div class="prompt success xs mt-4" id="createTicketStatusContainer">
                <label class="text-bw-800 font-bold mb-4" for="createTicketStatus">Current Status:</label>
                <div class="content p-2" id="createTicketStatus"></div>
              </div>
              <div class="credit-pack-details-container" id="newCreditPackTicketDetailsContainer" style="display: none">
                <h3 class="text-xl text-bw-800">New Credit Pack Ticket Details</h3>
                <div class="table-responsive">
                  <table class="table bordered bw new-ticket-table">
                    <thead>
                      <tr>
                        <th>Registration TXID</th>
                        <th>SHA3-256 Hash of Credit Pack Purchase Request Fields</th>
                        <th>Responding Supernode PastelID</th>
                        <th>Outcome</th>
                      </tr>
                    </thead>
                    <tbody id="newCreditPackTicketDetails">
                      <!-- New ticket details will be dynamically populated here -->
                    </tbody>
                  </table>
                </div>
              </div>
            </form>
          </div>
        </div>

        <div class="grid gap-4 grid-cols-1 mt-4">
          <!--Select Existing Credit Pack Ticket-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="creditPackTicket">
            <h2 class="text-xl font-bold text-bw-800">Select Existing Credit Pack Ticket</h2>
            <div class="relative text-bw-700 table-responsive mt-3">
              <table class="table bordered bw">
                <thead>
                  <tr>
                    <th class="select-column">Select</th>
                    <th class="initial-credits-column">Initial Credits in Pack</th>
                    <th class="current-credit-balance-column">
                      Current Credit Balance
                    </th>
                    <th class="tracking-address-column">Tracking Address</th>
                    <th>Blockheight Registered</th>
                    <th>Credit Pack Registration TXID</th>
                  </tr>
                </thead>
                <tbody id="creditPackTicketTableBody">
                  <!-- Rows will be dynamically populated here -->
                </tbody>
              </table>
              <div class="flex items-center gap-4 mt-4">
                <button id="refreshButton" class="btn success outline p-4 relative">
                  Manually Refresh Credit Pack Tickets
                  <span class="loader hidden absolute inset-0 flex items-center justify-center">
                    <div class="is-loading"></div>
                  </span>
                </button>
                <div class="btn is-loading hidden" id="loadingMessage">
                  Loading...
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="grid gap-4 grid-cols-2 mt-4">
          <!--Create New Inference Request-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="createNewInferenceRequest">
            <h2 class="text-xl font-bold text-bw-800">Create New Inference Request</h2>
            <form id="inferenceRequestForm" class="mt-3">
              <div class="grid gap-4 grid-cols-3 mb-4">
                <div>
                  <label class="label" for="inferenceType">Inference Type</label>
                  <div class="relative text-bw-700">
                    <select id="inferenceType" class="custom-select w-full">
                      <option value="">Select an inference type</option>
                      <option value="text_completion">Text Completion</option>
                      <option value="ask_question_about_an_image">
                        Ask a Question About an Image
                      </option>
                      <option value="text_to_image">Image Generation</option>
                      <option value="embedding_document">Embedding Document</option>
                      <option value="embedding_audio">
                        Audio Transcript and Embedding
                      </option>
                    </select>
                  </div>
                </div>
                <div>
                  <label class="label" for="model">Model/Service</label>
                  <div class="relative text-bw-700">
                    <select id="model" class="custom-select w-full">
                      <option value="">Select a model/service</option>
                      <option value="groq-llama3-70b-8192" selected></option>
                      <option value="claude3-opus">Claude3-Opus</option>
                    </select>
                  </div>
                </div>
                <div>
                  <label class="label" for="maxCost">Maximum Cost (Credits)</label>
                  <input class="text-box w-full" id="maxCost" type="text" placeholder="Enter maximum cost" value="200"
                    data-raw-value="200" />
                  <span id="maxCostFormatted" class="text-bw-700"></span>
                </div>
              </div>
      
              <div id="textCompletionSettings" class="col-span-full">
                <div class="mb-4">
                  <label class="label" for="prompt">Prompt</label>
                  <textarea class="text-box w-full h-113px" id="prompt" rows="7" placeholder="Enter your prompt">Write me a Shakespeare-style sonnet about Pastel Network and how it's really decentralized and powerful.</textarea>
                </div>
              </div>
              <div id="modelParametersContainer" class="col-span-full"></div>
      
              <div id="imageGenerationSettings" class="col-span-full" style="display: none">
                <div class="mb-4">
                  <label class="label" for="imagePrompt">Image Prompt</label>
                  <textarea class="text-box w-full h-113px" id="imagePrompt" rows="5" placeholder="Enter your image prompt">A picture of a clown holding a sign that says PASTEL</textarea>
                </div>
              </div>
      
              <div id="embeddingDocumentSettings" class="col-span-full" style="display: none">
                <div class="mb-4">
                  <label class="label" for="embeddingDocumentFile">Document to Embed</label>
                  <input type="file" class="text-box w-full" id="embeddingDocumentFile" accept=".pdf,.doc,.docx,.txt" />
                </div>
                <div class="mb-4">
                  <label class="label" for="document_semantic_query_string">Semantic Query String
                    (Optional):</label>
                  <input class="text-box w-full" id="document_semantic_query_string" type="text"
                    placeholder="Enter your query" />
                </div>
              </div>
      
              <div id="embeddingAudioSettings" class="col-span-full" style="display: none">
                <div class="mb-4">
                  <label class="label" for="embeddingAudioFile">Audio File to Transcribe and
                    Embed</label>
                  <input type="file" class="text-box w-full" id="embeddingAudioFile" accept="audio/*" />
                </div>
                <div class="mb-4">
                  <label class="label" for="audio_semantic_query_string">Semantic Query String
                    (Optional):</label>
                  <input class="text-box w-full" id="audio_semantic_query_string" type="text" placeholder="Enter your query" />
                </div>
              </div>
      
              <div id="askQuestionAboutImageSettings" class="col-span-full" style="display: none">
                <div class="mb-4">
                  <label class="label" for="imageFile">Image File</label>
                  <input type="file" class="text-box w-full" id="imageFile" accept="image/*" />
                </div>
                <div class="mb-4">
                  <label class="label" for="question">Question</label>
                  <input class="text-box w-full" id="question" type="text" placeholder="Enter your question" />
                </div>
              </div>

              <div class="col-span-full flex justify-between">
                <div class="flex gap-4 items-center" style="width: 100%">
                  <button class="button-contained" type="submit">
                    Create Inference Request
                  </button>
                </div>
              </div>
              <div class="prompt success xs mt-4 small" id="currentStatusContainer">
                <label class="text-bw-800 font-bold mb-4" for="currentStatus">Current Status:</label>
                <div class="content p-2" id="currentStatus"></div>
              </div>

              <div id="inferenceRequestResult" class="mt-4 hidden"></div>
            </form>
          </div>

          <!--View Previous Inference Requests-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="inferenceRequests">
            <div class="lg:col-span-1 flex flex-col">
              <h2 class="text-xl font-bold text-bw-800">
                View Previous Inference Requests
              </h2>
              <div id="previousRequestsList" class="bg-gray-100 p-4 rounded-lg overflow-y-auto flex-grow mt-3"
                style="max-height: 1200px">
                <!-- List of previous inference requests will be dynamically populated here -->
              </div>
              <button id="exportRequestsButton" class="btn success outline mt-4 flex items-center self-start">
                💾 Export all Saved Inference Requests
              </button>
            </div>
            <div id="requestPreview" class="lg:col-span-2 bg-gray-50 p-4 rounded-lg">
              <!-- Preview of selected inference request will be shown here -->
            </div>
          </div>
        </div>

        <div class="grid gap-4 grid-cols-2 mt-4">
          <!--Send and Receive Messages using PastelIDs-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white" id="sendAndReceiveMessages">
            <div>
              <h2 class="text-xl font-bold text-bw-800">
                Send and Receive Messages using PastelIDs
              </h2>
              <form id="sendMessageForm" class="grid grid-cols-1 gap-4 mt-3">
                <div>
                  <label class="block text-bw-700 font-bold mb-2" for="toPastelID">Recipient Pastel ID</label>
                  <input class="input w-full" id="toPastelID" type="text" placeholder="Enter recipient Pastel ID"
                    value="jXXiVgtFzLto4eYziePHjjb1hj3c6eXdABej5ndnQ62B8ouv1GYveJaD5QUMfainQM3b4MTieQuzFEmJexw8Cr" />
                </div>
                <div>
                  <label class="block text-bw-700 font-bold mb-2" for="messageBody">Message Body</label>
                  <textarea class="input w-full" id="messageBody" rows="5" placeholder="Enter your message">
      Hello, this is a brand 🍉 NEW test message from a regular user!</textarea>
                </div>
                <div class="flex justify-between">
                  <button class="btn success outline" type="submit">
                    Send Message
                  </button>
                </div>
              </form>
            </div>
            <div class="mt-5">
              <h2 class="text-xl font-bold text-bw-800">Received Messages</h2>
              <div id="receivedMessages" class="bg-bw-50 p-4 rounded-xl">
                <!-- Received messages will be dynamically populated here -->
              </div>
            </div>
          </div>

          <!--Manage Wallet-->
          <div class="border-color p-6 rounded-2xl shadow-xl bg-white" id="manageWallet">
            <h2 class="text-xl font-bold text-bw-800">Manage Wallet</h2>
            <div class="mb-4">
              <label class="block text-bw-700 font-bold mb-2" for="importPrivKey">
                Import Private Key
                <span class="tooltip" data-tooltip="Import a private key into your wallet.">&#9432;</span>
              </label>
              <input id="importPrivKey" class="input w-full" type="text" placeholder="Enter private key" />
              <button id="importPrivKeyButton" class="btn success outline mt-2">
                Import Private Key
              </button>
            </div>
            <div class="mb-4">
              <label class="block text-bw-700 font-bold mb-2" for="importWallet">
                Import Wallet
                <span class="tooltip" data-tooltip="Import a wallet file into your wallet.">&#9432;</span>
              </label>
              <input id="importWallet" class="input w-full" type="file" accept=".dat" />
              <button id="importWalletButton" class="btn success outline mt-2">
                Import Wallet
              </button>
            </div>
            <label class="block text-bw-700 font-bold mb-2" for="listAddressAmountsButton">
              Misc Functions:
            </label>
      
            <div class="mb-4">
              <button id="listAddressAmountsButton" class="btn success outline">
                List Address Amounts
                <span class="tooltip" data-tooltip="List the amounts associated with each address in your wallet.">
                  &#9432;
                </span>
              </button>
      
              <div id="addressAmountsContainer" class="mt-4" style="display: none; position: relative">
                <h2 class="text-2xl text-bw-800">Address Amounts:</h2>
                <button id="copyAddressAmountsButton" class="btn success outline" style="
                      position: absolute;
                      top: -1.5rem;
                      right: 0.5rem;
                      display: none;
                    ">
                  📋
                </button>
                <div class="table-responsive">
                  <table id="addressAmountsTable" class="table bordered bw"></table>
                </div>
              </div>
            </div>
      
            <div class="mb-4">
              <button id="getWalletInfoButton" class="btn success outline">
                Get Wallet Info
                <span class="tooltip" data-tooltip="Retrieve information about your wallet.">
                  &#9432;
                </span>
              </button>
      
              <div id="walletInfoContainer" class="mt-4" style="display: none; position: relative">
                <h2 class="text-2xl text-bw-800">Wallet Info:</h2>
                <button id="copyWalletInfoButton" class="btn success outline" style="
                      position: absolute;
                      top: -1.5rem;
                      right: 0.5rem;
                      display: none;
                    ">
                  📋
                </button>
                <div class="table-responsive">
                  <table id="walletInfoTable" class="table bordered bw"></table>
                </div>
              </div>
            </div>
      
            <div class="mb-4">
              <button id="clearLocalStorageButton" class="btn success outline">
                Clear Inference Client Local Storage
                <span class="tooltip" data-tooltip="Clear all local storage data for this page.">
                  &#9432;
                </span>
              </button>
            </div>
          </div>
        </div>

        <div class="grid gap-4 grid-cols-1 mt-4">
          <!--Terminal-->
          <div class="border-color p-20px rounded-2xl shadow-xl bg-white">
            <div class="flex justify-between item-center">
              <h2 class="text-xl font-bold text-bw-800">Terminal</h2>
              <div class="flex justify-center">
                <div class="inline-flex items-center gap-2">
                  <input class="switch success lg" data-content=" " type="checkbox" onchange="toggleTerminal()" />
                  <span class="label mb-0">Toggle Terminal</span>
                </div>
              </div>
            </div>
            <div id="terminal" class="bg-gray-900 text-white p-4 mt-3"></div>
            <div class="flex justify-end mt-2">
              <button id="exportTerminalButton" class="button-contained ml-2 w-auto">
                Export Terminal Session Text
              </button>
            </div>
          </div>
        </div>
      </main>
      <footer class="py-4 p-20px bg-gray-50 flex justify-center items-center">
        <p class="text-center">
          &copy; 2024 Pastel Inference Client UI. All rights reserved.
        </p>
      </footer>
    </div>
  </div>

  <script>
    const MESSAGING_TIMEOUT_IN_SECONDS = 60;
    const LOADING_MESSAGE = "Wait while data is loaded...";
    const STORAGE_KEY = "validCreditPackTickets";
    const STORAGE_TIMESTAMP_KEY = "creditPackTicketsTimestamp";
    const REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    function formatNumberWithCommas(number) {
      return number.toLocaleString();
    }

    function parseAndFormatNumber(value) {
      const number = parseFloat(value.replace(/,/g, ""));
      return isNaN(number) ? value : formatNumberWithCommas(number);
    }

    function handleInputChange(event) {
      const inputElement = event.target;
      if (inputElement.type === "file") {
        return;
      }
      const rawValue = inputElement.value.replace(/,/g, "");
      inputElement.setAttribute("data-raw-value", rawValue);
    }

    function handleInputBlur(event) {
      const inputElement = event.target;
      if (inputElement.type === "file") {
        return;
      }
      const formattedValue = parseAndFormatNumber(inputElement.value);
      inputElement.value = formattedValue;
    }

    async function fetchImageSize(url) {
      const response = await fetch(url);
      const blob = await response.blob();
      return blob.size;
    }

    async function getMyPslAddressWithLargestBalance() {
      try {
        const response = await axios.get(
          "/get-my-psl-address-with-largest-balance"
        );
        return response.data.result;
      } catch (error) {
        console.error(
          "Error retrieving PSL address with largest balance:",
          error
        );
        return "";
      }
    }

    function parseAndFormat(value) {
      try {
        if (typeof value === "string") {
          // Check if the JSON string is already formatted
          if (value.includes("\n")) {
            return value;
          }
          // Parse JSON string to handle it properly
          const parsedValue = JSON.parse(value);
          return JSON.stringify(parsedValue, null, 4); // Indent JSON string
        }
        return JSON.stringify(value, null, 4); // Format other values
      } catch (error) {
        return value; // Return original value if parsing fails
      }
    }

    function prettyJSON(data) {
      if (data instanceof Map) {
        data = Object.fromEntries(data); // Convert Map to object
      }
      if (
        Array.isArray(data) ||
        (typeof data === "object" && data !== null)
      ) {
        const formattedData = {};
        for (const [key, value] of Object.entries(data)) {
          if (typeof value === "string" && key.endsWith("_json")) {
            formattedData[key] = parseAndFormat(value);
          } else if (typeof value === "object" && value !== null) {
            formattedData[key] = prettyJSON(value); // Recurse for nested objects
          } else {
            formattedData[key] = value; // Handle other types
          }
        }
        return JSON.stringify(formattedData, null, 4); // Pretty print the object
      } else if (typeof data === "string") {
        return parseAndFormat(data); // Handle strings separately
      }
      return data; // Return data as is for other types
    }

    function sanitizeJSON(jsonString) {
      return jsonString.replace(/[^\x20-\x7E]+/g, ""); // Remove non-printable ASCII characters
    }

    function fallbackParseResult(result) {
      // If the result starts with {"text": ", strip it and the ending }
      if (result.startsWith(' {"text": "')) {
        result = result.slice(10); // Remove the prefix {"text": "
        const endIndex = result.indexOf('"}');
        if (endIndex !== -1) {
          result = result.slice(0, endIndex); // Remove the closing }
        }
      }

      // Remove anything including and after "} {"prompt":" from the end of the string
      const promptPattern = /"} {"prompt":".*$/;
      result = result.replace(promptPattern, "");

      return result;
    }

    async function fetchValidPastelIDs() {
      try {
        const response = await axios.get("/list-pastel-id-tickets", {
          params: { filter: "mine" },
        });
        return response.data.result.map((ticket) => ticket.ticket.pastelID);
      } catch (error) {
        console.error("Error retrieving Pastel ID tickets:", error);
        return [];
      }
    }

    function formatAndHighlightMessage(message) {
      const parts = message.split(/(\{[\s\S]*?\})/);
      return parts
        .map((part) => {
          try {
            if (part.startsWith("{") && part.endsWith("}")) {
              const parsed = JSON.parse(part);
              const formatted = prettyJSON(parsed);
              return `<pre><code class="json">${hljs.highlight(formatted, {
                language: "json",
                ignoreIllegals: true,
              }).value
                }</code></pre>`;
            }
          } catch (e) {
            // If parsing fails, fall through to return the part as plain text
          }
          return `<span>${part}</span>`;
        })
        .join("");
    }

    function logCreateTicketStatusMessage(message, container) {
      if (message.includes("ECONNREFUSED")) return;
      container.innerHTML = ""; // Clear previous log messages
      const logElement = document.createElement("div");
      logElement.style.fontFamily = "Montserrat, sans-serif";
      logElement.innerHTML = formatAndHighlightMessage(message);
      container.appendChild(logElement);
      container.scrollTop = container.scrollHeight; // Scroll to bottom
    }

    function logStatusMessage(message) {
      if (message.includes("ECONNREFUSED")) return;
      const currentStatus = document.getElementById("currentStatus");
      currentStatus.style.fontFamily = "Montserrat, sans-serif";
      currentStatus.style.whiteSpace = "pre-wrap"; // Ensure wrapping
      currentStatus.innerHTML = formatAndHighlightMessage(message);
    }

    function abbreviateJSON(jsonString, maxLength) {
      if (jsonString.length <= maxLength) return jsonString;
      const abbreviated = jsonString.slice(0, maxLength) + "...";
      const openBraces =
        (jsonString.match(/{/g) || []).length -
        (abbreviated.match(/{/g) || []).length;
      const openBrackets =
        (jsonString.match(/\[/g) || []).length -
        (abbreviated.match(/\[/g) || []).length;
      return (
        abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets)
      );
    }

    function logActionWithPayload(action, payloadName, jsonPayload) {
      const maxPayloadLength = 10000;
      let formattedPayload = prettyJSON(jsonPayload);
      if (formattedPayload.length > maxPayloadLength) {
        formattedPayload = abbreviateJSON(
          formattedPayload,
          maxPayloadLength
        );
      }
      logger.info(
        `Now ${action} ${payloadName} with payload:\n${formattedPayload}`
      );
    }

    async function setSelectedPastelIDAndPassphrase(selectedPastelID) {
      let storedPassphrase = localStorage.getItem(selectedPastelID);

      if (!storedPassphrase) {
        const dialogHtml = `
          <div style="background-color: rgba(0, 0, 0, 0.5); position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center;">
            <div style="background-color: white; padding: 20px; border-radius: 5px; text-align: center;">
              <h2 style="margin-bottom: 10px;">Enter passphrase for PastelID:</h2>
              <p style="font-weight: bold; margin-bottom: 10px;">${selectedPastelID}</p>
              <input type="password" id="passphraseInput" style="margin-bottom: 10px; padding: 5px; width: 100%;">
              <div>
                <button id="submitPassphrase" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">Submit</button>
              </div>
            </div>
          </div>
        `;

        const dialog = document.createElement("div");
        dialog.innerHTML = dialogHtml;
        document.body.appendChild(dialog);

        return new Promise((resolve) => {
          const submitButton = dialog.querySelector("#submitPassphrase");
          const passphraseInput = dialog.querySelector("#passphraseInput");

          submitButton.addEventListener("click", async () => {
            const inputPassphrase = passphraseInput.value;
            if (inputPassphrase) {
              try {
                localStorage.setItem(
                  selectedPastelID,
                  btoa(inputPassphrase)
                );
                storedPassphrase = btoa(inputPassphrase);
                dialog.remove();
                await postPassphrase(selectedPastelID, storedPassphrase);
                resolve();
              } catch (error) {
                console.error("Error handling passphrase:", error);
              }
            } else {
              console.error("No passphrase entered");
            }
          });
        });
      } else {
        await postPassphrase(selectedPastelID, storedPassphrase);
      }

      async function postPassphrase(pastelID, encodedPassphrase) {
        try {
          await axios.post("/set-pastel-id-passphrase", {
            pastelID: pastelID,
            passphrase: atob(encodedPassphrase),
          });

          // Fetch the model menu after setting the PastelID and passphrase
          await fetchModelMenu();

          // Fetch received messages after setting the PastelID and passphrase
          await fetchReceivedMessages();
        } catch (error) {
          console.error("Error setting PastelID and passphrase:", error);
        }
      }
    }

    function togglePastelIDDropdown() {
      const dropdown = document.getElementById("pastelIDDropdown");
      const dropdownContainer = document.getElementById("pastelIDDropdownContainer");
      dropdown.classList.toggle("hidden");
      dropdownContainer.classList.toggle("hidden");
    }

    function updatePastelIDSelection() {
      const selectedID = document.getElementById("pastelIDDropdown").value;
      document.getElementById("userPastelID").textContent =
        selectedID || "No PastelID selected";
    }

    async function checkCreditPackTicketInfo(txid) {
      try {
        const response = await axios.get(`/credit-pack-info/${txid}`);
        const { requestResponse, requestConfirmation, balanceInfo } =
          response.data;
        document.getElementById("requestResponse").textContent =
          JSON.stringify(requestResponse, null, 2);
        document.getElementById("requestConfirmation").textContent =
          JSON.stringify(requestConfirmation, null, 2);
        document.getElementById("currentCreditBalance").textContent =
          balanceInfo.current_credit_balance;
        document.getElementById("numberOfTransactions").textContent =
          balanceInfo.number_of_confirmation_transactions;
      } catch (error) {
        console.error("Error checking credit pack ticket info:", error);
        document.getElementById("requestResponse").textContent =
          "Failed to load credit pack info";
        document.getElementById("requestConfirmation").textContent = "";
        document.getElementById("currentCreditBalance").textContent = "";
        document.getElementById("numberOfTransactions").textContent = "";
      }
    }

    function getAddressURL(address) {
      let baseURL = "https://explorer.pastel.network/address/";
      if (address.startsWith("44")) {
        baseURL = "https://explorer-devnet.pastel.network/address/";
      } else if (address.startsWith("tP")) {
        baseURL = "https://explorer-testnet.pastel.network/address/";
      }
      return `${baseURL}${address}`;
    }

    function getTxidURL(trackingAddress, txid) {
      let baseURL = "https://explorer.pastel.network/tx/";
      if (trackingAddress.startsWith("44")) {
        baseURL = "https://explorer-devnet.pastel.network/tx/";
      } else if (trackingAddress.startsWith("tP")) {
        baseURL = "https://explorer-testnet.pastel.network/tx/";
      }
      return `${baseURL}${txid}`;
    }

    async function listPastelIDTickets() {
      try {
        const response = await axios.get("/list-pastel-id-tickets", {
          params: { filter: "mine" },
        });
        return response.data.result;
      } catch (error) {
        console.error("Error retrieving Pastel ID tickets:", error);
        return [];
      }
    }

    async function checkTrackingAddresses() {
      try {
        const response = await fetch("/list-address-amounts");
        if (!response.ok) {
          throw new Error("Failed to fetch address amounts");
        }
        const data = await response.json();
        const walletAddresses = Object.keys(data.result);

        const trackingAddresses =
          document.querySelectorAll(".tracking-address");
        trackingAddresses.forEach((element) => {
          const address = element.textContent.trim();
          if (walletAddresses.includes(address)) {
            element.classList.add("valid-address");
            element.classList.remove("invalid-address");
          } else {
            element.classList.add("invalid-address");
            element.classList.remove("valid-address");
          }
        });
      } catch (error) {
        console.error("Error checking tracking addresses:", error.message);
      }
    }

    async function getMyValidCreditPacks(forceRefresh = false) {
      const loadingMessage = document.getElementById("loadingMessage");
      const tableBody = document.getElementById(
        "creditPackTicketTableBody"
      );
      loadingMessage.style.display = "block";

      try {
        let validCreditPackTickets = [];
        const now = new Date().getTime();

        if (!forceRefresh) {
          const savedData = localStorage.getItem(STORAGE_KEY);
          const savedTimestamp = localStorage.getItem(
            STORAGE_TIMESTAMP_KEY
          );

          if (
            savedData &&
            savedTimestamp &&
            now - savedTimestamp < REFRESH_INTERVAL
          ) {
            validCreditPackTickets = JSON.parse(savedData);
          } else {
            const response = await axios.get("/get-my-valid-credit-packs");
            validCreditPackTickets = response.data.result;
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify(validCreditPackTickets)
            );
            localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
          }
        } else {
          const response = await axios.get("/get-my-valid-credit-packs");
          validCreditPackTickets = response.data.result;
          localStorage.setItem(
            STORAGE_KEY,
            JSON.stringify(validCreditPackTickets)
          );
          localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
        }

        // Fetch wallet addresses
        const walletResponse = await axios.get("/list-address-amounts");
        const walletAddresses = Object.keys(walletResponse.data.result);

        // Filter valid credit pack tickets based on tracking addresses
        validCreditPackTickets = validCreditPackTickets.filter((ticket) =>
          walletAddresses.includes(
            ticket.credit_pack_purchase_request
              .credit_usage_tracking_psl_address
          )
        );

        tableBody.innerHTML = "";

        // Filter out credit packs with 0 or negative balance
        validCreditPackTickets = validCreditPackTickets.filter(
          (ticket) => ticket.credit_pack_current_credit_balance > 0
        );

        // Find the credit pack with the highest current credit balance
        let highestBalanceTicket = validCreditPackTickets[0];
        for (const ticket of validCreditPackTickets) {
          if (
            ticket.credit_pack_current_credit_balance >
            highestBalanceTicket.credit_pack_current_credit_balance
          ) {
            highestBalanceTicket = ticket;
          }
        }

        for (const ticket of validCreditPackTickets) {
          const row = document.createElement("tr");

          const radioCell = document.createElement("td");
          const radioInput = document.createElement("input");
          radioInput.type = "radio";
          radioInput.name = "creditPackTicket";
          radioInput.value =
            ticket.credit_pack_purchase_request.requesting_end_user_pastelid;
          radioInput.dataset.txid =
            ticket.credit_pack_purchase_request_confirmation.txid_of_credit_purchase_burn_transaction;
          radioCell.appendChild(radioInput);
          row.appendChild(radioCell);

          const initialCreditsCell = document.createElement("td");
          initialCreditsCell.classList.add("truncate");
          initialCreditsCell.textContent = formatNumberWithCommas(
            ticket.credit_pack_purchase_request
              .requested_initial_credits_in_credit_pack
          );
          row.appendChild(initialCreditsCell);

          const currentCreditsCell = document.createElement("td");
          currentCreditsCell.classList.add("truncate");
          currentCreditsCell.textContent = formatNumberWithCommas(
            ticket.credit_pack_current_credit_balance
          );
          row.appendChild(currentCreditsCell);

          const trackingAddressCell = document.createElement("td");
          trackingAddressCell.classList.add("truncate", "tracking-address");
          const addressLink = document.createElement("a");
          addressLink.href = getAddressURL(
            ticket.credit_pack_purchase_request
              .credit_usage_tracking_psl_address
          );
          addressLink.target = "_blank";
          addressLink.textContent =
            ticket.credit_pack_purchase_request.credit_usage_tracking_psl_address;
          trackingAddressCell.appendChild(addressLink);
          row.appendChild(trackingAddressCell);

          const blockheightCell = document.createElement("td");
          blockheightCell.classList.add("truncate");
          blockheightCell.textContent = formatNumberWithCommas(
            ticket.credit_pack_purchase_request.request_pastel_block_height
          );
          row.appendChild(blockheightCell);

          const creditPackRegistrationTxidCell =
            document.createElement("td");
          creditPackRegistrationTxidCell.classList.add("truncate");
          const txLink = document.createElement("a");
          txLink.href = getTxidURL(
            ticket.credit_pack_purchase_request
              .credit_usage_tracking_psl_address,
            ticket.credit_pack_registration_txid
          );
          txLink.target = "_blank";
          txLink.textContent = ticket.credit_pack_registration_txid;
          creditPackRegistrationTxidCell.appendChild(txLink);
          row.appendChild(creditPackRegistrationTxidCell);

          tableBody.appendChild(row);
          if (ticket === highestBalanceTicket) {
            radioInput.checked = true;
            row.classList.add("bg-gray-200", "selected-row");
          }
        }

        handleCreditPackSelection(); // Re-apply event listeners
        if (validCreditPackTickets.length > 0) {
          let highestBalanceTicket = validCreditPackTickets[0];
          for (const ticket of validCreditPackTickets) {
            if (
              ticket.credit_pack_current_credit_balance >
              highestBalanceTicket.credit_pack_current_credit_balance
            ) {
              highestBalanceTicket = ticket;
            }
          }
          const highestBalanceRadioInput = Array.from(
            tableBody.querySelectorAll('input[type="radio"]')
          ).find(
            (input) =>
              input.value ===
              highestBalanceTicket.credit_pack_purchase_request
                .requesting_end_user_pastelid
          );
          if (highestBalanceRadioInput) {
            highestBalanceRadioInput.checked = true;
            highestBalanceRadioInput.dispatchEvent(new Event("change"));
          }
        }
      } catch (error) {
        console.error("Error retrieving valid credit pack tickets:", error);
      } finally {
        loadingMessage.style.display = "none";
      }
    }

    async function createNewCreditPackTicket(
      numCredits,
      maxTotalPrice,
      maxPerCreditPrice
    ) {
      const statusContainer = document.getElementById(
        "createTicketStatusContainer"
      );
      const statusContent = document.getElementById("createTicketStatus");
      const loaderContainer = document.getElementById("loaderContainer");

      if (!statusContainer || !statusContent || !loaderContainer) {
        console.error(
          "Status container, status content, or loader container element not found."
        );
        return;
      }

      statusContent.innerHTML = "";
      loaderContainer.innerHTML = "";

      let creditPackLoader = document.createElement("div");
      creditPackLoader.className = "btn is-loading";
      creditPackLoader.innerText = "Loading...";
      loaderContainer.appendChild(creditPackLoader);

      const newTicketDetailsContainer = document.getElementById(
        "newCreditPackTicketDetailsContainer"
      );
      const newTicketDetails = document.getElementById(
        "newCreditPackTicketDetails"
      );

      if (!newTicketDetailsContainer || !newTicketDetails) {
        console.error(
          "New ticket details container or new ticket details element not found."
        );
        return;
      }

      displayCreateTicketLoggerMessages = true;

      try {
        logCreateTicketStatusMessage(
          "Starting the creation of a new credit pack ticket...",
          statusContent
        );

        const desiredNumberOfCredits = numCredits;
        const amountOfPSLForTrackingTransactions = 10.0;
        const creditPriceCushionPercentage = 0.15;

        const estimatedTotalCostInPSLForCreditPackResponse =
          await axios.post("/estimate-credit-pack-cost", {
            desiredNumberOfCredits,
            creditPriceCushionPercentage,
          });

        const estimatedTotalCostInPSLForCreditPack =
          estimatedTotalCostInPSLForCreditPackResponse.data.result;

        if (estimatedTotalCostInPSLForCreditPack === undefined) {
          throw new Error(
            "Failed to estimate total cost for the credit pack"
          );
        }

        const amountToFundCreditTrackingAddress = Math.round(
          amountOfPSLForTrackingTransactions +
          estimatedTotalCostInPSLForCreditPack
        );

        const walletBalance = parseFloat(
          document
            .getElementById("walletBalance")
            .textContent.replace(/,/g, "")
        );
        if (amountToFundCreditTrackingAddress > walletBalance) {
          const insufficientFundsMessage = `The purchase of this credit pack would require ${amountToFundCreditTrackingAddress.toLocaleString()} PSL, but you only have ${walletBalance.toLocaleString()} PSL in your wallet. Please send at least ${(
            amountToFundCreditTrackingAddress - walletBalance
          ).toLocaleString()} more PSL to your wallet and try again. Alternatively, you can reduce the number of credits in the credit pack you are trying to purchase to ${Math.floor(
            walletBalance /
            (estimatedTotalCostInPSLForCreditPack / numCredits)
          ).toLocaleString()} credits instead of ${numCredits.toLocaleString()} credits.`;

          const errorMessageElement = document.createElement("div");
          errorMessageElement.classList.add(
            "text-red-800",
            "font-bold",
            "mt-4"
          );
          errorMessageElement.textContent = insufficientFundsMessage;
          statusContent.appendChild(errorMessageElement);

          console.error(insufficientFundsMessage);
          throw new Error(insufficientFundsMessage);
        }

        const response = await axios.post("/create-and-fund-new-address", {
          amount: amountToFundCreditTrackingAddress,
        });

        if (!response.data.success) {
          throw new Error(
            "Failed to create and fund new credit tracking address"
          );
        }

        const creditUsageTrackingPSLAddress =
          response.data.result.newCreditTrackingAddress;

        logCreateTicketStatusMessage(
          "Credit tracking address created and funded successfully.",
          statusContent
        );

        const ticketResponse = await axios.post(
          "/create-credit-pack-ticket",
          {
            numCredits,
            creditUsageTrackingPSLAddress,
            maxTotalPrice,
            maxPerCreditPrice,
          }
        );

        if (ticketResponse.data.success) {
          logCreateTicketStatusMessage(
            "Credit pack ticket created successfully.",
            statusContent
          );
          const result = ticketResponse.data.result;
          const formattedResult = prettyJSON(result);
          logCreateTicketStatusMessage(
            `Result: ${formattedResult}`,
            statusContent
          );

          newTicketDetails.innerHTML = `
      <tr>
        <td class="truncate">
          <a href="${getTxidURL(
            creditUsageTrackingPSLAddress,
            result.pastel_api_credit_pack_ticket_registration_txid
          )}" target="_blank">
            ${result.pastel_api_credit_pack_ticket_registration_txid}
          </a>
        </td>
        <td class="truncate">${result.sha3_256_hash_of_credit_pack_purchase_request_fields}</td>
        <td class="truncate">${result.responding_supernode_pastelid}</td>
        <td class="truncate">${result.credit_pack_confirmation_outcome_string}</td>
      </tr>
    `;

          newTicketDetailsContainer.style.display = "block";

          logCreateTicketStatusMessage(
            "Credit pack ticket created. Waiting for blockchain confirmation...",
            statusContent
          );

          pollCreditPackStatus(result.pastel_api_credit_pack_ticket_registration_txid);

          return result;
        } else {
          throw new Error("Failed to create new credit pack ticket");
        }
      } catch (error) {
        console.error(
          `Error creating new credit pack ticket: ${error.message}`
        );
        logCreateTicketStatusMessage(
          "Failed to create credit pack ticket. Please try again.",
          statusContent
        );
        throw error;
      } finally {
        creditPackLoader.remove();
        displayCreateTicketLoggerMessages = false;
      }
    }

    function pollCreditPackStatus(txid) {
      const pollInterval = 30000; // 30 seconds
      const maxAttempts = 20; // 10 minutes total
      let attempts = 0;

      const checkStatus = async () => {
        try {
          const response = await axios.get(`/credit-pack-status/${txid}`);
          if (response.data.confirmed) {
            logCreateTicketStatusMessage(
              "Credit pack ticket has been confirmed. Refreshing the table...",
              document.getElementById("createTicketStatus")
            );
            await getMyValidCreditPacks(true);
            logCreateTicketStatusMessage(
              "Credit pack ticket is now available for use.",
              document.getElementById("createTicketStatus")
            );
          } else {
            attempts++;
            if (attempts < maxAttempts) {
              logCreateTicketStatusMessage(
                `Waiting for credit pack ticket confirmation... (Attempt ${attempts}/${maxAttempts})`,
                document.getElementById("createTicketStatus")
              );
              setTimeout(checkStatus, pollInterval);
            } else {
              logCreateTicketStatusMessage(
                "Credit pack ticket confirmation is taking longer than expected. It should appear soon. You can manually refresh the table to check.",
                document.getElementById("createTicketStatus")
              );
            }
          }
        } catch (error) {
          console.error("Error checking credit pack status:", error);
          logCreateTicketStatusMessage(
            "An error occurred while checking the credit pack status. Please try refreshing the table manually.",
            document.getElementById("createTicketStatus")
          );
        }
      };

      checkStatus();
    }

    // Handle inference request stuff:
    let modelMenu = null;

    async function fetchModelMenu() {
      try {
        const response = await axios.get("/get-inference-model-menu");
        modelMenu = response.data.modelMenu;
        console.log("Model Menu:", modelMenu); // Debugging line, consider removing for production
        populateModelDropdown();
      } catch (error) {
        console.error("Error fetching model menu:", error);
        //displayError("Failed to load model menu. Please try again later.");
      }
    }

    function handleModelChange() {
      const selectedModelName = document.getElementById("model").value;
      const selectedModel = modelMenu.models.find(
        (model) => model.model_name === selectedModelName
      );

      if (selectedModel) {
        generateModelParameterFields(selectedModel);
      }
    }

    function generateModelParameterFields(selectedModel) {
      const modelParametersContainer = document.getElementById(
        "modelParametersContainer"
      );
      modelParametersContainer.innerHTML = "";
      const selectedInferenceType =
        document.getElementById("inferenceType").value;

      // Filter parameters based on the selected inference type
      const applicableParameters = selectedModel.model_parameters.filter(
        (param) =>
          JSON.parse(
            param.inference_types_parameter_applies_to.replace(/'/g, '"')
          ).includes(selectedInferenceType)
      );

      applicableParameters.forEach((param) => {
        const fieldContainer = document.createElement("div");
        fieldContainer.className = "mb-4";

        const labelText = param.description.split("[Optional]")[0].trim();
        const tooltipText =
          param.description
            .split("[Optional]")[1]
            ?.trim()
            .replace(/^\(|\)$/g, "") || "";

        const label = document.createElement("label");
        label.className =
          "block font-bold mb-2" +
          (param.description.includes("[Optional]") ? " text-bw-800" : "");
        label.htmlFor = param.name;
        label.textContent = labelText;
        fieldContainer.appendChild(label);

        if (tooltipText) {
          const tooltipSpan = document.createElement("span");
          tooltipSpan.className = "tooltip bw top";
          tooltipSpan.dataset.tooltip = tooltipText;
          const tooltipButton = document.createElement("button");
          tooltipButton.className = "tooltip-icon";
          tooltipButton.textContent = "ⓘ";
          tooltipSpan.appendChild(tooltipButton);
          label.appendChild(tooltipSpan);
        }

        const input = document.createElement("input");
        input.className = "input w-full";
        input.id = param.name;
        input.name = param.name;
        input.type =
          param.type === "float" || param.type === "int"
            ? "number"
            : "text";
        input.placeholder = `Enter ${param.description.toLowerCase()}`;
        input.value = param.default;

        if (param.name === "number_of_tokens_to_generate") {
          input.min = "1";
          input.max = "5000";
          input.step = "1";
        } else if (param.name === "temperature") {
          input.min = "0";
          input.max = "1";
          input.step = "0.01";
        } else if (param.name === "number_of_completions_to_generate") {
          input.min = "1";
          input.max = "10";
          input.step = "1";
        } else if (
          param.name === "grammar_file_string" ||
          param.name === "query_string" ||
          param.name === "corpus_identifier_string"
        ) {
          input.type = "text"; // Ensure it's a text input
        }

        fieldContainer.appendChild(input);
        modelParametersContainer.appendChild(fieldContainer);
      });
    }

    function populateModelDropdown() {
      const selectedInferenceType = inferenceTypeSelect.value;
      const modelSelect = document.getElementById("model");
      modelSelect.innerHTML =
        '<option value="">Select a model/service</option>';

      if (modelMenu) {
        if (selectedInferenceType === "ask_question_about_an_image") {
          const relevantModels = modelMenu.models.filter((model) =>
            model.supported_inference_type_strings.includes(
              selectedInferenceType
            )
          );

          relevantModels.forEach((model) => {
            const option = document.createElement("option");
            option.value = model.model_name;
            option.textContent = model.model_name;
            modelSelect.appendChild(option);
          });

          if (relevantModels.length > 0) {
            modelSelect.options[1].selected = true;
            generateModelParameterFields(relevantModels[0]);
          }
        } else {
          const filteredModels = modelMenu.models.filter(
            (model) =>
              model.supported_inference_type_strings &&
              model.supported_inference_type_strings.includes(
                selectedInferenceType
              )
          );

          filteredModels.forEach((model) => {
            const option = document.createElement("option");
            option.value = model.model_name;
            option.textContent = model.model_name;
            modelSelect.appendChild(option);
          });

          if (filteredModels.length > 0) {
            modelSelect.options[1].selected = true;
            generateModelParameterFields(filteredModels[0]);
          }
        }
      }
    }

    function displayError(message) {
      // Implement user-friendly error handling/display mechanism
      alert(message); // Simplistic example, consider more sophisticated modal or notification systems
    }

    // Load inference request settings from localStorage
    function loadInferenceRequestSettings() {
      const selectedInferenceType = inferenceTypeSelect.value;
      const storedSettings = localStorage.getItem(
        `inferenceRequestSettings_${selectedInferenceType}`
      );
      if (storedSettings) {
        const settings = JSON.parse(storedSettings);
        document.getElementById("model").value = settings.model || "";
        document.getElementById("prompt").value = settings.prompt || "";
        document.getElementById("maxCost").value = settings.maxCost || "";
        document.getElementById("imagePrompt").value =
          settings.imagePrompt || "";
      }
    }

    // Save inference request settings to localStorage
    function saveInferenceRequestSettings() {
      const selectedInferenceType = inferenceTypeSelect.value;
      const settings = {
        model: document.getElementById("model").value,
        prompt: document.getElementById("prompt").value,
        maxCost: document.querySelector("#maxCost").dataset.rawValue,
        imagePrompt: document.getElementById("imagePrompt").value,
      };
      localStorage.setItem(
        `inferenceRequestSettings_${selectedInferenceType}`,
        JSON.stringify(settings)
      );
    }

    async function pollWalletAndPastelIDStatus(pastelID) {
      const pollInterval = 30000; // 30 seconds
      const maxAttempts = 20; // 10 minutes total
      let attempts = 0;

      const checkStatus = async () => {
        try {
          const response = await axios.get(`/check-pastel-id-status/${pastelID}`);
          const walletResponse = await axios.get("/get-wallet-info");
          const walletBalance = walletResponse.data.result.balance;
          if (response.data.registered && walletBalance > 0) {
            updateCreatePastelIDStatus("Your PastelID has been registered and your wallet has been funded. The page will refresh shortly.");
            setTimeout(() => location.reload(), 5000);
          } else {
            attempts++;
            if (attempts < maxAttempts) {
              let message = "PastelID registration and wallet funding in progress...";
              if (response.data.registered) {
                message = "PastelID registered. Waiting for wallet to be funded...";
              } else if (walletBalance > 0) {
                message = "Wallet funded. Waiting for PastelID registration...";
              }
              updateCreatePastelIDStatus(`${message} (Attempt ${attempts}/${maxAttempts})`);
              setTimeout(checkStatus, pollInterval);
            } else {
              updateCreatePastelIDStatus("The process is taking longer than expected. Please refresh the page in a few minutes.");
            }
          }
        } catch (error) {
          console.error("Error checking PastelID and wallet status:", error);
          updateCreatePastelIDStatus("An error occurred while checking your PastelID and wallet status. Please refresh the page in a few minutes.");
        }
      };

      checkStatus();
    }

    function updateCreatePastelIDStatus(content) {
      const createPastelIDLoadingText = document.querySelector('#createPastelIDLoadingText');
      createPastelIDLoadingText.innerHTML = content;
    }

    createPastelIDForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const passphrase = document.getElementById("newPastelIDPassphrase").value;
      if (passphrase.length < 6) {
        displayMessage("Passphrase must be at least 6 characters long.", false);
        return;
      }
      try {
        displayLoading(true);
        const createPastelIDLoading = document.querySelector('#createPastelIDLoading');
        createPastelIDLoading.classList.remove('hidden');
        updateCreatePastelIDStatus("Start create and register PastelID.");
        const response = await axios.post("/create-and-register-pastel-id", {
          passphraseForNewPastelID: passphrase,
        });
        displayLoading(false);
        if (response.data.success) {
          updateCreatePastelIDStatus(`PastelID creation initiated. Your new PastelID is ${response.data.PastelID}. Please wait while it's being registered on the blockchain...`);
          localStorage.setItem(response.data.PastelID, btoa(passphrase));
          pollWalletAndPastelIDStatus(response.data.PastelID);
        } else {
          displayMessage(response.data.message, false);
        }
      } catch (error) {
        displayLoading(false);
        console.error("Error creating PastelID:", error);
        displayMessage("Failed to create PastelID. Please try again.", false);
      }
    });


    importPastelIDButton.addEventListener("click", async () => {
      const pastelIDFile =
        document.getElementById("importPastelIDFile").files[0];
      if (!pastelIDFile) {
        displayMessage("Please select a PastelID file to import.", false);
        return;
      }
      const formData = new FormData();
      formData.append("pastelIDFile", pastelIDFile);
      try {
        const { network } = await getNetworkInfo();
        const response = await axios.post(
          `/import-pastel-id?network=${network}`,
          formData
        );
        if (response.data.success) {
          displayMessage("PastelID imported successfully!", true);
          location.reload(); // Refresh the page to update the UI
        } else {
          displayMessage(response.data.message, false);
        }
      } catch (error) {
        console.error("Error importing PastelID:", error);
        displayMessage(
          "Failed to import PastelID. Please try again.",
          false
        );
      }
    });

    function displayLoading(show) {
      const loader = document.getElementById("loaderContainer");
      if (show) {
        loader.innerHTML = '<div class="btn is-loading">Loading...</div>';
      } else {
        loader.innerHTML = "";
      }
    }

    (async function () {
      try {
        const myPslAddress = await getMyPslAddressWithLargestBalance();
        document.getElementById("myPslAddress").textContent = myPslAddress;
      } catch (error) {
        console.error(
          "Error displaying PSL address with largest balance:",
          error
        );
      }
    })();

    function displayMessage(message, isSuccess) {
      const messageContainer = document.getElementById("messageContainer");
      messageContainer.innerHTML = `<p class="${isSuccess ? "text-green-600" : "text-red-600"} font-bold text-lg">${message}</p>`;
      messageContainer.scrollIntoView({ behavior: "smooth" });
    }

    async function getNetworkInfo() {
      const response = await axios.get("/get-network-info");
      return response.data;
    }

    (async function () {
      try {
        // Check if there are any PastelIDs on initial load
        const pastelIDTickets = await listPastelIDTickets();
        if (pastelIDTickets.length === 0) {
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.add("hidden");
          noPastelIDContainer.classList.remove("hidden");
        } else {
          noPastelIDContainer.classList.add("hidden");
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.remove("hidden");
        }
        if (pastelIDTickets.length < 2) {
          document
              .getElementById("changePastelIDButton")
              .setAttribute("disabled", true);
        } else {
          document
              .getElementById("changePastelIDButton")
              .removeAttribute("disabled");
        }
      } catch (error) {
        console.error("Error checking PastelIDs:", error);
      }
    })();

    document.addEventListener("DOMContentLoaded", async () => {
      const pastelIDDropdown = document.getElementById("pastelIDDropdown");
      const passphraseContainer = document.getElementById(
        "passphraseContainer"
      );
      const pastelIDPassphrase =
        document.getElementById("pastelIDPassphrase");
      const rememberPassphrase =
        document.getElementById("rememberPassphrase");
      const submitPassphraseButton = document.getElementById(
        "submitPassphraseButton"
      );
      const refreshButton = document.getElementById("refreshButton");

      async function fetchValidPastelIDs() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result.map(
            (ticket) => ticket.ticket.pastelID
          );
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      const validPastelIDs = await fetchValidPastelIDs();
      const storedPastelIDs = Object.keys(localStorage);

      storedPastelIDs.forEach((pastelID) => {
        if (validPastelIDs.includes(pastelID)) {
          const option = document.createElement("option");
          option.value = pastelID;
          option.textContent = pastelID;
          pastelIDDropdown.appendChild(option);
        }
      });

      pastelIDDropdown.addEventListener("change", async () => {
        const selectedPastelID = pastelIDDropdown.value;
        document.getElementById("userPastelID").textContent =
          selectedPastelID || "No PastelID selected";
        if (selectedPastelID) {
          const storedPassphrase = localStorage.getItem(selectedPastelID);
          if (storedPassphrase) {
            pastelIDPassphrase.value = atob(storedPassphrase);
            passphraseContainer.classList.add("hidden");
          } else {
            passphraseContainer.classList.remove("hidden");
          }
          await setSelectedPastelIDAndPassphrase(selectedPastelID);
        } else {
          passphraseContainer.classList.add("hidden");
        }
        refreshCreditPackTickets();
      });

      submitPassphraseButton.addEventListener("click", async () => {
        const selectedPastelID = pastelIDDropdown.value;
        const passphrase = pastelIDPassphrase.value;

        if (rememberPassphrase.checked) {
          const encryptedPassphrase = btoa(passphrase); // Simple base64 encoding
          localStorage.setItem(selectedPastelID, encryptedPassphrase);
        }

        try {
          const response = await axios.post("/set-pastel-id-passphrase", {
            pastelID: selectedPastelID,
            passphrase: passphrase,
          });

          if (response.data.success) {
            document.getElementById("messageContainer").innerText =
              "Successfully set PastelID and passphrase!";
          } else {
            document.getElementById("messageContainer").innerText =
              "Failed to set PastelID and passphrase.";
          }
        } catch (error) {
          console.error("Error setting PastelID and passphrase:", error);
          document.getElementById("messageContainer").innerText =
            "Failed to set PastelID and passphrase.";
        }
      });

      if (validPastelIDs.length === 0) {
        document
          .getElementById("pastelIDDropdownContainer")
          .classList.add("hidden");
        noPastelIDContainer.classList.remove("hidden");
      } else {
        noPastelIDContainer.classList.add("hidden");
        document
          .getElementById("pastelIDDropdownContainer")
          .classList.remove("hidden");
      }
      if (validPastelIDs.length < 2) {
        document
            .getElementById("changePastelIDButton")
            .setAttribute("disabled", true);
      } else {
        document
            .getElementById("changePastelIDButton")
            .removeAttribute("disabled");
      }

      // Call setSelectedPastelIDAndPassphrase based on the number of PastelIDs
      if (validPastelIDs.length === 1) {
        const pastelID = validPastelIDs[0];
        document.getElementById("userPastelID").textContent = pastelID;
        pastelIDDropdown.value = pastelID; // Set the selected value of the dropdown
        await setSelectedPastelIDAndPassphrase(pastelID);
      } else {
        const selectedPastelID = pastelIDDropdown.value;
        document.getElementById("userPastelID").textContent =
          selectedPastelID || "No PastelID selected";
        if (selectedPastelID) {
          await setSelectedPastelIDAndPassphrase(selectedPastelID);
        }
      }
    });

    async function refreshCreditPackTickets() {
      const refreshButton = document.getElementById("refreshButton");
      const loader = refreshButton.querySelector(".loader");
      const loadingMessage = document.getElementById("loadingMessage");

      loader.classList.remove("hidden");
      loadingMessage.classList.remove("hidden");

      await getMyValidCreditPacks(true);

      loader.classList.add("hidden");
      loadingMessage.classList.add("hidden");
    }

    // Add event listener for the refresh button
    document
      .getElementById("refreshButton")
      .addEventListener("click", refreshCreditPackTickets);

    // Handle inference type change
    const inferenceTypeSelect = document.getElementById("inferenceType");
    const textCompletionSettings = document.getElementById(
      "textCompletionSettings"
    );
    const imageGenerationSettings = document.getElementById(
      "imageGenerationSettings"
    );

    inferenceTypeSelect.addEventListener("change", () => {
      const selectedInferenceType =
        document.getElementById("inferenceType").value;
      const textCompletionSettings = document.getElementById(
        "textCompletionSettings"
      );
      const imageGenerationSettings = document.getElementById(
        "imageGenerationSettings"
      );
      const embeddingDocumentSettings = document.getElementById(
        "embeddingDocumentSettings"
      );
      const embeddingAudioSettings = document.getElementById(
        "embeddingAudioSettings"
      );
      const askQuestionAboutImageSettings = document.getElementById(
        "askQuestionAboutImageSettings"
      );

      textCompletionSettings.style.display = "none";
      imageGenerationSettings.style.display = "none";
      embeddingDocumentSettings.style.display = "none";
      embeddingAudioSettings.style.display = "none";
      askQuestionAboutImageSettings.style.display = "none";

      if (selectedInferenceType === "text_completion") {
        textCompletionSettings.style.display = "block";
      } else if (selectedInferenceType === "text_to_image") {
        imageGenerationSettings.style.display = "block";
      } else if (selectedInferenceType === "embedding_document") {
        embeddingDocumentSettings.style.display = "block";
      } else if (selectedInferenceType === "embedding_audio") {
        embeddingAudioSettings.style.display = "block";
      } else if (selectedInferenceType === "ask_question_about_an_image") {
        askQuestionAboutImageSettings.style.display = "block";
      }
      // Update the model dropdown and parameter fields
      populateModelDropdown();
      loadInferenceRequestSettings();
    });

    document
      .getElementById("model")
      .addEventListener("change", handleModelChange);

    function handleCreditPackSelection() {
      const radioButtons = document.querySelectorAll(
        'input[name="creditPackTicket"]'
      );
      radioButtons.forEach((button) => {
        button.addEventListener("change", () => {
          document
            .querySelectorAll("#creditPackTicketTableBody tr")
            .forEach((row) => {
              row.classList.remove("bg-gray-200", "selected-row");
            });
          button.parentElement.parentElement.classList.add(
            "bg-gray-200",
            "selected-row"
          );
        });
      });
    }

    document
      .getElementById("copyAddressButton")
      .addEventListener("click", () => {
        const addressElement = document.getElementById("myPslAddress");
        const address = addressElement.textContent;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(address).then(() => {
            const tooltip = document.getElementById("copyAddressButton");
            tooltip.setAttribute(
              "data-tooltip",
              "Copied address to clipboard!"
            );

            setTimeout(() => {
              tooltip.setAttribute(
                "data-tooltip",
                "Copy address to clipboard"
              );
            }, 2000);
          });
        } else {
          const tempInput = document.createElement("input");
          tempInput.value = address;
          document.body.appendChild(tempInput);
          tempInput.select();
          document.execCommand("copy");
          document.body.removeChild(tempInput);

          const tooltip = document.getElementById("copyAddressButton");
          tooltip.setAttribute(
            "data-tooltip",
            "Copied address to clipboard!"
          );

          setTimeout(() => {
            tooltip.setAttribute(
              "data-tooltip",
              "Copy address to clipboard"
            );
          }, 2000);
        }
      });

    document.addEventListener("DOMContentLoaded", () => {
      handleCreditPackSelection();
    });

    let displayInferenceRequestLoggerMessages = false;
    let displayCreateTicketLoggerMessages = false;

    async function saveInferenceRequestToLocalStorage(requestData) {
      let requests =
        JSON.parse(localStorage.getItem("inferenceRequests")) || [];
      if (
        requestData.selectedInferenceType === "ask_question_about_an_image"
      ) {
        try {
          const imageFile = document.getElementById("imageFile").files[0];
          const compressedImage = await compressImage(imageFile);
          requestData.inputFields.image = compressedImage;
        } catch (error) {
          console.error("Error compressing image:", error);
        }
      } else if (
        requestData.selectedInferenceType === "embedding_document"
      ) {
        const fileInput = document.getElementById("embeddingDocumentFile");
        const originalFileName = fileInput.files[0].name;
        const fileHash = sha3_256(requestData.inputFields.document);
        requestData.inputFields.document_details = `
          <div>
            <p>Original File Name: ${originalFileName}</p>
            <p>File Hash: ${fileHash}</p>
          </div>
        `;
        delete requestData.inputFields.document;
      } else if (requestData.selectedInferenceType === "embedding_audio") {
        const fileHash = sha3_256(requestData.inputFields.audio);
        requestData.inputFields.fileHash = fileHash;
        delete requestData.inputFields.audio;
      } else if (requestData.selectedInferenceType === "text_to_image") {
        const generatedImage = document.getElementById("generated-image");
        const compressedImage = await compressGeneratedImage(
          generatedImage
        );
        requestData.inferenceResultsDecoded = compressedImage;
      }
      if (requestData.selectedInferenceType === "embedding_document") {
        const embeddingDocumentFileInput = document.getElementById(
          "embeddingDocumentFile"
        );
        if (
          embeddingDocumentFileInput &&
          embeddingDocumentFileInput.files.length > 0
        ) {
          requestData.inputFields.document_file_name =
            embeddingDocumentFileInput.files[0].name;
        }
      } else if (requestData.selectedInferenceType === "embedding_audio") {
        const embeddingAudioFileInput =
          document.getElementById("embeddingAudioFile");
        if (
          embeddingAudioFileInput &&
          embeddingAudioFileInput.files.length > 0
        ) {
          requestData.inputFields.audio_file_name =
            embeddingAudioFileInput.files[0].name;
        }
      }
      requests.push(requestData);
      localStorage.setItem("inferenceRequests", JSON.stringify(requests));
      updatePreviousRequestsList();
    }

    async function compressGeneratedImage(imgElement) {
      try {
        const options = {
          maxSizeMB: 0.05,
          maxWidthOrHeight: 600,
          useWebWorker: true,
          initialQuality: 0.6,
          fileType: "image/webp",
        };
        const response = await fetch(imgElement.src);
        const blob = await response.blob();
        const compressedFile = await imageCompression(blob, options);
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            resolve(reader.result);
          };
          reader.onerror = (error) => {
            console.error("Reader error:", error);
            reject(error);
          };
          reader.readAsDataURL(compressedFile);
        });
      } catch (error) {
        console.error("Compression error:", error);
        throw error;
      }
    }
    async function compressImage(imageBlob) {
      try {
        const compressedFile = await imageCompression(imageBlob, {
          maxSizeMB: 0.03,
          maxWidthOrHeight: 500,
          useWebWorker: true,
          initialQuality: 0.6,
          fileType: "image/webp",
        });
        const reader = new FileReader();
        return new Promise((resolve, reject) => {
          reader.onloadend = () => {
            resolve(reader.result);
          };
          reader.onerror = reject;
          reader.readAsDataURL(compressedFile);
        });
      } catch (error) {
        throw error;
      }
    }
    function updatePreviousRequestsList() {
      const requests =
        JSON.parse(localStorage.getItem("inferenceRequests")) || [];
      const listContainer = document.getElementById("previousRequestsList");
      listContainer.innerHTML = "";

      if (requests.length === 0) {
        const noRequestsMessage = document.createElement("p");
        noRequestsMessage.className = "text-gray-500";
        noRequestsMessage.textContent =
          "No saved inference requests to display. Create new ones and they will display here when they finish successfully.";
        listContainer.appendChild(noRequestsMessage);
      } else {
        requests.forEach((request, index) => {
          let inferenceTypeIcon;
          let promptPreview;
          if (request.selectedInferenceType === "text_completion") {
            inferenceTypeIcon = "🖹";
            promptPreview = request.prompt;
          } else if (request.selectedInferenceType === "text_to_image") {
            inferenceTypeIcon = "🖼️";
            promptPreview = request.inputFields.imagePrompt;
          } else if (
            request.selectedInferenceType === "ask_question_about_an_image"
          ) {
            inferenceTypeIcon = "🖺";
            promptPreview = request.inputFields.question;
          } else if (
            request.selectedInferenceType === "embedding_document"
          ) {
            inferenceTypeIcon = "🔢";
            promptPreview = request.inputFields.document_file_name || "";
          } else if (request.selectedInferenceType === "embedding_audio") {
            inferenceTypeIcon = "🕪";
            promptPreview = request.inputFields.audio_file_name || "";
          } else {
            inferenceTypeIcon = "❔";
            promptPreview = request.prompt;
          }
          if (
            request.selectedInferenceType !== "embedding_document" &&
            request.selectedInferenceType !== "embedding_audio"
          ) {
            const previewText =
              request.selectedInferenceType ===
                "ask_question_about_an_image"
                ? request.inputFields.question
                : request.prompt;
            promptPreview =
              request.selectedInferenceType === "text_to_image"
                ? request.inputFields.imagePrompt.substring(0, 40)
                : previewText
                  ? previewText.substring(0, 40)
                  : "No prompt available";
          }

          const listItem = document.createElement("div");
          listItem.className =
            "mb-2 p-2 bg-white rounded-lg flex justify-between items-center cursor-pointer";
          listItem.innerHTML = `<span><span class="icon-large">${inferenceTypeIcon}</span> ${promptPreview}...</span>
            <button class="delete-btn" style="font-size: 0.75rem;" title="Delete entry?" onclick="deleteRequest(${index})">❌</button>`;
          listItem.addEventListener("click", () =>
            displayRequestPreview(index)
          );
          listContainer.appendChild(listItem);
        });
      }
    }

    function deleteRequest(index) {
      let requests =
        JSON.parse(localStorage.getItem("inferenceRequests")) || [];
      requests.splice(index, 1);
      localStorage.setItem("inferenceRequests", JSON.stringify(requests));
      updatePreviousRequestsList();
    }

    function exportRequests() {
      const requests =
        JSON.parse(localStorage.getItem("inferenceRequests")) || [];
      if (requests.length === 0) {
        alert("No saved inference requests to export.");
        return;
      }

      let markdownContent = "# Saved Inference Requests\n\n";
      requests.forEach((request, index) => {
        markdownContent += `## Inference Request ${index + 1}\n`;
        markdownContent += `**Prompt**: ${request.selectedInferenceType === "ask_question_about_an_image"
          ? request.inputFields.question
          : request.prompt
          }\n\n`;
        markdownContent += `**Inference Results**:\n\n`;

        if (request.selectedInferenceType === "text_to_image") {
          markdownContent += `![Generated Image](${request.compressedImage})\n\n`;
        } else {
          request.inferenceResultsDecoded.forEach((result, i) => {
            markdownContent += `### Completion ${i + 1}\n`;
            markdownContent += `\`\`\`\n${result}\n\`\`\`\n\n`;
          });
        }
        markdownContent += `**Model**: ${request.selectedModelCanonicalName}\n`;
        markdownContent += `**Actual Cost (Credits)**: ${request.actualCreditsUsed}\n`;
        markdownContent += `**Remaining Credits**: ${request.remainingCredits}\n`;
        markdownContent += `**Misc. Inference Parameters and Statistics**:\n`;
        markdownContent += `| Parameter | Value |\n`;
        markdownContent += `| --- | --- |\n`;
        markdownContent += `| Input Prompt to LLM | ${request.selectedInferenceType === "ask_question_about_an_image"
          ? request.inputFields.question
          : request.prompt
          } |\n`;
        markdownContent += `| Actual Cost (Credits) | ${request.actualCreditsUsed} |\n`;
        markdownContent += `| Remaining Credits | ${request.remainingCredits} |\n`;
        markdownContent += `| Model | ${request.selectedModelCanonicalName} |\n`;
        markdownContent += `| Request Timestamp | ${request.requestTimestamp} |\n`;
        markdownContent += `| Total Time (Seconds) | ${request.elapsedTimeInSeconds} |\n`;
        markdownContent += `\n\n`;
      });

      const blob = new Blob([markdownContent], { type: "text/markdown" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "inference_requests.md";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    document
      .getElementById("exportRequestsButton")
      .addEventListener("click", exportRequests);

    updatePreviousRequestsList();

    function displayRequestPreview(index) {
      const requests =
        JSON.parse(localStorage.getItem("inferenceRequests")) || [];
      const request = requests[index];
      const previewContainer = document.getElementById("requestPreview");
      let combinedResults = "";
      if (request.selectedInferenceType === "text_completion") {
        const results = Array.isArray(
          JSON.parse(request.inferenceResultsDecoded)
        )
          ? JSON.parse(request.inferenceResultsDecoded)
          : [JSON.parse(request.inferenceResultsDecoded)];
        results.forEach((result, i) => {
          let parsedResult = result;
          try {
            const sanitizedResult = sanitizeJSON(result);
            const parsedJSON = JSON.parse(sanitizedResult);
            if (parsedJSON.text) {
              parsedResult = parsedJSON.text;
            }
          } catch (e) {
            parsedResult = fallbackParseResult(result);
          }
          combinedResults += `<h4>Completion ${i + 1} of ${results.length
            }</h4>`;
          combinedResults += `<github-md>${parsedResult}</github-md>`;
          if (i < results.length - 1) {
            combinedResults += "<hr>";
          }
        });
      } else if (
        request.selectedInferenceType === "ask_question_about_an_image"
      ) {
        combinedResults = `
          <img src="${request.inputFields.image
          }" alt="Input Image" style="max-width: 100%; max-height: 400px;">
          <p>Question: ${request.inputFields.question}</p>
          <p>Answer:</p>
          <github-md>${JSON.parse(request.inferenceResultsDecoded)[0]
          }</github-md>
        `;
      } else if (request.selectedInferenceType === "embedding_document") {
        combinedResults = `
                  <p>Semantic Query String: ${request.inputFields.question}</p>
                  `;
      } else if (request.selectedInferenceType === "embedding_audio") {
        const inferenceResultDecoded = request.inferenceResultsDecoded;
        const formattedResult = prettyJSON(inferenceResultDecoded);
        const coloredResult = formattedResult
          .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
          .replace(
            /"([^"]+)"(?=:)/g,
            '<span style="color: #2196F3;">$1</span>'
          ) // Pale blue for keys
          .replace(
            /: ("[^"]+")/g,
            ': <span style="color: #FFC107;">$1</span>'
          ) // Pale yellow for string values
          .replace(/: (\d+)/g, ': <span style="color: #FFC107;">$1</span>') // Pale yellow for numeric values
          .replace(
            /: (true|false|null)/g,
            ': <span style="color: #FFC107;">$1</span>'
          ); // Pale yellow for boolean and null values
        combinedResults = `
          <p>Original File Name: ${request.inputFields.audio_file_name}</p>
          <p>File SHA3-256 Hash: ${request.inputFields.fileHash}</p>
          <p>Semantic Query String: ${request.inputFields.question}</p>
          <div style="max-height: 1000px; overflow-y: auto;">
            <pre>${coloredResult}</pre>
          </div>
        `;
      } else if (request.selectedInferenceType === "text_to_image") {
        combinedResults = `
        <img src="${request.inferenceResultsDecoded}" alt="Generated Image" style="max-width: 100%; max-height: 400px;">
        <p class="text-sm italic m-2">(Please note that this is a compressed version of the original generated image.)</p>
      `;
      }
      previewContainer.innerHTML = `
      <div class="mb-4">
        <h3 class="font-bold">Inference Result:</h3>
        ${combinedResults}
      </div>
      <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
      <div class="table-responsive">
        <table class="table">
          <tr>
            <th>
              ${request.selectedInferenceType ===
          "ask_question_about_an_image"
          ? "Question"
          : request.selectedInferenceType === "embedding_document"
            ? "Input Document Name"
            : request.selectedInferenceType === "text_to_image"
              ? "Image Generation Prompt"
              : "Input Prompt to LLM"
        }
            </th>
            <td>
              ${request.selectedInferenceType ===
          "ask_question_about_an_image"
          ? request.inputFields.question
          : request.selectedInferenceType === "embedding_document"
            ? request.inputFields.document_file_name
            : request.selectedInferenceType === "text_to_image"
              ? request.inputFields.imagePrompt
              : request.prompt
        }
            </td>
          </tr>
          <tr><th>Actual Cost (Credits)</th><td>${request.actualCreditsUsed
        }</td></tr>
          <tr><th>Remaining Credits</th><td>${request.remainingCredits
        }</td></tr>
          <tr><th>Request Timestamp</th><td>${request.requestTimestamp
        }</td></tr>
          <tr><th>Model</th><td>${request.selectedModelCanonicalName
        }</td></tr>
          <tr><th>Total Time in Seconds to Process Request</th><td>${request.elapsedTimeInSeconds
        }</td></tr>
        </table>
      </div>`;

      renderMarkdown();
    }

    function downloadZip(zipUrl) {
      const link = document.createElement("a");
      link.href = zipUrl;
      link.download = "inference_result.zip";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Call updatePreviousRequestsList on page load
    document.addEventListener(
      "DOMContentLoaded",
      updatePreviousRequestsList
    );

    async function createNewInferenceRequest(
      selectedCreditPackTicketId,
      selectedInferenceType,
      selectedModelCanonicalName,
      maxCost,
      modelParametersJSONBase64Encoded,
      modelInputDataJSONBase64Encoded
    ) {
      const resultContainer = document.getElementById(
        "inferenceRequestResult"
      );
      resultContainer.classList.remove('hidden');
      resultContainer.innerHTML = "";
      const loader = document.createElement("div");
      loader.className = "btn is-loading";
      loader.innerText = "Loading...";
      resultContainer.appendChild(loader);

      displayInferenceRequestLoggerMessages = true;
      const startTime = new Date();

      try {
        logStatusMessage("Creating new inference request...");

        if (!modelInputDataJSONBase64Encoded) {
          throw new Error(
            "Model input data is required and cannot be empty."
          );
        }

        const requestPayload = {
          model_inference_type_string: selectedInferenceType,
          model_parameters_json_b64: modelParametersJSONBase64Encoded,
          model_input_data_json_b64: modelInputDataJSONBase64Encoded,
          selectedCreditPackTicketId,
          maxCost,
          model_canonical_name: selectedModelCanonicalName,
        };

        const response = await axios.post(
          "/create-inference-request",
          requestPayload
        );

        if (response.data.success) {
          logStatusMessage("Inference request created successfully.");
          const contentType = response.headers["content-type"];

          const inferenceResultDict =
            response.data.result.inferenceResultDict;

          let combinedResults = "";
          const modelInputDataJSON =
            inferenceResultDict.model_input_data_json;
          const {
            proposed_cost_of_request_in_inference_credits,
            remaining_credits_in_pack_after_request_processed,
          } = inferenceResultDict.usage_request_response;

          const endTime = new Date();
          const elapsedTimeInSeconds = Math.floor(
            (endTime - startTime) / 1000
          );
          let compressedImage;
          if (selectedInferenceType === "text_to_image") {
            const imageBinaryData =
              inferenceResultDict.generated_image_decoded.data;
            if (imageBinaryData) {
              // Convert the binary data to a Blob
              const outputFormat =
                document
                  .getElementById("output_format")
                  .value.replace("jpeg", "jpg") || "jpg";
              const imageBlob = new Blob(
                [new Uint8Array(imageBinaryData)],
                {
                  type: `image/${outputFormat}`,
                }
              );
              // Create an object URL for the image
              const imageUrl = URL.createObjectURL(imageBlob);
              // Generate the image name
              const imageName = modelInputDataJSON.imagePrompt
                .replace(/[^\w]/g, "_")
                .replace(/_+/g, "_")
                .substring(0, 100);
              // Create the combined results HTML
              const imageSizeBytes = await fetchImageSize(imageUrl);
              const imageSizeMB = (imageSizeBytes / (1024 * 1024)).toFixed(
                2
              );
              combinedResults = `
                <div class="m-8">
                  <img id="generated-image" src="${imageUrl}" alt="Generated Image" class="max-w-full max-h-96 mx-auto mb-4">
                  <p class="text-center">
                    <a href="${imageUrl}" download="${imageName}.${outputFormat}" class="btn success outline m-4">Download Image</a>
                  </p>
                  <p class="text-center text-gray-500">File size: ${imageSizeMB} MB</p>
                </div>
              `;
            } else {
              combinedResults = "Failed to generate image.";
            }
          } else if (selectedInferenceType === "embedding_audio") {
            const embeddingAudioFileInput =
              document.getElementById("embeddingAudioFile");
            const originalFileName = embeddingAudioFileInput.files[0].name;
            const inferenceResultDecoded =
              inferenceResultDict.inference_result_decoded;
            const formattedResult = prettyJSON(inferenceResultDecoded);
            const coloredResult = formattedResult
              .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
              .replace(
                /"([^"]+)"(?=:)/g,
                '<span style="color: #2196F3;">$1</span>'
              ) // Pale blue for keys
              .replace(
                /: ("[^"]+")/g,
                ': <span style="color: #FFC107;">$1</span>'
              ) // Pale yellow for string values
              .replace(
                /: (\d+)/g,
                ': <span style="color: #FFC107;">$1</span>'
              ) // Pale yellow for numeric values
              .replace(
                /: (true|false|null)/g,
                ': <span style="color: #FFC107;">$1</span>'
              ); // Pale yellow for boolean and null values
            combinedResults = `
              <p>Original File Name: ${originalFileName}</p>
              <p>Semantic Query String: ${modelInputDataJSON.question}</p>
              <div style="max-height: 1000px; overflow-y: auto;">
                <pre>${coloredResult}</pre>
              </div>
            `;
          } else if (
            selectedInferenceType === "ask_question_about_an_image"
          ) {
            const imageFile = document.getElementById("imageFile").files[0];
            const imageUrl = URL.createObjectURL(imageFile);
            combinedResults = `
              <img src="${imageUrl}" alt="Input Image" style="max-width: 100%; max-height: 400px;">
              <p>Question: ${modelInputDataJSON.question}</p>
              <p>Answer:</p>
              <github-md>${JSON.parse(inferenceResultDict.inference_result_decoded)[0]
              }</github-md> 
            `;
          } else if (selectedInferenceType === "text_completion") {
            const inferenceResultsDecoded = JSON.parse(
              inferenceResultDict.inference_result_decoded
            );
            if (Array.isArray(inferenceResultsDecoded)) {
              inferenceResultsDecoded.forEach((result, i) => {
                let parsedResult = result;
                try {
                  const sanitizedResult = sanitizeJSON(result);
                  const parsedJSON = JSON.parse(sanitizedResult);
                  if (parsedJSON.text) {
                    parsedResult = parsedJSON.text;
                  }
                } catch (e) {
                  try {
                    parsedResult = fallbackParseResult(result);
                  } catch (e) {
                    parsedResult = result;
                  }
                }
                combinedResults += `<h4>Completion ${i + 1} of ${inferenceResultsDecoded.length
                  }</h4>`;
                combinedResults += `<github-md>${parsedResult}</github-md>`;
                if (i < inferenceResultsDecoded.length - 1) {
                  combinedResults += "<hr>";
                }
              });
            } else {
              // It's not an array, just a single result; so wrap it in markdown tags
              combinedResults = `<github-md>${inferenceResultsDecoded}</github-md>`;
            }
          }

          resultContainer.innerHTML = `
          <div class="mb-4">
            <h3 class="font-bold">Inference Result:</h3>
            ${combinedResults}
          </div>
          <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
          <div class="table-responsive">
            <table class="table">
              <tr>
                <th>${selectedInferenceType === "embedding_document"
              ? "Input Document File Name"
              : selectedInferenceType === "embedding_audio"
                ? "Input Audio File Name"
                : "Input Prompt to LLM"
            }</th>
                <td>${selectedInferenceType === "embedding_document"
              ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                .document_file_name
              : selectedInferenceType === "embedding_audio"
                ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                  .audio_file_name
                : modelInputDataJSON.prompt
            }</td>
              </tr>
              <tr><th>Actual Cost (Credits)</th><td>${proposed_cost_of_request_in_inference_credits}</td></tr>
              <tr><th>Remaining Credits</th><td>${remaining_credits_in_pack_after_request_processed}</td></tr>
              <tr><th>Request Timestamp</th><td>${new Date().toISOString()}</td></tr>
              <tr><th>Model</th><td>${selectedModelCanonicalName}</td></tr>
              <tr><th>Total Time in Seconds to Process Request</th><td>${elapsedTimeInSeconds}</td></tr>
            </table>
          </div>
          ${selectedInferenceType === "embedding_document"
              ? `<p class="text-center">
                  <a href="#" id="downloadZipButton" class="btn success outline m-4">
                    Download Zip File of JSON Document Embeddings${inferenceResultDict.semantic_query_result
                ? " and Semantic Search Results"
                : ""
              }
                  </a>
                </p>`
              : ""
            }
        `;

          saveInferenceRequestToLocalStorage({
            selectedCreditPackTicketId,
            selectedInferenceType,
            selectedModelCanonicalName,
            inputFields: JSON.parse(atob(modelInputDataJSONBase64Encoded)),
            parameterFields: JSON.parse(
              atob(modelParametersJSONBase64Encoded)
            ),
            maxCost,
            inferenceResultsDecoded:
              inferenceResultDict.inference_result_decoded,
            prompt: document.getElementById("prompt").value,
            elapsedTimeInSeconds,
            actualCreditsUsed:
              proposed_cost_of_request_in_inference_credits,
            remainingCredits:
              remaining_credits_in_pack_after_request_processed,
            respondingSupernode:
              inferenceResultDict.responding_supernode_pastelid,
            requestTimestamp: startTime.toISOString(),
          });

          if (selectedInferenceType === "embedding_document") {
            const embeddingDocumentFileInput = document.getElementById(
              "embeddingDocumentFile"
            );
            const originalFileName =
              embeddingDocumentFileInput.files[0].name;
            document
              .getElementById("downloadZipButton")
              .addEventListener("click", () => {
                const processedFileName = originalFileName
                  .replace(/\.[^/.]+$/, "")
                  .replace(/[^\w]/g, "_")
                  .replace(/_+/g, "_")
                  .substring(0, 100);
                // Convert the buffer data to a Uint8Array
                const zipFileDataBuffer =
                  inferenceResultDict.zip_file_data.data;
                const zipFileUint8Array = new Uint8Array(zipFileDataBuffer);
                const zipBlob = new Blob([zipFileUint8Array], {
                  type: "application/zip",
                });
                const downloadLink = document.createElement("a");
                downloadLink.href = URL.createObjectURL(zipBlob);
                downloadLink.download = `${processedFileName}.zip`;
                downloadLink.click();
              });
            // Update the table cell with the original file name
            resultContainer.querySelector("td").textContent =
              originalFileName;
          }
          renderMarkdown();
        } else {
          throw new Error("Failed to create inference request");
        }
      } catch (error) {
        console.error(
          `Error creating new inference request: ${error.message}`
        );
        resultContainer.innerHTML =
          "Failed to create inference request. Please try again.";
        logStatusMessage("Failed to create inference request.");
      } finally {
        loader.remove();
        displayInferenceRequestLoggerMessages = false;
      }
    }

    async function decompressJsonFromZip(zipUrl) {
      const response = await fetch(zipUrl);
      const blob = await response.blob();
      const jsZip = new JSZip();
      const zip = await jsZip.loadAsync(blob);
      const fileNames = Object.keys(zip.files);
      const jsonFile = await zip.files[fileNames[0]].async("text");
      return jsonFile;
    }

    // Function to fetch and display received messages
    async function fetchReceivedMessages() {
      try {
        const userPastelID =
          document.getElementById("pastelIDDropdown").value;

        const response = await axios.get("/get-best-supernode-url", {
          params: { userPastelID },
        });
        const supernodeURL = response.data.supernodeURL;
        const closestSupernodeIP = supernodeURL.match(
          /(?:https?:\/\/)?([^:/]+)/i
        )[1];

        const messagesResponse = await axios.get("/get-received-messages", {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        });
        const messageDict = messagesResponse.data.messageDict;

        const receivedMessagesContainer =
          document.getElementById("receivedMessages");
        receivedMessagesContainer.innerHTML = ""; // Clear previous messages

        for (const pastelId in messageDict) {
          const messages = messageDict[pastelId];
          messages.forEach((message) => {
            const messageElement = document.createElement("div");
            messageElement.classList.add(
              "mb-4",
              "border",
              "border-gray-300",
              "rounded-lg",
              "p-4"
            );

            const fromPastelIDElement = document.createElement("p");
            fromPastelIDElement.classList.add(
              "text-sm",
              "font-medium",
              "text-gray-600",
              "mb-2"
            );
            fromPastelIDElement.textContent = `From: ${pastelId}`;

            const messageBodyElement = document.createElement("p");
            messageBodyElement.classList.add(
              "text-base",
              "text-gray-800",
              "mb-2"
            );
            messageBodyElement.textContent = message.message_body;

            const timestampElement = document.createElement("p");
            timestampElement.classList.add("text-xs", "text-gray-500");
            timestampElement.textContent = new Date(
              message.timestamp
            ).toLocaleString();

            messageElement.appendChild(fromPastelIDElement);
            messageElement.appendChild(messageBodyElement);
            messageElement.appendChild(timestampElement);

            receivedMessagesContainer.appendChild(messageElement);
          });
        }
      } catch (error) {
        console.log("Error retrieving received messages:", error);
        const receivedMessagesContainer =
          document.getElementById("receivedMessages");
        receivedMessagesContainer.innerHTML =
          "Failed to retrieve received messages. Please try again later.";
      }
    }

    // Handle create PastelID button click
    document
      .getElementById("createPastelIDButton")
      .addEventListener("click", async () => {
        try {
          await axios.post("/check-for-pastel-id", { autoRegister: true });
          location.reload(); // Refresh the page to update the UI
        } catch (error) {
          console.error("Error creating PastelID:", error);
        }
      });

    // Handle import private key form submission
    document
      .getElementById("importPrivKeyButton")
      .addEventListener("click", async () => {
        const privKey = document.getElementById("importPrivKey").value;
        try {
          await axios.post("/import-priv-key", { zcashPrivKey: privKey });
          alert("Private key imported successfully!");
        } catch (error) {
          console.error("Error importing private key:", error);
        }
      });

    // Handle import wallet form submission
    document
      .getElementById("importWalletButton")
      .addEventListener("click", async () => {
        const walletFile = document.getElementById("importWallet").files[0];
        const formData = new FormData();
        formData.append("walletFile", walletFile);
        try {
          await axios.post("/import-wallet", formData);
          alert("Wallet imported successfully!");
        } catch (error) {
          console.error("Error importing wallet:", error);
        }
      });

    // Handle list address amounts button click
    document
      .getElementById("listAddressAmountsButton")
      .addEventListener("click", async () => {
        try {
          const response = await axios.get("/list-address-amounts");
          const addressAmounts = response.data.result;
          console.log("Address amounts:", addressAmounts);

          // Populate the table
          const addressAmountsTable = document.getElementById(
            "addressAmountsTable"
          );
          addressAmountsTable.innerHTML =
            "<thead><tr><th>Address</th><th>Amount</th></tr></thead><tbody></tbody>";
          const tbody = addressAmountsTable.querySelector("tbody");
          for (const [address, amount] of Object.entries(addressAmounts)) {
            const row = document.createElement("tr");
            row.innerHTML = `<td>${address}</td><td>${parseAndFormatNumber(
              amount.toString()
            )}</td>`;
            tbody.appendChild(row);
          }

          // Show the container and the copy button
          const addressAmountsContainer = document.getElementById(
            "addressAmountsContainer"
          );
          addressAmountsContainer.style.display = "block";
          document.getElementById(
            "copyAddressAmountsButton"
          ).style.display = "inline-block";

          // Add clipboard functionality
          document
            .getElementById("copyAddressAmountsButton")
            .addEventListener("click", () => {
              const csvData = Object.entries(addressAmounts)
                .map(
                  ([address, amount]) =>
                    `${address},${amount.toString().replace(/,/g, "")}`
                )
                .join("\n");
              navigator.clipboard.writeText(csvData);
              alert("Address amounts copied to clipboard as CSV!");
            });
        } catch (error) {
          console.error("Error retrieving address amounts:", error);
        }
      });
    // Handle get wallet info button click
    document
      .getElementById("getWalletInfoButton")
      .addEventListener("click", async () => {
        try {
          const response = await axios.get("/get-wallet-info");
          const walletInfo = response.data.result;
          console.log("Wallet info:", walletInfo);

          // Populate the table
          const walletInfoTable =
            document.getElementById("walletInfoTable");
          walletInfoTable.innerHTML =
            "<thead><tr><th>Key</th><th>Value</th></thead><tbody></tbody>";
          const tbody = walletInfoTable.querySelector("tbody");
          const balanceFields = [
            "balance",
            "unconfirmed_balance",
            "immature_balance",
          ]; // Add the balance fields you want to format

          for (const [key, value] of Object.entries(walletInfo)) {
            const formattedValue = balanceFields.includes(key)
              ? parseAndFormatNumber(value.toString())
              : value;
            const row = document.createElement("tr");
            row.innerHTML = `<td>${key}</td><td>${formattedValue}</td>`;
            tbody.appendChild(row);
          }

          // Show the container and the copy button
          const walletInfoContainer = document.getElementById(
            "walletInfoContainer"
          );
          walletInfoContainer.style.display = "block";
          document.getElementById("copyWalletInfoButton").style.display =
            "inline-block";

          // Add clipboard functionality
          document
            .getElementById("copyWalletInfoButton")
            .addEventListener("click", () => {
              const csvData = Object.entries(walletInfo)
                .map(
                  ([key, value]) =>
                    `${key},${value.toString().replace(/,/g, "")}`
                )
                .join("\n");
              navigator.clipboard.writeText(csvData);
              alert("Wallet info copied to clipboard as CSV!");
            });
        } catch (error) {
          console.error("Error retrieving wallet info:", error);
        }
      });

    document
      .getElementById("clearLocalStorageButton")
      .addEventListener("click", () => {
        if (
          confirm(
            "Are you sure you want to clear all local storage data for this page?"
          )
        ) {
          localStorage.clear();
          alert("Local storage cleared. The page will now reload.");
          location.reload();
        }
      });

    // Create a terminal and load the fit addon
    const term = new Terminal({ cols: 175, rows: 24 });
    term.open(document.getElementById("terminal"));
    term.terminalOptions = {
      fontSize: 6,
      enableBold: true,
      cols: 175,
      rows: 24,
    };

    function resizeTerminal() {
      const terminalElement = document.getElementById("terminal");
      const cols = Math.floor(terminalElement.clientWidth / 10); // Approximate character width
      const rows = Math.floor(terminalElement.clientHeight / 20); // Approximate character height

      console.log(
        `Cols: ${cols}, Rows: ${rows}, Type of Cols: ${typeof cols}, Type of Rows: ${typeof rows}`
      );

      if (cols > 0 && rows > 0) {
        term.resize(cols, rows);
      }
    }

    resizeTerminal();
    window.addEventListener("resize", resizeTerminal);

    function displayStatusMessage(message) {
      const currentStatus = document.getElementById("currentStatus");
      currentStatus.textContent = message;
    }

    function cleanAndFormatMessage(message) {
      if (typeof message === "object") {
        // If the message is a JSON object, stringify and format it
        return JSON.stringify(message, null, 2);
      } else if (typeof message === "string") {
        // Remove excess whitespace from strings
        return message.replace(/\s+/g, " ").trim();
      }
      return message;
    }

    function logMessageToTerminal(term, logMessage) {
      const message =
        typeof logMessage.message === "string" ? logMessage.message : "";
      const cleanMessage = cleanAndFormatMessage(message);
      if (typeof cleanMessage !== "string") {
        console.error("cleanMessage is not a string:", cleanMessage);
        return;
      }
      const parts = cleanMessage.split(/(\{[\s\S]*?\})/);
      const formattedParts = parts
        .map((part) => {
          if (part.startsWith("{") && part.endsWith("}")) {
            let parsed;
            try {
              parsed = JSON.parse(part);
            } catch (e) {
              try {
                // Fix common JSON issues
                let fixedPart = part
                  .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Ensure keys are quoted
                  .replace(/:\s*(['"])?([^\n\r\t,}\]]+)(['"])?/g, ': "$2"') // Ensure values are quoted
                  .replace(/,\s*([\]}])/g, "$1") // Remove trailing commas
                  .replace(/\\n/g, "\\n") // Handle newlines
                  .replace(/\\r/g, "\\r") // Handle carriage returns
                  .replace(/\\t/g, "\\t") // Handle tabs
                  .replace(/[\u0000-\u001F\u007F-\u009F]/g, ""); // Remove control characters

                // Fix for unterminated strings
                const quotesBalanced =
                  fixedPart.split('"').length % 2 === 1;
                if (quotesBalanced) {
                  fixedPart = fixedPart + '"';
                }

                parsed = JSON.parse(fixedPart);
              } catch (innerE) {
                // Silently fail
                return part;
              }
            }
            const formatted = prettyJSON(parsed);
            return formatted
              .replace(/({|})/g, "\x1b[1;32m$1\x1b[0m") // Light green for braces
              .replace(/"([^"]+)"(?=:)/g, '\x1b[1;34m"$1"\x1b[0m') // Pale blue for keys
              .replace(/: ("[^"]+")/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for string values
              .replace(/: (\d+)/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for numeric values
              .replace(/: (true|false|null)/g, ": \x1b[1;33m$1\x1b[0m"); // Pale yellow for boolean and null values
          }
          return part;
        })
        .join("");
      const timestamp = logMessage.timestamp
        ? new Date(logMessage.timestamp).toISOString()
        : "Invalid timestamp";
      const logLevel = logMessage.level || "Unknown level";
      const messageLines =
        `[${timestamp}] [${logLevel}] ${formattedParts}`.split("\n");
      messageLines.forEach((line) => term.writeln(line));
    }

    fetch("/ws-url")
      .then((response) => response.json())
      .then((data) => {
        const socket = new WebSocket(data.wsUrl);

        socket.onopen = () => {
          console.log("WebSocket connection established");
        };

        socket.onmessage = (event) => {
          if (event.data) {
            const logMessage = JSON.parse(event.data);
            logMessageToTerminal(term, logMessage);

            if (displayInferenceRequestLoggerMessages) {
              logStatusMessage(logMessage.message);
            }

            if (displayCreateTicketLoggerMessages) {
              const statusContainer = document.getElementById(
                "createTicketStatusContainer"
              );
              const statusContent =
                document.getElementById("createTicketStatus");
              if (logMessage.message) {
                logCreateTicketStatusMessage(
                  logMessage.message,
                  statusContent
                );
              }
            }
          }
        };

        socket.onclose = () => {
          console.log("WebSocket connection closed");
        };

        socket.onerror = (error) => {
          console.error("WebSocket error:", error);
        };
      })
      .catch((error) => {
        console.error("Error fetching WebSocket URL:", error);
      });

    function toggleTerminal() {
      const terminal = document.getElementById("terminal");
      if (terminal.style.display === "none") {
        terminal.style.display = "block";
      } else {
        terminal.style.display = "none";
      }
      resizeTerminal();
    }

    tailwind.config = {
      theme: {
        extend: {},
      },
    };

    var storedTheme =
      localStorage.getItem("theme") ||
      (window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light");
    if (storedTheme)
      document.documentElement.setAttribute("data-theme", storedTheme);

    function toggleDarkMode() {
      var currentTheme =
        document.documentElement.getAttribute("data-theme");
      var targetTheme = currentTheme === "light" ? "dark" : "light";
      document.documentElement.setAttribute("data-theme", targetTheme);
      localStorage.setItem("theme", targetTheme);
      document
        .querySelector("#theme-toggle")
        .setAttribute("data-content", targetTheme === "dark" ? "🌙" : "☀");
    }

    // Set the initial state of the switch toggle
    const toggle = document.querySelector("#theme-toggle");
    if (storedTheme === "dark") {
      toggle.checked = true;
      toggle.setAttribute("data-content", "🌙");
    } else {
      toggle.checked = false;
      toggle.setAttribute("data-content", "☀");
    }

    // Format the values and display them using template literals
    function formatAndDisplay(inputElement) {
      const value = inputElement.value.replace(/,/g, "");
      const number = parseFloat(value);
      if (!isNaN(number)) {
        inputElement.setAttribute("data-raw-value", number);
        inputElement.value = number.toLocaleString();
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      const createTicketForm = document.getElementById("createTicketForm");
      createTicketForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const numCredits = parseInt(
          document.querySelector("#numCredits").value.replace(/,/g, "")
        );
        const maxTotalPrice = parseFloat(
          document.querySelector("#maxTotalPrice").value.replace(/,/g, "")
        );
        const maxPerCreditPrice = parseFloat(
          document
            .querySelector("#maxPerCreditPrice")
            .value.replace(/,/g, "")
        );

        const statusContainer = document.getElementById(
          "createTicketStatusContainer"
        );
        const statusContent = document.getElementById("createTicketStatus");
        statusContent.innerHTML = ""; // Clear previous logs

        logCreateTicketStatusMessage(
          "Initializing ticket creation...",
          statusContent
        );
        try {
          await createNewCreditPackTicket(
            numCredits,
            maxTotalPrice,
            maxPerCreditPrice
          );
        } catch (error) {
          console.error(
            "Error creating credit pack ticket:",
            error.message
          );
          logCreateTicketStatusMessage(
            `Failed to create credit pack ticket: ${error.message}`,
            statusContent
          );
        }
      });

      // Add event listener to format and update raw values on input change
      const inputs = document.querySelectorAll(
        "#numCredits, #maxTotalPrice, #maxPerCreditPrice"
      );
      inputs.forEach((input) => {
        input.addEventListener("input", handleInputChange);
        input.addEventListener("blur", handleInputBlur);
      });

      document
        .getElementById("inferenceRequestForm")
        .addEventListener("submit", async (event) => {
          event.preventDefault();
          saveInferenceRequestSettings();

          const selectedCreditPackTicket = document.querySelector(
            'input[name="creditPackTicket"]:checked'
          );
          if (!selectedCreditPackTicket) {
            alert("Please select a credit pack ticket.");
            return;
          }
          const selectedRow = selectedCreditPackTicket.closest("tr");
          const selectedCreditPackTicketId = selectedRow
            .querySelector("td:last-child a")
            .textContent.trim();

          const selectedInferenceType =
            document.getElementById("inferenceType").value;
          const selectedModelCanonicalName =
            document.getElementById("model").value;
          const maxCost = parseFloat(
            document.querySelector("#maxCost").dataset.rawValue
          );

          const encodeToBase64 = (str) => {
            return btoa(unescape(encodeURIComponent(str)));
          };

          const encodeFileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result.split(",")[1]);
              reader.onerror = reject;
              reader.readAsDataURL(file);
            });
          };

          const formData = new FormData(event.target);
          const modelParameters = {};
          formData.forEach((value, key) => {
            if (
              key !== "prompt" &&
              key !== "imagePrompt" &&
              key !== "embeddingDocumentFile" &&
              key !== "embeddingAudioFile"
            ) {
              modelParameters[key] = value;
            }
          });

          const modelParametersJSON = JSON.stringify(modelParameters);
          const modelParametersJSONBase64Encoded =
            encodeToBase64(modelParametersJSON);

          let inputPromptKey;
          if (selectedInferenceType === "text_completion") {
            inputPromptKey = "prompt";
          } else if (selectedInferenceType === "text_to_image") {
            inputPromptKey = "imagePrompt";
          } else if (selectedInferenceType === "embedding_document") {
            inputPromptKey = "embeddingDocumentFile";
          } else if (selectedInferenceType === "embedding_audio") {
            inputPromptKey = "embeddingAudioFile";
          } else {
            inputPromptKey = "prompt";
          }

          let modelInputDataBase64Encoded;
          if (selectedInferenceType === "ask_question_about_an_image") {
            const imageFile = document.getElementById("imageFile").files[0];
            const question = document.getElementById("question").value;
            if (!imageFile || !question) {
              alert("Please select an image and enter a question.");
              return;
            }
            const imageBase64 = await encodeFileToBase64(imageFile);
            modelInputDataBase64Encoded = encodeToBase64(
              JSON.stringify({
                image: imageBase64,
                question: question,
              })
            );
          } else if (selectedInferenceType === "embedding_document") {
            const inputFile =
              document.getElementById(inputPromptKey).files[0];
            const semantic_query_string = document.getElementById(
              "document_semantic_query_string"
            ).value;
            if (!inputFile) {
              alert("Document file data cannot be empty.");
              return;
            }
            const documentBase64 = await encodeFileToBase64(inputFile);
            modelInputDataBase64Encoded = encodeToBase64(
              JSON.stringify({
                document: documentBase64,
                question: semantic_query_string,
              })
            );
          } else if (selectedInferenceType === "embedding_audio") {
            const inputFile =
              document.getElementById(inputPromptKey).files[0];
            const semantic_query_string = document.getElementById(
              "audio_semantic_query_string"
            ).value;
            if (!inputFile) {
              alert("Audio file data cannot be empty.");
              return;
            }
            const audioBase64 = await encodeFileToBase64(inputFile);
            modelInputDataBase64Encoded = encodeToBase64(
              JSON.stringify({
                audio: audioBase64,
                question: semantic_query_string,
              })
            );
          } else {
            const inputPromptValue =
              document.getElementById(inputPromptKey).value;
            modelInputDataBase64Encoded = encodeToBase64(
              JSON.stringify({ [inputPromptKey]: inputPromptValue })
            );
          }

          await createNewInferenceRequest(
            selectedCreditPackTicketId,
            selectedInferenceType,
            selectedModelCanonicalName,
            maxCost,
            modelParametersJSONBase64Encoded,
            modelInputDataBase64Encoded
          );

          localStorage.removeItem(STORAGE_KEY);
          localStorage.removeItem(STORAGE_TIMESTAMP_KEY);

          // Refresh the credit pack tickets to reflect the updated balance
          await getMyValidCreditPacks(true);
        });

      // Attach debounced input and blur event listeners to all relevant input elements
      const inferenceRequestForm = document.getElementById(
        "inferenceRequestForm"
      );
      const inputElements = inferenceRequestForm.querySelectorAll(
        "input, textarea, select"
      );

      inputElements.forEach((inputElement) => {
        inputElement.addEventListener(
          "input",
          debounce(handleInputChange, 300)
        );
        inputElement.addEventListener("blur", handleInputBlur);
      });

      const maxCostInput = document.getElementById("maxCost");
      const maxCostFormattedSpan =
        document.getElementById("maxCostFormatted");
      maxCostInput.addEventListener(
        "input",
        debounce(
          () => formatAndDisplay(maxCostInput, maxCostFormattedSpan),
          300
        )
      );
    });

    document
      .getElementById("exportTerminalButton")
      .addEventListener("click", () => {
        let termText = "";
        for (let i = 0; i < term.buffer.active.length; i++) {
          const line = term.buffer.active.getLine(i);
          if (line) {
            termText += line.translateToString(false) + "\n";
          }
        }
        const blob = new Blob([termText], { type: "text/plain" });
        const link = document.createElement("a");
        const currentDate = new Date().toISOString();
        const fileName = `Pastel_Inference_Client_Terminal_Session_Log__${currentDate}.txt`;
        link.href = URL.createObjectURL(blob);
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      });

    document.addEventListener("DOMContentLoaded", () => {
      hljs.highlightAll();
      handleCreditPackSelection();
      document.getElementById("inferenceType").value = "text_completion"; // Set default to Text Completion
      document
        .getElementById("inferenceType")
        .dispatchEvent(new Event("change")); // Trigger change event

      // Automatically refresh the table of existing credit packs on initial page load
      getMyValidCreditPacks(true).catch((error) => {
        console.error("Error refreshing credit pack tickets:", error);
      });
    });
  </script>
  <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js"></script>
</body>

</html>