<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pastel Inference Client UI</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@sira-ui/tailwind/dist/css/styles.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/json.min.js"></script>
    <style>
      .ground-glass {
        background-color: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
      }
      body {
        font-family: Montserrat, sans-serif;
      }
      .btn.success.outline {
        border-color: #4caf50;
        color: #4caf50;
      }
      .btn.success.outline:hover {
        background-color: #4caf50;
        color: #ffffff;
      }
      .btn.success.outline:active {
        background-color: #388e3c;
        border-color: #388e3c;
        color: #ffffff;
      }
      .xterm {
        width: 100% !important;
        border-radius: 0.5rem; /* Adds rounded corners */
      }
      .table-container {
        overflow-x: auto;
      }
      .table {
        width: 100%;
        table-layout: fixed;
      }
      .table th,
      .table td {
        padding: 0.5rem;
        border: 1px solid #ccc;
      }
      .table th:last-child,
      .table td:last-child {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }
      .table td:last-child:hover {
        white-space: normal;
      }
      [data-theme="dark"] {
        background-color: #121212;
        color: #ffffff;
      }
      [data-theme="dark"] .bg-white {
        background-color: #333333;
      }
      [data-theme="dark"] .text-bw-50 {
        color: #cccccc;
      }
      [data-theme="dark"] .text-bw-600 {
        color: #ffffff;
      }
      [data-theme="dark"] .text-bw-700 {
        color: #eeeeee;
      }
      [data-theme="dark"] .text-bw-800 {
        color: #ffffff;
      }
      [data-theme="dark"] .bg-bw-50 {
        background-color: #333333;
      }
      [data-theme="dark"] .btn.outline.bw {
        border-color: #ffffff;
        color: #ffffff;
      }
      [data-theme="dark"] .btn.outline.bw:hover {
        background-color: #ffffff;
        color: #000000;
      }
      [data-theme="dark"] .table .bg-gray-200 {
        background-color: #333333;
        color: #ffffff; /* This needs to be adjusted */
      }
      [data-theme="dark"] .table .bg-gray-200.selected-row {
        color: #000000; /* Adjust this color to be dark for legibility */
      }
      .table-responsive {
        overflow-x: auto;
      }
      .truncate {
        max-width: 150px; /* Adjust as needed */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .prompt.success.xs {
        display: inline-block;
        flex-grow: 1; /* Allow it to take up the remaining space */
        max-width: calc(
          100% - 2rem
        ); /* Leave some padding for better readability */
        word-wrap: break-word; /* Ensure the text wraps correctly */
        height: 260px; /* Set a fixed height */
        overflow-y: auto; /* Add a scrollbar if the content exceeds the height */
        padding: 0.5rem; /* Add padding for better readability */
        border: 1px solid #ccc; /* Optional: Add a border for better visibility */
        border-radius: 0.5rem; /* Optional: Add rounded corners */
      }
      .prompt.success.xs .content {
        overflow-wrap: break-word;
      }
      .flex {
        display: flex;
      }
      .items-center {
        align-items: center;
      }
      .gap-4 {
        gap: 1rem; /* Adjust gap as needed */
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body class="flex flex-col gap-6 px-20 transition-all duration-300 bg-bw-50">
    <div
      class="flex gap-6 items-center sticky top-0 p-4 bg-bw-50 z-10 ground-glass shadow-md"
      id="title"
    >
      <h1 class="text-4xl font-bold text-bw-600">Pastel Inference Client</h1>
      <input
        id="theme-toggle"
        class="switch success lg"
        data-content="☀"
        type="checkbox"
        onchange="toggleDarkMode()"
      />
    </div>
    <div
      class="grid grid-cols-5 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl col-span-full text-bw-800">User Information</h2>
      <div class="col-span-full">
        <button
          id="changePastelIDButton"
          class="btn success"
          onclick="togglePastelIDDropdown()"
        >
          Switch to a Different PastelID
        </button>
        <div id="pastelIDDropdownContainer" class="mt-4 hidden">
          <label class="block text-bw-700 font-bold mb-2"
            >Select Existing PastelID to Use:</label
          >
          <select id="pastelIDDropdown" class="select w-full">
            <!-- Options will be dynamically populated -->
          </select>
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2"
            >Your Currently Selected PastelID:</label
          >
          <span id="userPastelID" class="text-bw-700">Loading...</span>
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2"
            >Wallet Balance (PSL):</label
          >
          <span id="walletBalance" class="text-bw-700">
            Loading...
            <script>
              document.addEventListener("DOMContentLoaded", async () => {
                try {
                  const walletInfoResponse = await axios.get(
                    "/get-wallet-info"
                  );
                  const walletInfo = walletInfoResponse.data.result;
                  const formattedWalletBalance =
                    walletInfo.balance.toLocaleString(undefined, {
                      minimumFractionDigits: 1,
                      maximumFractionDigits: 1,
                    });
                  document.getElementById(
                    "walletBalance"
                  ).textContent = `${formattedWalletBalance} PSL`;
                } catch (error) {
                  console.error("Error retrieving wallet info:", error);
                  document.getElementById("walletBalance").textContent =
                    "Failed to load balance";
                }
              });
            </script>
          </span>
        </div>
        <button id="createPastelIDButton" class="btn success mt-4 hidden">
          Create a PastelID so you can make inference requests? (Costs 1,000
          PSL)
        </button>
      </div>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Create New Credit Pack Ticket</h2>
      <form id="createTicketForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="numCredits"
            >Number of Credits</label
          >
          <input
            class="input w-full"
            id="numCredits"
            type="text"
            placeholder="Enter number of credits"
            value="1500"
            data-raw-value="1500"
          />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxTotalPrice"
            >Maximum Total Price (PSL)</label
          >
          <input
            class="input w-full"
            id="maxTotalPrice"
            type="text"
            placeholder="Enter maximum total price"
            value="150000"
            data-raw-value="150000"
          />
        </div>
        <div>
          <label
            class="block text-bw-700 font-bold mb-2"
            for="maxPerCreditPrice"
            >Maximum Per Credit Price (PSL)</label
          >
          <input
            class="input w-full"
            id="maxPerCreditPrice"
            type="text"
            placeholder="Enter maximum per credit price"
            value="100.0"
            data-raw-value="100.0"
          />
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button
              class="btn success outline"
              type="submit"
              id="createCreditPackButton"
            >
              Create Credit Pack
            </button>
            <div id="loaderContainer"></div>
            <!-- Add this div for the loader -->
            <div class="prompt success xs" id="createTicketStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="createTicketStatus"
                >Current Status:</label
              >
              <div class="content p-2" id="createTicketStatus"></div>
            </div>
          </div>
        </div>

        <div id="newCreditPackTicketDetailsContainer" style="display: none">
          <h3 class="text-xl text-bw-800">New Credit Pack Ticket Details</h3>
          <div class="table-responsive">
            <table class="table bordered bw">
              <thead>
                <tr>
                  <th>Registration TXID</th>
                  <th>SHA3-256 Hash of Credit Pack Purchase Request Fields</th>
                  <th>Responding Supernode PastelID</th>
                  <th>Outcome</th>
                </tr>
              </thead>
              <tbody id="newCreditPackTicketDetails">
                <!-- New ticket details will be dynamically populated here -->
              </tbody>
            </table>
          </div>
        </div>
      </form>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Select Existing Credit Pack Ticket</h2>
      <div class="relative text-bw-700 table-responsive">
        <table class="table bordered bw">
          <thead>
            <tr>
              <th>Select</th>
              <th>Initial Credits in Pack</th>
              <th>Current Credit Balance</th>
              <th>Tracking Address</th>
              <th>Blockheight Registered</th>
              <th>Credit Pack Registration TXID</th>
            </tr>
          </thead>
          <tbody id="creditPackTicketTableBody">
            <!-- Rows will be dynamically populated here -->
          </tbody>
        </table>
        <div class="flex items-center gap-4 mt-4">
          <button id="refreshButton" class="btn success outline p-4 relative">
            Manually Refresh Credit Pack Tickets
            <span
              class="loader hidden absolute inset-0 flex items-center justify-center"
            >
              <div class="is-loading"></div>
            </span>
          </button>
          <div class="btn is-loading hidden" id="loadingMessage">
            Loading...
          </div>
        </div>
      </div>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Create New Inference Request</h2>
      <form id="inferenceRequestForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="inferenceType"
            >Inference Type</label
          >
          <div class="relative text-bw-700">
            <select id="inferenceType" class="select w-full">
              <option value="">Select an inference type</option>
              <option value="text_completion" selected>Text Completion</option>
              <option value="image_generation">Image Generation</option>
            </select>
          </div>
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="model"
            >Model/Service</label
          >
          <div class="relative text-bw-700">
            <select id="model" class="select w-full">
              <option value="">Select a model/service</option>
              <option value="groq-llama3-70b-8192" selected></option>
              <option value="claude3-opus">Claude3-Opus</option>
            </select>
          </div>
        </div>
        <div id="textCompletionSettings" class="col-span-full">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="prompt"
              >Prompt</label
            >
            <textarea
              class="input w-full"
              id="prompt"
              rows="5"
              placeholder="Enter your prompt"
            >
Write me a Shakespeare-style sonnet about Pastel Network and how it's really decentralized and powerful. </textarea
            >
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="maxTokens"
              >Max Tokens</label
            >
            <input
              class="input w-full"
              id="maxTokens"
              type="text"
              placeholder="Enter maximum tokens"
              value="2000"
              data-raw-value="2000"
            />
            <span id="maxTokensFormatted" class="text-bw-700"></span>
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="numCompletions"
              >Number of Completions</label
            >
            <input
              class="input w-full"
              id="numCompletions"
              type="text"
              placeholder="Enter number of completions"
              value="1"
              data-raw-value="1"
            />
            <span id="numCompletionsFormatted" class="text-bw-700"></span>
          </div>
        </div>
        <div
          id="imageGenerationSettings"
          class="col-span-full"
          style="display: none"
        >
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imagePrompt"
              >Image Prompt</label
            >
            <textarea
              class="input w-full"
              id="imagePrompt"
              rows="5"
              placeholder="Enter your image prompt"
            >
A picture of a clown holding a sign that says PASTEL</textarea
            >
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="stylePreset"
              >Style Preset</label
            >
            <div class="relative text-bw-700">
              <select id="stylePreset" class="select w-full">
                <option value="">Select a style preset</option>
                <option value="photographic" selected>Photographic</option>
                <option value="digital-art">Digital Art</option>
                <option value="comic-book">Comic Book</option>
                <!-- Add more style preset options as needed -->
              </select>
            </div>
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="outputFormat"
              >Output Format</label
            >
            <div class="relative text-bw-700">
              <select id="outputFormat" class="select w-full">
                <option value="">Select an output format</option>
                <option value="png" selected>PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="webp">WebP</option>
              </select>
            </div>
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="aspectRatio"
              >Aspect Ratio</label
            >
            <div class="relative text-bw-700">
              <select id="aspectRatio" class="select w-full">
                <option value="">Select an aspect ratio</option>
                <option value="16:9" selected>16:9</option>
                <option value="1:1">1:1</option>
                <option value="4:5">4:5</option>
                <!-- Add more aspect ratio options as needed -->
              </select>
            </div>
          </div>
        </div>
        <div class="mb-4">
          <label class="block text-bw-700 font-bold mb-2" for="maxCost"
            >Maximum Cost (Credits)</label
          >
          <input
            class="input w-full"
            id="maxCost"
            type="text"
            placeholder="Enter maximum cost"
            value="200"
            data-raw-value="200"
          />
          <span id="maxCostFormatted" class="text-bw-700"></span>
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button class="btn success outline" type="submit">
              Create Inference Request
            </button>
            <div class="prompt success xs" id="currentStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="currentStatus"
                >Current Status:</label
              >
              <div class="content p-2" id="currentStatus"></div>
            </div>
          </div>
        </div>

        <div id="inferenceRequestResult"></div>
      </form>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">View Previous Inference Requests</h2>
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div
          id="previousRequestsList"
          class="bg-gray-100 p-4 rounded-lg overflow-y-auto"
          style="max-height: 300px"
        >
          <!-- List of previous inference requests will be dynamically populated here -->
        </div>
        <div id="requestPreview" class="bg-gray-50 p-4 rounded-lg">
          <!-- Preview of selected inference request will be shown here -->
        </div>
      </div>
    </div>

    <div
      class="grid grid-cols-1 lg:grid-cols-2 gap-8 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <div>
        <h2 class="text-2xl mb-4 text-bw-800">
          Send and Receive Messages using PastelIDs
        </h2>
        <form id="sendMessageForm" class="grid grid-cols-1 gap-4">
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="toPastelID"
              >Recipient Pastel ID</label
            >
            <input
              class="input w-full"
              id="toPastelID"
              type="text"
              placeholder="Enter recipient Pastel ID"
              value="jXXiVgtFzLto4eYziePHjjb1hj3c6eXdABej5ndnQ62B8ouv1GYveJaD5QUMfainQM3b4MTieQuzFEmJexw8Cr"
            />
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="messageBody"
              >Message Body</label
            >
            <textarea
              class="input w-full"
              id="messageBody"
              rows="5"
              placeholder="Enter your message"
            >
Hello, this is a brand 🍉 NEW test message from a regular user!</textarea
            >
          </div>
          <div class="flex justify-between">
            <button class="btn success outline" type="submit">
              Send Message
            </button>
          </div>
        </form>
      </div>
      <div>
        <h2 class="text-2xl mb-4">Received Messages</h2>
        <div id="receivedMessages" class="bg-bw-50 p-4 rounded-xl">
          <!-- Received messages will be dynamically populated here -->
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl">
      <h2 class="text-2xl">Manage Wallet</h2>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importPrivKey">
          Import Private Key
          <span
            class="tooltip"
            data-tooltip="Import a private key into your wallet."
            >&#9432;</span
          >
        </label>
        <input
          id="importPrivKey"
          class="input w-full"
          type="text"
          placeholder="Enter private key"
        />
        <button id="importPrivKeyButton" class="btn success outline mt-2">
          Import Private Key
        </button>
      </div>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importWallet">
          Import Wallet
          <span
            class="tooltip"
            data-tooltip="Import a wallet file into your wallet."
            >&#9432;</span
          >
        </label>
        <input
          id="importWallet"
          class="input w-full"
          type="file"
          accept=".dat"
        />
        <button id="importWalletButton" class="btn success outline mt-2">
          Import Wallet
        </button>
      </div>

      <label
        class="block text-bw-700 font-bold mb-2"
        for="listAddressAmountsButton"
        >Misc Functions:</label
      >

      <div class="mb-4">
        <button id="listAddressAmountsButton" class="btn success outline">
          List Address Amounts
          <span
            class="tooltip"
            data-tooltip="List the amounts associated with each address in your wallet."
            >&#9432;</span
          >
        </button>
      </div>
      <div>
        <button id="getWalletInfoButton" class="btn success outline">
          Get Wallet Info
          <span
            class="tooltip"
            data-tooltip="Retrieve information about your wallet."
            >&#9432;</span
          >
        </button>
      </div>
    </div>
    <button onclick="toggleTerminal()" class="btn success outline">
      Toggle Terminal
    </button>

    <h2 class="text-2xl">Terminal</h2>

    <div id="terminal" class="bg-gray-900 text-white p-4 rounded-xl"></div>

    <div class="bg-bw-800 text-bw-50 py-6">
      <div class="container mx-auto px-4">
        <p class="text-center">
          &copy; 2023 Pastel Inference Client UI. All rights reserved.
        </p>
      </div>
    </div>

    <script>
      const MESSAGING_TIMEOUT_IN_SECONDS = 60;
      const LOADING_MESSAGE = "Wait while data is loaded...";
      const STORAGE_KEY = "validCreditPackTickets";
      const STORAGE_TIMESTAMP_KEY = "creditPackTicketsTimestamp";
      const REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      function formatNumberWithCommas(number) {
        return number.toLocaleString();
      }

      function parseAndFormatNumber(value) {
        const number = parseFloat(value.replace(/,/g, ""));
        return isNaN(number) ? value : formatNumberWithCommas(number);
      }

      function handleInputChange(event) {
        const inputElement = event.target;
        const rawValue = inputElement.value.replace(/,/g, "");
        inputElement.setAttribute("data-raw-value", rawValue);
      }

      function handleInputBlur(event) {
        const inputElement = event.target;
        const formattedValue = parseAndFormatNumber(inputElement.value);
        inputElement.value = formattedValue;
      }

      function parseAndFormat(value) {
        try {
          if (typeof value === "string") {
            // Check if the JSON string is already formatted
            if (value.includes("\n")) {
              return value;
            }
            // Parse JSON string to handle it properly
            const parsedValue = JSON.parse(value);
            return JSON.stringify(parsedValue, null, 4); // Indent JSON string
          }
          return JSON.stringify(value, null, 4); // Format other values
        } catch (error) {
          return value; // Return original value if parsing fails
        }
      }

      function prettyJSON(data) {
        if (data instanceof Map) {
          data = Object.fromEntries(data); // Convert Map to object
        }
        if (
          Array.isArray(data) ||
          (typeof data === "object" && data !== null)
        ) {
          const formattedData = {};
          for (const [key, value] of Object.entries(data)) {
            if (typeof value === "string" && key.endsWith("_json")) {
              formattedData[key] = parseAndFormat(value);
            } else if (typeof value === "object" && value !== null) {
              formattedData[key] = prettyJSON(value); // Recurse for nested objects
            } else {
              formattedData[key] = value; // Handle other types
            }
          }
          return JSON.stringify(formattedData, null, 4); // Pretty print the object
        } else if (typeof data === "string") {
          return parseAndFormat(data); // Handle strings separately
        }
        return data; // Return data as is for other types
      }

      function logActionWithPayload(action, payloadName, jsonPayload) {
        logger.info(
          `Now ${action} ${payloadName} with payload:\n${prettyJSON(
            jsonPayload
          )}`
        );
      }

      function togglePastelIDDropdown() {
        const dropdown = document.getElementById("pastelIDDropdown");
        dropdown.classList.toggle("hidden");
      }

      function updatePastelIDSelection() {
        const selectedID = document.getElementById("pastelIDDropdown").value;
        document.getElementById("userPastelID").textContent = selectedID;
        togglePastelIDDropdown(); // Hide dropdown after selection
      }

      async function checkCreditPackTicketInfo(txid) {
        try {
          const response = await axios.get(`/credit-pack-info/${txid}`);
          const { requestResponse, requestConfirmation, balanceInfo } =
            response.data;
          document.getElementById("requestResponse").textContent =
            JSON.stringify(requestResponse, null, 2);
          document.getElementById("requestConfirmation").textContent =
            JSON.stringify(requestConfirmation, null, 2);
          document.getElementById("currentCreditBalance").textContent =
            balanceInfo.current_credit_balance;
          document.getElementById("numberOfTransactions").textContent =
            balanceInfo.number_of_confirmation_transactions;
        } catch (error) {
          console.error("Error checking credit pack ticket info:", error);
          document.getElementById("requestResponse").textContent =
            "Failed to load credit pack info";
          document.getElementById("requestConfirmation").textContent = "";
          document.getElementById("currentCreditBalance").textContent = "";
          document.getElementById("numberOfTransactions").textContent = "";
        }
      }

      function getAddressURL(address) {
        let baseURL = "https://explorer.pastel.network/address/";
        if (address.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/address/";
        } else if (address.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/address/";
        }
        return `${baseURL}${address}`;
      }

      function getTxidURL(trackingAddress, txid) {
        let baseURL = "https://explorer.pastel.network/tx/";
        if (trackingAddress.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/tx/";
        } else if (trackingAddress.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/tx/";
        }
        return `${baseURL}${txid}`;
      }

      async function checkTrackingAddresses() {
        try {
          const response = await fetch("/list-address-amounts");
          if (!response.ok) {
            throw new Error("Failed to fetch address amounts");
          }
          const data = await response.json();
          const walletAddresses = Object.keys(data.result);

          const trackingAddresses =
            document.querySelectorAll(".tracking-address");
          trackingAddresses.forEach((element) => {
            const address = element.textContent.trim();
            if (walletAddresses.includes(address)) {
              element.classList.add("valid-address");
              element.classList.remove("invalid-address");
            } else {
              element.classList.add("invalid-address");
              element.classList.remove("valid-address");
            }
          });
        } catch (error) {
          console.error("Error checking tracking addresses:", error.message);
        }
      }

      async function getMyValidCreditPacks(forceRefresh = false) {
        const loadingMessage = document.getElementById("loadingMessage");
        const tableBody = document.getElementById("creditPackTicketTableBody");
        loadingMessage.style.display = "block";

        try {
          let validCreditPackTickets = [];
          const now = new Date().getTime();

          if (!forceRefresh) {
            const savedData = localStorage.getItem(STORAGE_KEY);
            const savedTimestamp = localStorage.getItem(STORAGE_TIMESTAMP_KEY);

            if (
              savedData &&
              savedTimestamp &&
              now - savedTimestamp < REFRESH_INTERVAL
            ) {
              validCreditPackTickets = JSON.parse(savedData);
            } else {
              const response = await axios.get("/get-my-valid-credit-packs");
              validCreditPackTickets = response.data.result;
              localStorage.setItem(
                STORAGE_KEY,
                JSON.stringify(validCreditPackTickets)
              );
              localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
            }
          } else {
            const response = await axios.get("/get-my-valid-credit-packs");
            validCreditPackTickets = response.data.result;
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify(validCreditPackTickets)
            );
            localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
          }

          // Fetch wallet addresses
          const walletResponse = await axios.get("/list-address-amounts");
          const walletAddresses = Object.keys(walletResponse.data.result);

          // Filter valid credit pack tickets based on tracking addresses
          validCreditPackTickets = validCreditPackTickets.filter((ticket) =>
            walletAddresses.includes(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address
            )
          );

          tableBody.innerHTML = "";

          for (const ticket of validCreditPackTickets) {
            const row = document.createElement("tr");

            const radioCell = document.createElement("td");
            const radioInput = document.createElement("input");
            radioInput.type = "radio";
            radioInput.name = "creditPackTicket";
            radioInput.value =
              ticket.credit_pack_purchase_request.requesting_end_user_pastelid;
            radioInput.dataset.txid =
              ticket.credit_pack_purchase_request_confirmation.txid_of_credit_purchase_burn_transaction;
            radioCell.appendChild(radioInput);
            row.appendChild(radioCell);

            const initialCreditsCell = document.createElement("td");
            initialCreditsCell.classList.add("truncate");
            initialCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_purchase_request
                .requested_initial_credits_in_credit_pack
            );
            row.appendChild(initialCreditsCell);

            const currentCreditsCell = document.createElement("td");
            currentCreditsCell.classList.add("truncate");
            currentCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_current_credit_balance
            );
            row.appendChild(currentCreditsCell);

            const trackingAddressCell = document.createElement("td");
            trackingAddressCell.classList.add("truncate", "tracking-address");
            const addressLink = document.createElement("a");
            addressLink.href = getAddressURL(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address
            );
            addressLink.target = "_blank";
            addressLink.textContent =
              ticket.credit_pack_purchase_request.credit_usage_tracking_psl_address;
            trackingAddressCell.appendChild(addressLink);
            row.appendChild(trackingAddressCell);

            const blockheightCell = document.createElement("td");
            blockheightCell.classList.add("truncate");
            blockheightCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_purchase_request.request_pastel_block_height
            );
            row.appendChild(blockheightCell);

            const creditPackRegistrationTxidCell = document.createElement("td");
            creditPackRegistrationTxidCell.classList.add("truncate");
            const txLink = document.createElement("a");
            txLink.href = getTxidURL(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address,
              ticket.credit_pack_registration_txid
            );
            txLink.target = "_blank";
            txLink.textContent = ticket.credit_pack_registration_txid;
            creditPackRegistrationTxidCell.appendChild(txLink);
            row.appendChild(creditPackRegistrationTxidCell);

            tableBody.appendChild(row);
          }

          handleCreditPackSelection(); // Re-apply event listeners

          if (validCreditPackTickets.length > 0) {
            const lastRadioInput = tableBody.querySelectorAll(
              'input[type="radio"]'
            )[validCreditPackTickets.length - 1];
            lastRadioInput.checked = true;
            lastRadioInput.dispatchEvent(new Event("change"));
          }
        } catch (error) {
          console.error("Error retrieving valid credit pack tickets:", error);
        } finally {
          loadingMessage.style.display = "none";
        }
      }

      function logCreateTicketStatusMessage(message, container) {
        container.innerHTML = ""; // Clear previous log messages
        const logElement = document.createElement("div");
        logElement.textContent = message;
        container.appendChild(logElement);
        container.scrollTop = container.scrollHeight; // Scroll to bottom
      }

      async function createNewCreditPackTicket(
        numCredits,
        maxTotalPrice,
        maxPerCreditPrice
      ) {
        const statusContainer = document.getElementById(
          "createTicketStatusContainer"
        );
        const statusContent = document.getElementById("createTicketStatus");
        const loaderContainer = document.getElementById("loaderContainer"); // Get the loader container

        if (!statusContainer || !statusContent || !loaderContainer) {
          console.error(
            "Status container, status content, or loader container element not found."
          );
          return;
        }

        statusContent.innerHTML = ""; // Clear previous logs
        loaderContainer.innerHTML = ""; // Clear previous loader if any

        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader); // Append to loader container

        const newTicketDetailsContainer = document.getElementById(
          "newCreditPackTicketDetailsContainer"
        );
        const newTicketDetails = document.getElementById(
          "newCreditPackTicketDetails"
        );

        if (!newTicketDetailsContainer || !newTicketDetails) {
          console.error(
            "New ticket details container or new ticket details element not found."
          );
          return;
        }

        displayCreateTicketLoggerMessages = true;

        try {
          logCreateTicketStatusMessage(
            "Starting the creation of a new credit pack ticket...",
            statusContent
          );

          const desiredNumberOfCredits = numCredits;
          const amountOfPSLForTrackingTransactions = 10.0;
          const creditPriceCushionPercentage = 0.15;

          const estimatedTotalCostInPSLForCreditPackResponse = await axios.post(
            "/estimate-credit-pack-cost",
            {
              desiredNumberOfCredits,
              creditPriceCushionPercentage,
            }
          );

          const estimatedTotalCostInPSLForCreditPack =
            estimatedTotalCostInPSLForCreditPackResponse.data.result;

          if (estimatedTotalCostInPSLForCreditPack === undefined) {
            throw new Error(
              "Failed to estimate total cost for the credit pack"
            );
          }

          const amountToFundCreditTrackingAddress = Math.round(
            amountOfPSLForTrackingTransactions +
              estimatedTotalCostInPSLForCreditPack
          );

          const response = await axios.post("/create-and-fund-new-address", {
            amount: amountToFundCreditTrackingAddress,
          });

          if (!response.data.success) {
            throw new Error(
              "Failed to create and fund new credit tracking address"
            );
          }

          const creditUsageTrackingPSLAddress =
            response.data.result.newCreditTrackingAddress;

          logCreateTicketStatusMessage(
            "Credit tracking address created and funded successfully.",
            statusContent
          );

          const ticketResponse = await axios.post(
            "/create-credit-pack-ticket",
            {
              numCredits,
              creditUsageTrackingPSLAddress,
              maxTotalPrice,
              maxPerCreditPrice,
            }
          );

          if (ticketResponse.data.success) {
            logCreateTicketStatusMessage(
              "Credit pack ticket created successfully.",
              statusContent
            );
            const result = ticketResponse.data.result;
            const formattedResult = prettyJSON(result);
            logCreateTicketStatusMessage(
              `Result: ${formattedResult}`,
              statusContent
            );

            newTicketDetails.innerHTML = `
              <tr>
                <td class="truncate">
                  <a href="${getTxidURL(
                    creditUsageTrackingPSLAddress,
                    result.pastel_api_credit_pack_ticket_registration_txid
                  )}" target="_blank">
                    ${result.pastel_api_credit_pack_ticket_registration_txid}
                  </a>
                </td>
                <td class="truncate">${
                  result.sha3_256_hash_of_credit_pack_purchase_request_fields
                }</td>
                <td class="truncate">${
                  result.responding_supernode_pastelid
                }</td>
                <td class="truncate">${
                  result.credit_pack_confirmation_outcome_string
                }</td>
              </tr>
            `;

            newTicketDetailsContainer.style.display = "block";

            return result;
          } else {
            throw new Error("Failed to create new credit pack ticket");
          }
        } catch (error) {
          console.error(
            `Error creating new credit pack ticket: ${error.message}`
          );
          logCreateTicketStatusMessage(
            "Failed to create credit pack ticket. Please try again.",
            statusContent
          );
          throw error;
        } finally {
          creditPackLoader.remove();
          displayCreateTicketLoggerMessages = false;
        }
      }

      // Handle inference request stuff:
      let modelMenu = null;

      async function fetchModelMenu() {
        try {
          const response = await axios.get("/get-inference-model-menu");
          modelMenu = response.data.modelMenu;
          console.log("Model Menu:", modelMenu); // Debugging line, consider removing for production
          populateModelDropdown();
        } catch (error) {
          console.error("Error fetching model menu:", error);
          displayError("Failed to load model menu. Please try again later.");
        }
      }

      function populateModelDropdown() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const modelSelect = document.getElementById("model");
        modelSelect.innerHTML =
          '<option value="">Select a model/service</option>';

        if (modelMenu) {
          const filteredModels = modelMenu.models.filter(
            (model) =>
              model.supported_inference_type_strings &&
              model.supported_inference_type_strings.includes(
                selectedInferenceType
              )
          );

          let defaultModelSet = false;
          filteredModels.forEach((model) => {
            const option = document.createElement("option");
            option.value = model.model_name;
            option.textContent = model.model_name;

            if (model.model_name === "groq-llama3-70b-8192") {
              option.selected = true;
              defaultModelSet = true;
            }

            modelSelect.appendChild(option);
          });

          if (!defaultModelSet && filteredModels.length > 0) {
            modelSelect.options[1].selected = true;
          }
        }
      }

      function displayError(message) {
        // Implement user-friendly error handling/display mechanism
        alert(message); // Simplistic example, consider more sophisticated modal or notification systems
      }

      // Load inference request settings from localStorage
      function loadInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const storedSettings = localStorage.getItem(
          `inferenceRequestSettings_${selectedInferenceType}`
        );
        if (storedSettings) {
          const settings = JSON.parse(storedSettings);
          document.getElementById("model").value = settings.model || "";
          document.getElementById("prompt").value = settings.prompt || "";
          document.getElementById("maxTokens").value = settings.maxTokens || "";
          document.getElementById("numCompletions").value =
            settings.numCompletions || "";
          document.getElementById("maxCost").value = settings.maxCost || "";
          document.getElementById("imagePrompt").value =
            settings.imagePrompt || "";
          document.getElementById("stylePreset").value =
            settings.stylePreset || "";
          document.getElementById("outputFormat").value =
            settings.outputFormat || "";
          document.getElementById("aspectRatio").value =
            settings.aspectRatio || "";
        }
      }

      // Save inference request settings to localStorage
      function saveInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const settings = {
          model: document.getElementById("model").value,
          prompt: document.getElementById("prompt").value,
          maxTokens: document.querySelector("#maxTokens").dataset.rawValue,
          numCompletions:
            document.querySelector("#numCompletions").dataset.rawValue,
          maxCost: document.querySelector("#maxCost").dataset.rawValue,
          imagePrompt: document.getElementById("imagePrompt").value,
          stylePreset: document.getElementById("stylePreset").value,
          outputFormat: document.getElementById("outputFormat").value,
          aspectRatio: document.getElementById("aspectRatio").value,
        };
        localStorage.setItem(
          `inferenceRequestSettings_${selectedInferenceType}`,
          JSON.stringify(settings)
        );
      }

      // Fetch the model menu when the page loads
      fetchModelMenu();

      // Handle inference type change
      const inferenceTypeSelect = document.getElementById("inferenceType");
      const textCompletionSettings = document.getElementById(
        "textCompletionSettings"
      );
      const imageGenerationSettings = document.getElementById(
        "imageGenerationSettings"
      );

      inferenceTypeSelect.addEventListener("change", () => {
        const selectedInferenceType = inferenceTypeSelect.value;
        if (selectedInferenceType === "text_completion") {
          textCompletionSettings.style.display = "block";
          imageGenerationSettings.style.display = "none";
        } else if (selectedInferenceType === "image_generation") {
          textCompletionSettings.style.display = "none";
          imageGenerationSettings.style.display = "block";
        }
        populateModelDropdown();
        loadInferenceRequestSettings();
      });

      function handleCreditPackSelection() {
        const radioButtons = document.querySelectorAll(
          'input[name="creditPackTicket"]'
        );
        radioButtons.forEach((button) => {
          button.addEventListener("change", () => {
            document
              .querySelectorAll("#creditPackTicketTableBody tr")
              .forEach((row) => {
                row.classList.remove("bg-gray-200", "selected-row");
              });
            button.parentElement.parentElement.classList.add(
              "bg-gray-200",
              "selected-row"
            );
          });
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        handleCreditPackSelection();
      });

      let displayInferenceRequestLoggerMessages = false;
      let displayCreateTicketLoggerMessages = false;

      function logStatusMessage(message) {
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.textContent = `${prettyJSON(message)}`;
      }

      function saveInferenceRequestToLocalStorage(requestData) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        requests.push(requestData);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      function updatePreviousRequestsList() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const listContainer = document.getElementById("previousRequestsList");
        listContainer.innerHTML = "";

        if (requests.length === 0) {
          const noRequestsMessage = document.createElement("p");
          noRequestsMessage.className = "text-gray-500";
          noRequestsMessage.textContent =
            "No saved inference requests to display. Create new ones and they will display here when they finish successfully.";
          listContainer.appendChild(noRequestsMessage);
        } else {
          requests.forEach((request, index) => {
            const listItem = document.createElement("div");
            listItem.className = "mb-2 p-2 bg-white rounded-lg cursor-pointer";
            listItem.textContent = `${request.prompt.substring(0, 40)}...`;
            listItem.addEventListener("click", () =>
              displayRequestPreview(index)
            );
            listContainer.appendChild(listItem);
          });
        }
      }

      function displayRequestPreview(index) {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const request = requests[index];
        const previewContainer = document.getElementById("requestPreview");

        let combinedResults = "";
        request.inferenceResultsDecoded.forEach((result, i) => {
          combinedResults += `<h4>Completion ${i + 1} of ${
            request.inferenceResultsDecoded.length
          }</h4>`;
          combinedResults += `<github-md>${result}</github-md>`;
          if (i < request.inferenceResultsDecoded.length - 1) {
            combinedResults += "<hr>";
          }
        });

        previewContainer.innerHTML = `
          <div class="mb-4">
            <h3 class="font-bold">Inference Result:</h3>
            ${combinedResults}
          </div>
          <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
          <div class="table-responsive">
            <table class="table">
              <tr><th>Input Prompt to LLM</th><td>${request.prompt}</td></tr>
              <tr><th>Proposed Cost (Credits)</th><td>${request.maxCost}</td></tr>
              <tr><th>Model</th><td>${request.selectedModel}</td></tr>
            </table>
          </div>
        `;

        renderMarkdown();
      }

      // Call updatePreviousRequestsList on page load
      document.addEventListener("DOMContentLoaded", updatePreviousRequestsList);

      async function createNewInferenceRequest(
        selectedCreditPackTicketId,
        selectedInferenceType,
        selectedModel,
        prompt,
        maxTokens,
        numCompletions,
        maxCost
      ) {
        const resultContainer = document.getElementById(
          "inferenceRequestResult"
        );
        resultContainer.innerHTML = "";
        const loader = document.createElement("div");
        loader.className = "btn is-loading";
        loader.innerText = "Loading...";
        resultContainer.appendChild(loader);

        displayInferenceRequestLoggerMessages = true;

        try {
          logStatusMessage("Creating new inference request...");
          const response = await axios.post("/create-inference-request", {
            selectedCreditPackTicketId,
            selectedInferenceType,
            selectedModel,
            prompt,
            maxTokens,
            numCompletions,
            maxCost,
          });

          if (response.data.success) {
            logStatusMessage("Inference request created successfully.");
            const inferenceResultDict =
              response.data.result.inferenceResultDict;
            const inferenceResultsDecoded = JSON.parse(
              inferenceResultDict.inference_result_decoded
            );
            const inputPromptToLLM = inferenceResultDict.input_prompt_to_llm;
            const {
              proposed_cost_of_request_in_inference_credits,
              remaining_credits_in_pack_after_request_processed,
              responding_supernode_pastelid,
            } = inferenceResultDict.usage_request_response;

            let combinedResults = "";
            if (inferenceResultsDecoded.length > 1) {
              inferenceResultsDecoded.forEach((result, index) => {
                combinedResults += `<h4>Completion ${index + 1} of ${
                  inferenceResultsDecoded.length
                }</h4>`;
                combinedResults += `<github-md>${result}</github-md>`;
                if (index < inferenceResultsDecoded.length - 1) {
                  combinedResults += "<hr>";
                }
              });
            } else {
              combinedResults = `<github-md>${inferenceResultsDecoded[0]}</github-md>`;
            }

            resultContainer.innerHTML = `
              <div class="mb-4">
                <h3 class="font-bold">Inference Result:</h3>
                ${combinedResults}
              </div>
              <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
              <div class="table-responsive">
                <table class="table">
                  <tr><th>Input Prompt to LLM</th><td>${inputPromptToLLM}</td></tr>
                  <tr><th>Proposed Cost (Credits)</th><td>${proposed_cost_of_request_in_inference_credits}</td></tr>
                  <tr><th>Remaining Credits</th><td>${remaining_credits_in_pack_after_request_processed}</td></tr>
                  <tr><th>Supernode PastelID</th><td>${responding_supernode_pastelid}</td></tr>
                </table>
              </div>
            `;

            // Save inference request and results to localStorage
            saveInferenceRequestToLocalStorage({
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModel,
              prompt,
              maxTokens,
              numCompletions,
              maxCost,
              inferenceResultsDecoded,
            });

            renderMarkdown();
          } else {
            throw new Error("Failed to create inference request");
          }
        } catch (error) {
          console.error(
            `Error creating new inference request: ${error.message}`
          );
          resultContainer.innerHTML =
            "Failed to create inference request. Please try again.";
          logStatusMessage("Failed to create inference request.");
        } finally {
          loader.remove();
          displayInferenceRequestLoggerMessages = false;
        }
      }

      // Function to fetch and display received messages
      async function fetchReceivedMessages() {
        try {
          const userPastelID =
            document.getElementById("pastelIDDropdown").value;

          const response = await axios.get("/get-best-supernode-url", {
            params: { userPastelID },
          });
          const supernodeURL = response.data.supernodeURL;

          const messagesResponse = await axios.get("/get-received-messages", {
            timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
          });
          const messageDict = messagesResponse.data.messageDict;

          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML = ""; // Clear previous messages

          for (const pastelId in messageDict) {
            const messages = messageDict[pastelId];
            messages.forEach((message) => {
              const messageElement = document.createElement("div");
              messageElement.classList.add(
                "mb-4",
                "border",
                "border-gray-300",
                "rounded-lg",
                "p-4"
              );

              const fromPastelIDElement = document.createElement("p");
              fromPastelIDElement.classList.add(
                "text-sm",
                "font-medium",
                "text-gray-600",
                "mb-2"
              );
              fromPastelIDElement.textContent = `From: ${pastelId}`;

              const messageBodyElement = document.createElement("p");
              messageBodyElement.classList.add(
                "text-base",
                "text-gray-800",
                "mb-2"
              );
              messageBodyElement.textContent = message.message_body;

              const timestampElement = document.createElement("p");
              timestampElement.classList.add("text-xs", "text-gray-500");
              timestampElement.textContent = new Date(
                message.timestamp
              ).toLocaleString();

              messageElement.appendChild(fromPastelIDElement);
              messageElement.appendChild(messageBodyElement);
              messageElement.appendChild(timestampElement);

              receivedMessagesContainer.appendChild(messageElement);
            });
          }
        } catch (error) {
          console.error("Error retrieving received messages:", error);
          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML =
            "Failed to retrieve received messages. Please try again later.";
        }
      }

      // Fetch received messages when the page loads
      window.addEventListener("DOMContentLoaded", fetchReceivedMessages);

      window.addEventListener("DOMContentLoaded", async () => {
        const pastelIDElement = document.getElementById("userPastelID");
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const pastelIDDropdownContainer = document.getElementById(
          "pastelIDDropdownContainer"
        );
        const createPastelIDButton = document.getElementById(
          "createPastelIDButton"
        );
        const changePastelIDButton = document.getElementById(
          "changePastelIDButton"
        );

        await getMyValidCreditPacks();

        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          const pastelIDTickets = response.data.result;

          // Clear existing options
          pastelIDDropdown.innerHTML = "";

          if (pastelIDTickets.length > 0) {
            pastelIDTickets.forEach((ticket, index) => {
              const option = document.createElement("option");
              option.value = ticket.ticket.pastelID;
              option.textContent = ticket.ticket.pastelID;
              pastelIDDropdown.appendChild(option);
              if (index === 0) {
                pastelIDElement.textContent = ticket.ticket.pastelID; // Display the first PastelID by default
              }
            });
            // Only show the change button and dropdown if there are multiple PastelIDs
            if (pastelIDTickets.length > 1) {
              changePastelIDButton.classList.remove("hidden");
              pastelIDDropdownContainer.classList.remove("hidden");
            } else {
              changePastelIDButton.classList.add("hidden");
              pastelIDDropdownContainer.classList.add("hidden");
            }
          } else {
            pastelIDElement.textContent = "No PastelID found";
            createPastelIDButton.style.display = "block"; // Show create button if no IDs
          }
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          pastelIDElement.textContent = "Failed to load PastelIDs";
        }
      });

      // Handle create PastelID button click
      document
        .getElementById("createPastelIDButton")
        .addEventListener("click", async () => {
          try {
            await axios.post("/check-for-pastel-id", { autoRegister: true });
            location.reload(); // Refresh the page to update the UI
          } catch (error) {
            console.error("Error creating PastelID:", error);
          }
        });

      // Handle import private key form submission
      document
        .getElementById("importPrivKeyButton")
        .addEventListener("click", async () => {
          const privKey = document.getElementById("importPrivKey").value;
          try {
            await axios.post("/import-priv-key", { zcashPrivKey: privKey });
            alert("Private key imported successfully!");
          } catch (error) {
            console.error("Error importing private key:", error);
          }
        });

      // Handle import wallet form submission
      document
        .getElementById("importWalletButton")
        .addEventListener("click", async () => {
          const walletFile = document.getElementById("importWallet").files[0];
          const formData = new FormData();
          formData.append("walletFile", walletFile);
          try {
            await axios.post("/import-wallet", formData);
            alert("Wallet imported successfully!");
          } catch (error) {
            console.error("Error importing wallet:", error);
          }
        });

      // Handle list address amounts button click
      document
        .getElementById("listAddressAmountsButton")
        .addEventListener("click", async () => {
          try {
            const response = await axios.get("/list-address-amounts");
            const addressAmounts = response.data.result;
            console.log("Address amounts:", addressAmounts);
            // Display the address amounts in the UI as needed
          } catch (error) {
            console.error("Error retrieving address amounts:", error);
          }
        });

      // Handle get wallet info button click
      document
        .getElementById("getWalletInfoButton")
        .addEventListener("click", async () => {
          try {
            const response = await axios.get("/get-wallet-info");
            const walletInfo = response.data.result;
            console.log("Wallet info:", walletInfo);
            // Display the wallet info in the UI as needed
          } catch (error) {
            console.error("Error retrieving wallet info:", error);
          }
        });

      // Create a terminal and load the fit addon
      const term = new Terminal();
      term.open(document.getElementById("terminal"));
      term.terminalOptions = {
        fontSize: 7,
        enableBold: true,
        cols: 150,
        rows: 25,
      };

      function resizeTerminal() {
        const terminalElement = document.getElementById("terminal");
        const cols = Math.floor(terminalElement.clientWidth / 10); // Approximate character width
        const rows = Math.floor(terminalElement.clientHeight / 20); // Approximate character height

        console.log(
          `Cols: ${cols}, Rows: ${rows}, Type of Cols: ${typeof cols}, Type of Rows: ${typeof rows}`
        );

        if (cols > 0 && rows > 0) {
          term.resize(cols, rows);
        }
      }

      resizeTerminal();
      window.addEventListener("resize", resizeTerminal);

      function displayStatusMessage(message) {
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.textContent = message;
      }

      fetch("/ws-url")
        .then((response) => response.json())
        .then((data) => {
          const socket = new WebSocket(data.wsUrl);

          socket.onopen = () => {
            console.log("WebSocket connection established");
          };

          socket.onmessage = (event) => {
            console.log("Received:", event.data);
            const logMessage = JSON.parse(event.data);
            const formattedMessage = prettyJSON(logMessage);
            term.writeln(
              `[${logMessage.timestamp}] [${logMessage.level}] ${logMessage.message}`
            );
            term.write(formattedMessage);

            if (displayInferenceRequestLoggerMessages) {
              logStatusMessage(logMessage.message);
            }

            if (displayCreateTicketLoggerMessages) {
              const statusContainer = document.getElementById(
                "createTicketStatusContainer"
              );
              const statusContent =
                document.getElementById("createTicketStatus");
              logCreateTicketStatusMessage(logMessage.message, statusContent);
            }
          };

          socket.onclose = () => {
            console.log("WebSocket connection closed");
          };

          socket.onerror = (error) => {
            console.error("WebSocket error:", error);
          };
        })
        .catch((error) => {
          console.error("Error fetching WebSocket URL:", error);
        });

      function toggleTerminal() {
        const terminal = document.getElementById("terminal");
        if (terminal.style.display === "none") {
          terminal.style.display = "block";
        } else {
          terminal.style.display = "none";
        }
        resizeTerminal();
      }

      tailwind.config = {
        theme: {
          extend: {},
        },
      };

      var storedTheme =
        localStorage.getItem("theme") ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light");
      if (storedTheme)
        document.documentElement.setAttribute("data-theme", storedTheme);

      function toggleDarkMode() {
        var currentTheme = document.documentElement.getAttribute("data-theme");
        var targetTheme = currentTheme === "light" ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", targetTheme);
        localStorage.setItem("theme", targetTheme);
        document
          .querySelector("#theme-toggle")
          .setAttribute("data-content", targetTheme === "dark" ? "🌙" : "☀");
      }

      // Set the initial state of the switch toggle
      const toggle = document.querySelector("#theme-toggle");
      if (storedTheme === "dark") {
        toggle.checked = true;
        toggle.setAttribute("data-content", "🌙");
      } else {
        toggle.checked = false;
        toggle.setAttribute("data-content", "☀");
      }

      // Format the values and display them using template literals
      function formatAndDisplay(inputElement) {
        const value = inputElement.value.replace(/,/g, "");
        const number = parseFloat(value);
        if (!isNaN(number)) {
          inputElement.setAttribute("data-raw-value", number);
          inputElement.value = number.toLocaleString();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const createTicketForm = document.getElementById("createTicketForm");

        createTicketForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const numCredits = parseInt(
            document.querySelector("#numCredits").dataset.rawValue
          );
          const maxTotalPrice = parseFloat(
            document.querySelector("#maxTotalPrice").dataset.rawValue
          );
          const maxPerCreditPrice = parseFloat(
            document.querySelector("#maxPerCreditPrice").dataset.rawValue
          );

          const statusContainer = document.getElementById(
            "createTicketStatusContainer"
          );
          const statusContent = document.getElementById("createTicketStatus");
          statusContent.innerHTML = ""; // Clear previous logs

          logCreateTicketStatusMessage(
            "Initializing ticket creation...",
            statusContent
          );

          await createNewCreditPackTicket(
            numCredits,
            maxTotalPrice,
            maxPerCreditPrice
          );
        });

        document
          .getElementById("inferenceRequestForm")
          .addEventListener("submit", async (event) => {
            event.preventDefault();
            saveInferenceRequestSettings();
            const selectedCreditPackTicket = document.querySelector(
              'input[name="creditPackTicket"]:checked'
            );
            if (!selectedCreditPackTicket) {
              alert("Please select a credit pack ticket.");
              return;
            }
            const selectedRow = selectedCreditPackTicket.closest("tr");
            const selectedCreditPackTicketId = selectedRow
              .querySelector("td:last-child a")
              .textContent.trim();
            const selectedInferenceType =
              document.getElementById("inferenceType").value;
            const selectedModel = document.getElementById("model").value;
            const prompt = document.getElementById("prompt").value;
            const maxTokens = parseInt(
              document.querySelector("#maxTokens").dataset.rawValue
            );
            const numCompletions = parseInt(
              document.querySelector("#numCompletions").dataset.rawValue
            );
            const maxCost = parseFloat(
              document.querySelector("#maxCost").dataset.rawValue
            );

            await createNewInferenceRequest(
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModel,
              prompt,
              maxTokens,
              numCompletions,
              maxCost
            );
          });

        // Handle send message form submission
        const sendMessageForm = document.getElementById("sendMessageForm");
        sendMessageForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const toPastelID = document.getElementById("toPastelID").value;
          const messageBody = document.getElementById("messageBody").value;
          await sendMessage(toPastelID, messageBody);
          await fetchReceivedMessages();
        });

        // Additional event listeners and initializations
        const numCreditsInput = document.getElementById("numCredits");
        numCreditsInput.addEventListener("input", handleInputChange);
        numCreditsInput.addEventListener("blur", handleInputBlur);

        const maxTotalPriceInput = document.getElementById("maxTotalPrice");
        maxTotalPriceInput.addEventListener("input", handleInputChange);
        maxTotalPriceInput.addEventListener("blur", handleInputBlur);

        const maxPerCreditPriceInput =
          document.getElementById("maxPerCreditPrice");
        maxPerCreditPriceInput.addEventListener("input", handleInputChange);
        maxPerCreditPriceInput.addEventListener("blur", handleInputBlur);

        const maxTokensInput = document.getElementById("maxTokens");
        const maxTokensFormattedSpan =
          document.getElementById("maxTokensFormatted");
        maxTokensInput.addEventListener("input", () =>
          formatAndDisplay(maxTokensInput, maxTokensFormattedSpan)
        );

        const numCompletionsInput = document.getElementById("numCompletions");
        const numCompletionsFormattedSpan = document.getElementById(
          "numCompletionsFormatted"
        );
        numCompletionsInput.addEventListener("input", () =>
          formatAndDisplay(numCompletionsInput, numCompletionsFormattedSpan)
        );

        const maxCostInput = document.getElementById("maxCost");
        const maxCostFormattedSpan =
          document.getElementById("maxCostFormatted");
        maxCostInput.addEventListener("input", () =>
          formatAndDisplay(maxCostInput, maxCostFormattedSpan)
        );

        // Add event listener for the refresh button
        document
          .getElementById("refreshButton")
          .addEventListener("click", async () => {
            const refreshButton = document.getElementById("refreshButton");
            const loader = refreshButton.querySelector(".loader");
            const loadingMessage = document.getElementById("loadingMessage");

            loader.classList.remove("hidden");
            loadingMessage.classList.remove("hidden");

            await getMyValidCreditPacks(true);

            loader.classList.add("hidden");
            loadingMessage.classList.add("hidden");
          });
      });
    </script>
    <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js"></script>
  </body>
</html>
