<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pastel Inference Client UI</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@sira-ui/tailwind/dist/css/styles.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.9.3/sha3.min.js"></script>
    <style>
      .ground-glass {
        background-color: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
      }
      body {
        font-family: Montserrat, sans-serif;
      }
      .btn.success.outline {
        border-color: #4caf50;
        color: #4caf50;
      }
      .btn.success.outline:hover {
        background-color: #4caf50;
        color: #ffffff;
      }
      .btn.success.outline:active {
        background-color: #388e3c;
        border-color: #388e3c;
        color: #ffffff;
      }
      .xterm {
        width: 100% !important;
        border-radius: 0.5rem; /* Adds rounded corners */
      }
      .table-container {
        overflow-x: auto;
      }
      .table {
        width: 100%;
        table-layout: fixed;
      }
      .table th,
      .table td {
        padding: 0.5rem;
        border: 1px solid #ccc;
      }
      .table th:last-child,
      .table td:last-child {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }
      .table td:last-child:hover {
        white-space: normal;
      }
      [data-theme="dark"] {
        background-color: #121212;
        color: #ffffff;
      }
      [data-theme="dark"] .bg-white {
        background-color: #333333;
      }
      [data-theme="dark"] .text-bw-50 {
        color: #cccccc;
      }
      [data-theme="dark"] .text-bw-600 {
        color: #ffffff;
      }
      [data-theme="dark"] .text-bw-700 {
        color: #eeeeee;
      }
      [data-theme="dark"] .text-bw-800 {
        color: #ffffff;
      }
      [data-theme="dark"] .bg-bw-50 {
        background-color: #333333;
      }
      [data-theme="dark"] .btn.outline.bw {
        border-color: #ffffff;
        color: #ffffff;
      }
      [data-theme="dark"] .btn.outline.bw:hover {
        background-color: #ffffff;
        color: #000000;
      }
      [data-theme="dark"] .table .bg-gray-200 {
        background-color: #333333;
        color: #ffffff; /* This needs to be adjusted */
      }
      [data-theme="dark"] .table .bg-gray-200.selected-row {
        color: #000000; /* Adjust this color to be dark for legibility */
      }
      [data-theme="dark"] #previousRequestsList {
        background-color: #333333;
        color: #ffffff;
      }
      [data-theme="dark"] .delete-btn {
        color: #ffffff;
        border-color: #ffffff;
      }
      .table-responsive {
        overflow-x: auto;
      }
      .truncate {
        max-width: 150px; /* Adjust as needed */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .prompt.success.xs {
        display: inline-block;
        flex-grow: 1; /* Allow it to take up the remaining space */
        max-width: calc(
          100% - 2rem
        ); /* Leave some padding for better readability */
        word-wrap: break-word; /* Ensure the text wraps correctly */
        height: 333px; /* Set a fixed height */
        overflow-y: auto; /* Add a scrollbar if the content exceeds the height */
        padding: 0.5rem; /* Add padding for better readability */
        border: 1px solid #ccc; /* Optional: Add a border for better visibility */
        border-radius: 0.5rem; /* Optional: Add rounded corners */
      }
      .prompt.success.xs .content {
        overflow-wrap: break-word;
      }
      .flex {
        display: flex;
      }
      .items-center {
        align-items: center;
      }
      .gap-4 {
        gap: 1rem; /* Adjust gap as needed */
      }
      .hidden {
        display: none;
      }
      #previousRequestsList {
        background-color: #f9f9f9;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1rem;
        max-height: 400px;
        overflow-y: auto;
      }
      #requestPreview {
        background-color: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1.5rem;
      }
      .delete-btn {
        background: none;
        border: none;
        font-size: 1.25rem;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        transition: box-shadow 0.3s;
      }
      .delete-btn:hover {
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }
      #exportRequestsButton {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: auto;
      }
      .align-middle {
        vertical-align: middle;
      }
      .new-ticket-table {
        width: auto; /* Change to auto to fit content */
        table-layout: auto; /* Use auto layout to fit column content */
      }
    </style>
  </head>
  <body class="flex flex-col gap-6 px-20 transition-all duration-300 bg-bw-50">
    <div
      class="flex gap-6 items-center sticky top-0 p-4 bg-bw-50 z-10 ground-glass shadow-md"
      id="title"
    >
      <h1 class="text-4xl font-bold text-bw-600">
        Pastel Inference Client
        <span id="networkName" class="text-xl font-normal align-middle"></span>
      </h1>
      <input
        id="theme-toggle"
        class="switch success lg"
        data-content="‚òÄ"
        type="checkbox"
        onchange="toggleDarkMode()"
      />
    </div>

    <div
      class="grid grid-cols-5 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl col-span-full text-bw-800">User Information</h2>
      <div class="col-span-full">
        <div id="noPastelIDContainer" class="hidden">
          <p class="text-bw-700">
            No PastelID found. Would you like to create a new one for 1,000 PSL?
          </p>
          <form id="createPastelIDForm" class="mt-4">
            <label
              class="block text-bw-700 font-bold mb-2"
              for="newPastelIDPassphrase"
            >
              Enter Passphrase (min 6 characters):
            </label>
            <input
              id="newPastelIDPassphrase"
              class="input w-full"
              type="password"
              placeholder="Enter passphrase"
              minlength="6"
              required
            />
            <button type="submit" class="btn success outline mt-4">
              Create PastelID
            </button>
            <div id="messageContainer" class="my-4"></div>
            <!-- Container for messages -->
          </form>
          <p class="mt-4">
            Already have an existing PastelID? Import the file here:
          </p>
          <input
            id="importPastelIDFile"
            class="input w-full"
            type="file"
            accept=".dat"
          />
          <button id="importPastelIDButton" class="btn success mt-2">
            Import PastelID
          </button>
        </div>

        <button
          id="changePastelIDButton"
          class="btn outline success"
          onclick="togglePastelIDDropdown()"
        >
          Switch to a Different PastelID
        </button>
        <div id="pastelIDDropdownContainer" class="mt-4 hidden">
          <label class="block text-bw-700 font-bold mb-2"
            >Select Existing PastelID to Use:</label
          >
          <select id="pastelIDDropdown" class="select w-full">
            <!-- Options will be dynamically populated -->
          </select>
        </div>
        <div class="mt-4 hidden" id="passphraseContainer">
          <label
            class="block text-bw-700 font-bold mb-2"
            for="pastelIDPassphrase"
            >Enter Passphrase:</label
          >
          <input
            id="pastelIDPassphrase"
            class="input w-full"
            type="password"
            placeholder="Enter passphrase"
            minlength="6"
            required
          />
          <div class="mt-2">
            <input type="checkbox" id="rememberPassphrase" />
            <label for="rememberPassphrase" class="text-bw-700"
              >Remember password?</label
            >
          </div>
          <button id="submitPassphraseButton" class="btn success outline mt-4">
            Submit
          </button>
          <div id="messageContainer" class="my-4"></div>
          <!-- Container for messages -->
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2"
            >Your Currently Selected PastelID:</label
          >
          <span id="userPastelID" class="text-bw-700">Loading...</span>
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2"
            >Wallet Balance (PSL):</label
          >
          <span id="walletBalance" class="text-bw-700">
            Loading...
            <script>
              document.addEventListener("DOMContentLoaded", async () => {
                try {
                  const walletInfoResponse = await axios.get(
                    "/get-wallet-info"
                  );
                  const walletInfo = walletInfoResponse.data.result;
                  const formattedWalletBalance =
                    walletInfo.balance.toLocaleString(undefined, {
                      minimumFractionDigits: 1,
                      maximumFractionDigits: 1,
                    });
                  document.getElementById(
                    "walletBalance"
                  ).textContent = `${formattedWalletBalance} PSL`;
                } catch (error) {
                  console.error("Error retrieving wallet info:", error);
                  document.getElementById("walletBalance").textContent =
                    "Failed to load balance";
                }
              });
            </script>
          </span>
        </div>
        <button id="createPastelIDButton" class="btn success mt-4 hidden">
          Create a PastelID so you can make inference requests? (Costs 1,000
          PSL)
        </button>
      </div>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Create New Credit Pack Ticket</h2>
      <form id="createTicketForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="numCredits"
            >Number of Credits</label
          >
          <input
            class="input w-full"
            id="numCredits"
            type="text"
            placeholder="Enter number of credits"
            value="1500"
            data-raw-value="1500"
          />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxTotalPrice"
            >Maximum Total Price (PSL)</label
          >
          <input
            class="input w-full"
            id="maxTotalPrice"
            type="text"
            placeholder="Enter maximum total price"
            value="150000"
            data-raw-value="150000"
          />
        </div>
        <div>
          <label
            class="block text-bw-700 font-bold mb-2"
            for="maxPerCreditPrice"
            >Maximum Per Credit Price (PSL)</label
          >
          <input
            class="input w-full"
            id="maxPerCreditPrice"
            type="text"
            placeholder="Enter maximum per credit price"
            value="100.0"
            data-raw-value="100.0"
          />
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button
              class="btn success outline"
              type="submit"
              id="createCreditPackButton"
            >
              Create Credit Pack
            </button>
            <div id="loaderContainer"></div>
            <!-- Add this div for the loader -->
            <div class="prompt success xs" id="createTicketStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="createTicketStatus"
                >Current Status:</label
              >
              <div class="content p-2" id="createTicketStatus"></div>
            </div>
          </div>
        </div>

        <div id="newCreditPackTicketDetailsContainer" style="display: none">
          <h3 class="text-xl text-bw-800">New Credit Pack Ticket Details</h3>
          <div class="table-responsive new-ticket-table">
            <table class="table bordered bw new-ticket-table">
              <thead>
                <tr>
                  <th>Registration TXID</th>
                  <th>SHA3-256 Hash of Credit Pack Purchase Request Fields</th>
                  <th>Responding Supernode PastelID</th>
                  <th>Outcome</th>
                </tr>
              </thead>
              <tbody id="newCreditPackTicketDetails">
                <!-- New ticket details will be dynamically populated here -->
              </tbody>
            </table>
          </div>
        </div>
      </form>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Select Existing Credit Pack Ticket</h2>
      <div class="relative text-bw-700 table-responsive">
        <table class="table bordered bw">
          <thead>
            <tr>
              <th>Select</th>
              <th>Initial Credits in Pack</th>
              <th>Current Credit Balance</th>
              <th>Tracking Address</th>
              <th>Blockheight Registered</th>
              <th>Credit Pack Registration TXID</th>
            </tr>
          </thead>
          <tbody id="creditPackTicketTableBody">
            <!-- Rows will be dynamically populated here -->
          </tbody>
        </table>
        <div class="flex items-center gap-4 mt-4">
          <button id="refreshButton" class="btn success outline p-4 relative">
            Manually Refresh Credit Pack Tickets
            <span
              class="loader hidden absolute inset-0 flex items-center justify-center"
            >
              <div class="is-loading"></div>
            </span>
          </button>
          <div class="btn is-loading hidden" id="loadingMessage">
            Loading...
          </div>
        </div>
      </div>
    </div>

    <div
      class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <h2 class="text-2xl text-bw-800">Create New Inference Request</h2>
      <form id="inferenceRequestForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="inferenceType"
            >Inference Type</label
          >
          <div class="relative text-bw-700">
            <select id="inferenceType" class="select w-full">
              <option value="">Select an inference type</option>
              <option value="text_completion">Text Completion</option>
              <option value="ask_question_about_an_image">
                Ask a Question About an Image
              </option>
              <option value="text_to_image">Image Generation</option>
              <option value="embedding_document">Embedding Document</option>
              <option value="embedding_audio">Embedding Audio</option>
            </select>
          </div>
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="model"
            >Model/Service</label
          >
          <div class="relative text-bw-700">
            <select id="model" class="select w-full">
              <option value="">Select a model/service</option>
              <option value="groq-llama3-70b-8192" selected></option>
              <option value="claude3-opus">Claude3-Opus</option>
            </select>
          </div>
        </div>

        <div id="textCompletionSettings" class="col-span-full">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="prompt"
              >Prompt</label
            >
            <textarea
              class="input w-full"
              id="prompt"
              rows="5"
              placeholder="Enter your prompt"
            >
Write me a Shakespeare-style sonnet about Pastel Network and how it's really decentralized and powerful. </textarea
            >
          </div>
        </div>
        <div id="modelParametersContainer" class="col-span-full"></div>

        <div
          id="imageGenerationSettings"
          class="col-span-full"
          style="display: none"
        >
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imagePrompt"
              >Image Prompt</label
            >
            <textarea
              class="input w-full"
              id="imagePrompt"
              rows="5"
              placeholder="Enter your image prompt"
            >
A picture of a clown holding a sign that says PASTEL</textarea
            >
          </div>
        </div>

        <div
          id="embeddingDocumentSettings"
          class="col-span-full"
          style="display: none"
        >
          <div class="mb-4">
            <label
              class="block text-bw-700 font-bold mb-2"
              for="embeddingDocumentFile"
              >Document to Embed</label
            >
            <input
              type="file"
              class="input w-full"
              id="embeddingDocumentFile"
              accept=".pdf,.doc,.docx,.txt"
            />
          </div>
          <div class="mb-4">
            <label
              class="block text-bw-700 font-bold mb-2"
              for="document_semantic_query_string"
              >Semantic Query String (Optional):</label
            >
            <input
              class="input w-full"
              id="document_semantic_query_string"
              type="text"
              placeholder="Enter your query"
            />
          </div>
        </div>

        <div
          id="embeddingAudioSettings"
          class="col-span-full"
          style="display: none"
        >
          <div class="mb-4">
            <label
              class="block text-bw-700 font-bold mb-2"
              for="embeddingAudioFile"
              >Audio File to Transcribed and Embed</label
            >
            <input
              type="file"
              class="input w-full"
              id="embeddingAudioFile"
              accept="audio/*"
            />
          </div>
          <div class="mb-4">
            <label
              class="block text-bw-700 font-bold mb-2"
              for="audio_semantic_query_string"
              >Semantic Query String (Optional):</label
            >
            <input
              class="input w-full"
              id="audio_semantic_query_string"
              type="text"
              placeholder="Enter your query"
            />
          </div>
        </div>

        <div
          id="askQuestionAboutImageSettings"
          class="col-span-full"
          style="display: none"
        >
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imageFile"
              >Image File</label
            >
            <input
              type="file"
              class="input w-full"
              id="imageFile"
              accept="image/*"
            />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="question"
              >Question</label
            >
            <input
              class="input w-full"
              id="question"
              type="text"
              placeholder="Enter your question"
            />
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-bw-700 font-bold mb-2" for="maxCost"
            >Maximum Cost (Credits)</label
          >
          <input
            class="input w-full"
            id="maxCost"
            type="text"
            placeholder="Enter maximum cost"
            value="200"
            data-raw-value="200"
          />
          <span id="maxCostFormatted" class="text-bw-700"></span>
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button class="btn success outline" type="submit">
              Create Inference Request
            </button>
            <div class="prompt success xs" id="currentStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="currentStatus"
                >Current Status:</label
              >
              <div class="content p-2" id="currentStatus"></div>
            </div>
          </div>
        </div>

        <div id="inferenceRequestResult"></div>
      </form>
    </div>

    <div
      class="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <div class="lg:col-span-1 flex flex-col">
        <h2 class="text-2xl mb-4 text-bw-800">
          View Previous Inference Requests
        </h2>
        <div
          id="previousRequestsList"
          class="bg-gray-100 p-4 rounded-lg overflow-y-auto flex-grow"
          style="max-height: 300px"
        >
          <!-- List of previous inference requests will be dynamically populated here -->
        </div>
        <button
          id="exportRequestsButton"
          class="btn success outline mt-4 flex items-center self-start"
        >
          üíæ Export all Saved Inference Requests
        </button>
      </div>
      <div id="requestPreview" class="lg:col-span-2 bg-gray-50 p-4 rounded-lg">
        <!-- Preview of selected inference request will be shown here -->
      </div>
    </div>

    <div
      class="grid grid-cols-1 lg:grid-cols-2 gap-8 p-4 has-border rounded-xl bg-white shadow-md"
    >
      <div>
        <h2 class="text-2xl mb-4 text-bw-800">
          Send and Receive Messages using PastelIDs
        </h2>
        <form id="sendMessageForm" class="grid grid-cols-1 gap-4">
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="toPastelID"
              >Recipient Pastel ID</label
            >
            <input
              class="input w-full"
              id="toPastelID"
              type="text"
              placeholder="Enter recipient Pastel ID"
              value="jXXiVgtFzLto4eYziePHjjb1hj3c6eXdABej5ndnQ62B8ouv1GYveJaD5QUMfainQM3b4MTieQuzFEmJexw8Cr"
            />
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="messageBody"
              >Message Body</label
            >
            <textarea
              class="input w-full"
              id="messageBody"
              rows="5"
              placeholder="Enter your message"
            >
Hello, this is a brand üçâ NEW test message from a regular user!</textarea
            >
          </div>
          <div class="flex justify-between">
            <button class="btn success outline" type="submit">
              Send Message
            </button>
          </div>
        </form>
      </div>
      <div>
        <h2 class="text-2xl mb-4">Received Messages</h2>
        <div id="receivedMessages" class="bg-bw-50 p-4 rounded-xl">
          <!-- Received messages will be dynamically populated here -->
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl">
      <h2 class="text-2xl">Manage Wallet</h2>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importPrivKey">
          Import Private Key
          <span
            class="tooltip"
            data-tooltip="Import a private key into your wallet."
            >&#9432;</span
          >
        </label>
        <input
          id="importPrivKey"
          class="input w-full"
          type="text"
          placeholder="Enter private key"
        />
        <button id="importPrivKeyButton" class="btn success outline mt-2">
          Import Private Key
        </button>
      </div>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importWallet">
          Import Wallet
          <span
            class="tooltip"
            data-tooltip="Import a wallet file into your wallet."
            >&#9432;</span
          >
        </label>
        <input
          id="importWallet"
          class="input w-full"
          type="file"
          accept=".dat"
        />
        <button id="importWalletButton" class="btn success outline mt-2">
          Import Wallet
        </button>
      </div>
      <label
        class="block text-bw-700 font-bold mb-2"
        for="listAddressAmountsButton"
      >
        Misc Functions:
      </label>

      <div class="mb-4">
        <button id="listAddressAmountsButton" class="btn success outline">
          List Address Amounts
          <span
            class="tooltip"
            data-tooltip="List the amounts associated with each address in your wallet."
          >
            &#9432;
          </span>
        </button>

        <div
          id="addressAmountsContainer"
          class="mt-4"
          style="display: none; position: relative"
        >
          <h2 class="text-2xl text-bw-800">Address Amounts:</h2>
          <button
            id="copyAddressAmountsButton"
            class="btn success outline"
            style="
              position: absolute;
              top: -1.5rem;
              right: 0.5rem;
              display: none;
            "
          >
            üìã
          </button>
          <div class="table-responsive">
            <table id="addressAmountsTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <button id="getWalletInfoButton" class="btn success outline">
          Get Wallet Info
          <span
            class="tooltip"
            data-tooltip="Retrieve information about your wallet."
          >
            &#9432;
          </span>
        </button>

        <div
          id="walletInfoContainer"
          class="mt-4"
          style="display: none; position: relative"
        >
          <h2 class="text-2xl text-bw-800">Wallet Info:</h2>
          <button
            id="copyWalletInfoButton"
            class="btn success outline"
            style="
              position: absolute;
              top: -1.5rem;
              right: 0.5rem;
              display: none;
            "
          >
            üìã
          </button>
          <div class="table-responsive">
            <table id="walletInfoTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <button id="clearLocalStorageButton" class="btn success outline">
          Clear Inference Client Local Storage
          <span
            class="tooltip"
            data-tooltip="Clear all local storage data for this page."
          >
            &#9432;
          </span>
        </button>
      </div>
    </div>
    <button onclick="toggleTerminal()" class="btn success outline">
      Toggle Terminal
    </button>

    <h2 class="text-2xl">Terminal</h2>

    <div id="terminal" class="bg-gray-900 text-white p-4 rounded-xl"></div>
    <div class="flex justify-between items-center">
      <button id="exportTerminalButton" class="btn success outline">
        Export Terminal Session Text
      </button>
    </div>

    <div class="bg-bw-800 text-bw-50 py-6">
      <div class="container mx-auto px-4">
        <p class="text-center">
          &copy; 2023 Pastel Inference Client UI. All rights reserved.
        </p>
      </div>
    </div>

    <script>
      const MESSAGING_TIMEOUT_IN_SECONDS = 60;
      const LOADING_MESSAGE = "Wait while data is loaded...";
      const STORAGE_KEY = "validCreditPackTickets";
      const STORAGE_TIMESTAMP_KEY = "creditPackTicketsTimestamp";
      const REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      function formatNumberWithCommas(number) {
        return number.toLocaleString();
      }

      function parseAndFormatNumber(value) {
        const number = parseFloat(value.replace(/,/g, ""));
        return isNaN(number) ? value : formatNumberWithCommas(number);
      }

      function handleInputChange(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const rawValue = inputElement.value.replace(/,/g, "");
        inputElement.setAttribute("data-raw-value", rawValue);
      }

      function handleInputBlur(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const formattedValue = parseAndFormatNumber(inputElement.value);
        inputElement.value = formattedValue;
      }

      function parseAndFormat(value) {
        try {
          if (typeof value === "string") {
            // Check if the JSON string is already formatted
            if (value.includes("\n")) {
              return value;
            }
            // Parse JSON string to handle it properly
            const parsedValue = JSON.parse(value);
            return JSON.stringify(parsedValue, null, 4); // Indent JSON string
          }
          return JSON.stringify(value, null, 4); // Format other values
        } catch (error) {
          return value; // Return original value if parsing fails
        }
      }

      function prettyJSON(data) {
        if (data instanceof Map) {
          data = Object.fromEntries(data); // Convert Map to object
        }
        if (
          Array.isArray(data) ||
          (typeof data === "object" && data !== null)
        ) {
          const formattedData = {};
          for (const [key, value] of Object.entries(data)) {
            if (typeof value === "string" && key.endsWith("_json")) {
              formattedData[key] = parseAndFormat(value);
            } else if (typeof value === "object" && value !== null) {
              formattedData[key] = prettyJSON(value); // Recurse for nested objects
            } else {
              formattedData[key] = value; // Handle other types
            }
          }
          return JSON.stringify(formattedData, null, 4); // Pretty print the object
        } else if (typeof data === "string") {
          return parseAndFormat(data); // Handle strings separately
        }
        return data; // Return data as is for other types
      }

      function sanitizeJSON(jsonString) {
        return jsonString.replace(/[^\x20-\x7E]+/g, ""); // Remove non-printable ASCII characters
      }

      function fallbackParseResult(result) {
        // If the result starts with {"text": ", strip it and the ending }
        if (result.startsWith(' {"text": "')) {
          result = result.slice(10); // Remove the prefix {"text": "
          const endIndex = result.indexOf('"}');
          if (endIndex !== -1) {
            result = result.slice(0, endIndex); // Remove the closing }
          }
        }

        // Remove anything including and after "} {"prompt":" from the end of the string
        const promptPattern = /"} {"prompt":".*$/;
        result = result.replace(promptPattern, "");

        return result;
      }

      function formatAndHighlightMessage(message) {
        const parts = message.split(/(\{[\s\S]*?\})/);
        return parts
          .map((part) => {
            try {
              if (part.startsWith("{") && part.endsWith("}")) {
                const parsed = JSON.parse(part);
                const formatted = prettyJSON(parsed);
                return `<pre><code class="json">${
                  hljs.highlight(formatted, {
                    language: "json",
                    ignoreIllegals: true,
                  }).value
                }</code></pre>`;
              }
            } catch (e) {
              // If parsing fails, fall through to return the part as plain text
            }
            return `<span>${part}</span>`;
          })
          .join("");
      }

      function logCreateTicketStatusMessage(message, container) {
        if (message.includes("ECONNREFUSED")) return;
        container.innerHTML = ""; // Clear previous log messages
        const logElement = document.createElement("div");
        logElement.style.fontFamily = "Montserrat, sans-serif";
        logElement.innerHTML = formatAndHighlightMessage(message);
        container.appendChild(logElement);
        container.scrollTop = container.scrollHeight; // Scroll to bottom
      }

      function logStatusMessage(message) {
        if (message.includes("ECONNREFUSED")) return;
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.style.fontFamily = "Montserrat, sans-serif";
        currentStatus.style.whiteSpace = "pre-wrap"; // Ensure wrapping
        currentStatus.innerHTML = formatAndHighlightMessage(message);
      }

      function abbreviateJSON(jsonString, maxLength) {
        if (jsonString.length <= maxLength) return jsonString;
        const abbreviated = jsonString.slice(0, maxLength) + "...";
        const openBraces =
          (jsonString.match(/{/g) || []).length -
          (abbreviated.match(/{/g) || []).length;
        const openBrackets =
          (jsonString.match(/\[/g) || []).length -
          (abbreviated.match(/\[/g) || []).length;
        return abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets);
      }

      function logActionWithPayload(action, payloadName, jsonPayload) {
        const maxPayloadLength = 10000;
        let formattedPayload = prettyJSON(jsonPayload);
        if (formattedPayload.length > maxPayloadLength) {
          formattedPayload = abbreviateJSON(formattedPayload, maxPayloadLength);
        }
        logger.info(
          `Now ${action} ${payloadName} with payload:\n${formattedPayload}`
        );
      }

      function togglePastelIDDropdown() {
        const dropdown = document.getElementById("pastelIDDropdown");
        dropdown.classList.toggle("hidden");
      }

      function updatePastelIDSelection() {
        const selectedID = document.getElementById("pastelIDDropdown").value;
        document.getElementById("userPastelID").textContent = selectedID;
        togglePastelIDDropdown(); // Hide dropdown after selection
      }

      async function checkCreditPackTicketInfo(txid) {
        try {
          const response = await axios.get(`/credit-pack-info/${txid}`);
          const { requestResponse, requestConfirmation, balanceInfo } =
            response.data;
          document.getElementById("requestResponse").textContent =
            JSON.stringify(requestResponse, null, 2);
          document.getElementById("requestConfirmation").textContent =
            JSON.stringify(requestConfirmation, null, 2);
          document.getElementById("currentCreditBalance").textContent =
            balanceInfo.current_credit_balance;
          document.getElementById("numberOfTransactions").textContent =
            balanceInfo.number_of_confirmation_transactions;
        } catch (error) {
          console.error("Error checking credit pack ticket info:", error);
          document.getElementById("requestResponse").textContent =
            "Failed to load credit pack info";
          document.getElementById("requestConfirmation").textContent = "";
          document.getElementById("currentCreditBalance").textContent = "";
          document.getElementById("numberOfTransactions").textContent = "";
        }
      }

      function getAddressURL(address) {
        let baseURL = "https://explorer.pastel.network/address/";
        if (address.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/address/";
        } else if (address.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/address/";
        }
        return `${baseURL}${address}`;
      }

      function getTxidURL(trackingAddress, txid) {
        let baseURL = "https://explorer.pastel.network/tx/";
        if (trackingAddress.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/tx/";
        } else if (trackingAddress.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/tx/";
        }
        return `${baseURL}${txid}`;
      }

      async function listPastelIDTickets() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result;
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      async function checkTrackingAddresses() {
        try {
          const response = await fetch("/list-address-amounts");
          if (!response.ok) {
            throw new Error("Failed to fetch address amounts");
          }
          const data = await response.json();
          const walletAddresses = Object.keys(data.result);

          const trackingAddresses =
            document.querySelectorAll(".tracking-address");
          trackingAddresses.forEach((element) => {
            const address = element.textContent.trim();
            if (walletAddresses.includes(address)) {
              element.classList.add("valid-address");
              element.classList.remove("invalid-address");
            } else {
              element.classList.add("invalid-address");
              element.classList.remove("valid-address");
            }
          });
        } catch (error) {
          console.error("Error checking tracking addresses:", error.message);
        }
      }

      async function getMyValidCreditPacks(forceRefresh = false) {
        const loadingMessage = document.getElementById("loadingMessage");
        const tableBody = document.getElementById("creditPackTicketTableBody");
        loadingMessage.style.display = "block";

        try {
          let validCreditPackTickets = [];
          const now = new Date().getTime();

          if (!forceRefresh) {
            const savedData = localStorage.getItem(STORAGE_KEY);
            const savedTimestamp = localStorage.getItem(STORAGE_TIMESTAMP_KEY);

            if (
              savedData &&
              savedTimestamp &&
              now - savedTimestamp < REFRESH_INTERVAL
            ) {
              validCreditPackTickets = JSON.parse(savedData);
            } else {
              const response = await axios.get("/get-my-valid-credit-packs");
              validCreditPackTickets = response.data.result;
              localStorage.setItem(
                STORAGE_KEY,
                JSON.stringify(validCreditPackTickets)
              );
              localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
            }
          } else {
            const response = await axios.get("/get-my-valid-credit-packs");
            validCreditPackTickets = response.data.result;
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify(validCreditPackTickets)
            );
            localStorage.setItem(STORAGE_TIMESTAMP_KEY, now);
          }

          // Fetch wallet addresses
          const walletResponse = await axios.get("/list-address-amounts");
          const walletAddresses = Object.keys(walletResponse.data.result);

          // Filter valid credit pack tickets based on tracking addresses
          validCreditPackTickets = validCreditPackTickets.filter((ticket) =>
            walletAddresses.includes(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address
            )
          );

          tableBody.innerHTML = "";

          // Filter out credit packs with 0 or negative balance
          validCreditPackTickets = validCreditPackTickets.filter(
            (ticket) => ticket.credit_pack_current_credit_balance > 0
          );

          // Find the credit pack with the highest current credit balance
          let highestBalanceTicket = validCreditPackTickets[0];
          for (const ticket of validCreditPackTickets) {
            if (
              ticket.credit_pack_current_credit_balance >
              highestBalanceTicket.credit_pack_current_credit_balance
            ) {
              highestBalanceTicket = ticket;
            }
          }

          for (const ticket of validCreditPackTickets) {
            const row = document.createElement("tr");

            const radioCell = document.createElement("td");
            const radioInput = document.createElement("input");
            radioInput.type = "radio";
            radioInput.name = "creditPackTicket";
            radioInput.value =
              ticket.credit_pack_purchase_request.requesting_end_user_pastelid;
            radioInput.dataset.txid =
              ticket.credit_pack_purchase_request_confirmation.txid_of_credit_purchase_burn_transaction;
            radioCell.appendChild(radioInput);
            row.appendChild(radioCell);

            const initialCreditsCell = document.createElement("td");
            initialCreditsCell.classList.add("truncate");
            initialCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_purchase_request
                .requested_initial_credits_in_credit_pack
            );
            row.appendChild(initialCreditsCell);

            const currentCreditsCell = document.createElement("td");
            currentCreditsCell.classList.add("truncate");
            currentCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_current_credit_balance
            );
            row.appendChild(currentCreditsCell);

            const trackingAddressCell = document.createElement("td");
            trackingAddressCell.classList.add("truncate", "tracking-address");
            const addressLink = document.createElement("a");
            addressLink.href = getAddressURL(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address
            );
            addressLink.target = "_blank";
            addressLink.textContent =
              ticket.credit_pack_purchase_request.credit_usage_tracking_psl_address;
            trackingAddressCell.appendChild(addressLink);
            row.appendChild(trackingAddressCell);

            const blockheightCell = document.createElement("td");
            blockheightCell.classList.add("truncate");
            blockheightCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_purchase_request.request_pastel_block_height
            );
            row.appendChild(blockheightCell);

            const creditPackRegistrationTxidCell = document.createElement("td");
            creditPackRegistrationTxidCell.classList.add("truncate");
            const txLink = document.createElement("a");
            txLink.href = getTxidURL(
              ticket.credit_pack_purchase_request
                .credit_usage_tracking_psl_address,
              ticket.credit_pack_registration_txid
            );
            txLink.target = "_blank";
            txLink.textContent = ticket.credit_pack_registration_txid;
            creditPackRegistrationTxidCell.appendChild(txLink);
            row.appendChild(creditPackRegistrationTxidCell);

            tableBody.appendChild(row);
            if (ticket === highestBalanceTicket) {
              radioInput.checked = true;
              row.classList.add("bg-gray-200", "selected-row");
            }
          }

          handleCreditPackSelection(); // Re-apply event listeners
          if (validCreditPackTickets.length > 0) {
            let highestBalanceTicket = validCreditPackTickets[0];
            for (const ticket of validCreditPackTickets) {
              if (
                ticket.credit_pack_current_credit_balance >
                highestBalanceTicket.credit_pack_current_credit_balance
              ) {
                highestBalanceTicket = ticket;
              }
            }
            const highestBalanceRadioInput = Array.from(
              tableBody.querySelectorAll('input[type="radio"]')
            ).find(
              (input) =>
                input.value ===
                highestBalanceTicket.credit_pack_purchase_request
                  .requesting_end_user_pastelid
            );
            if (highestBalanceRadioInput) {
              highestBalanceRadioInput.checked = true;
              highestBalanceRadioInput.dispatchEvent(new Event("change"));
            }
          }
        } catch (error) {
          console.error("Error retrieving valid credit pack tickets:", error);
        } finally {
          loadingMessage.style.display = "none";
        }
      }

      async function createNewCreditPackTicket(
        numCredits,
        maxTotalPrice,
        maxPerCreditPrice
      ) {
        const statusContainer = document.getElementById(
          "createTicketStatusContainer"
        );
        const statusContent = document.getElementById("createTicketStatus");
        const loaderContainer = document.getElementById("loaderContainer"); // Get the loader container

        if (!statusContainer || !statusContent || !loaderContainer) {
          console.error(
            "Status container, status content, or loader container element not found."
          );
          return;
        }

        statusContent.innerHTML = ""; // Clear previous logs
        loaderContainer.innerHTML = ""; // Clear previous loader if any

        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader); // Append to loader container

        const newTicketDetailsContainer = document.getElementById(
          "newCreditPackTicketDetailsContainer"
        );
        const newTicketDetails = document.getElementById(
          "newCreditPackTicketDetails"
        );

        if (!newTicketDetailsContainer || !newTicketDetails) {
          console.error(
            "New ticket details container or new ticket details element not found."
          );
          return;
        }

        displayCreateTicketLoggerMessages = true;

        try {
          logCreateTicketStatusMessage(
            "Starting the creation of a new credit pack ticket...",
            statusContent
          );

          const desiredNumberOfCredits = numCredits;
          const amountOfPSLForTrackingTransactions = 10.0;
          const creditPriceCushionPercentage = 0.15;

          const estimatedTotalCostInPSLForCreditPackResponse = await axios.post(
            "/estimate-credit-pack-cost",
            {
              desiredNumberOfCredits,
              creditPriceCushionPercentage,
            }
          );

          const estimatedTotalCostInPSLForCreditPack =
            estimatedTotalCostInPSLForCreditPackResponse.data.result;

          if (estimatedTotalCostInPSLForCreditPack === undefined) {
            throw new Error(
              "Failed to estimate total cost for the credit pack"
            );
          }

          const amountToFundCreditTrackingAddress = Math.round(
            amountOfPSLForTrackingTransactions +
              estimatedTotalCostInPSLForCreditPack
          );

          const response = await axios.post("/create-and-fund-new-address", {
            amount: amountToFundCreditTrackingAddress,
          });

          if (!response.data.success) {
            throw new Error(
              "Failed to create and fund new credit tracking address"
            );
          }

          const creditUsageTrackingPSLAddress =
            response.data.result.newCreditTrackingAddress;

          logCreateTicketStatusMessage(
            "Credit tracking address created and funded successfully.",
            statusContent
          );

          const ticketResponse = await axios.post(
            "/create-credit-pack-ticket",
            {
              numCredits,
              creditUsageTrackingPSLAddress,
              maxTotalPrice,
              maxPerCreditPrice,
            }
          );

          if (ticketResponse.data.success) {
            logCreateTicketStatusMessage(
              "Credit pack ticket created successfully.",
              statusContent
            );
            const result = ticketResponse.data.result;
            const formattedResult = prettyJSON(result);
            logCreateTicketStatusMessage(
              `Result: ${formattedResult}`,
              statusContent
            );

            newTicketDetails.innerHTML = `
                      <tr>
                        <td class="truncate">
                          <a href="${getTxidURL(
                            creditUsageTrackingPSLAddress,
                            result.pastel_api_credit_pack_ticket_registration_txid
                          )}" target="_blank">
                            ${
                              result.pastel_api_credit_pack_ticket_registration_txid
                            }
                          </a>
                        </td>
                        <td class="truncate">${
                          result.sha3_256_hash_of_credit_pack_purchase_request_fields
                        }</td>
                        <td class="truncate">${
                          result.responding_supernode_pastelid
                        }</td>
                        <td class="truncate">${
                          result.credit_pack_confirmation_outcome_string
                        }</td>
                      </tr>
                    `;

            newTicketDetailsContainer.style.display = "block";
            document.getElementById("refreshButton").click(); // Simulate click to refresh tickets
            return result;
          } else {
            throw new Error("Failed to create new credit pack ticket");
          }
        } catch (error) {
          console.error(
            `Error creating new credit pack ticket: ${error.message}`
          );
          logCreateTicketStatusMessage(
            "Failed to create credit pack ticket. Please try again.",
            statusContent
          );
          throw error;
        } finally {
          creditPackLoader.remove();
          displayCreateTicketLoggerMessages = false;
        }
      }

      // Handle inference request stuff:
      let modelMenu = null;

      async function fetchModelMenu() {
        try {
          const response = await axios.get("/get-inference-model-menu");
          modelMenu = response.data.modelMenu;
          console.log("Model Menu:", modelMenu); // Debugging line, consider removing for production
          populateModelDropdown();
        } catch (error) {
          console.error("Error fetching model menu:", error);
          displayError("Failed to load model menu. Please try again later.");
        }
      }

      function handleModelChange() {
        const selectedModelName = document.getElementById("model").value;
        const selectedModel = modelMenu.models.find(
          (model) => model.model_name === selectedModelName
        );

        if (selectedModel) {
          generateModelParameterFields(selectedModel);
        }
      }

      function generateModelParameterFields(selectedModel) {
        const modelParametersContainer = document.getElementById(
          "modelParametersContainer"
        );
        modelParametersContainer.innerHTML = "";
        const selectedInferenceType =
          document.getElementById("inferenceType").value;

        // Filter parameters based on the selected inference type
        const applicableParameters = selectedModel.model_parameters.filter(
          (param) =>
            JSON.parse(
              param.inference_types_parameter_applies_to.replace(/'/g, '"')
            ).includes(selectedInferenceType)
        );

        applicableParameters.forEach((param) => {
          const fieldContainer = document.createElement("div");
          fieldContainer.className = "mb-4";

          const label = document.createElement("label");
          label.className = "block text-bw-700 font-bold mb-2";
          label.htmlFor = param.name;
          label.textContent = param.description;
          fieldContainer.appendChild(label);

          const input = document.createElement("input");
          input.className = "input w-full";
          input.id = param.name;
          input.name = param.name;
          input.type =
            param.type === "float" || param.type === "int" ? "number" : "text";
          input.placeholder = `Enter ${param.description.toLowerCase()}`;
          input.value = param.default;

          if (param.name === "number_of_tokens_to_generate") {
            input.min = "1";
            input.max = "5000";
            input.step = "1";
          } else if (param.name === "temperature") {
            input.min = "0";
            input.max = "1";
            input.step = "0.01";
          } else if (param.name === "number_of_completions_to_generate") {
            input.min = "1";
            input.max = "10";
            input.step = "1";
          } else if (
            param.name === "grammar_file_string" ||
            param.name === "query_string" ||
            param.name === "corpus_identifier_string"
          ) {
            input.type = "text"; // Ensure it's a text input
          }

          fieldContainer.appendChild(input);
          modelParametersContainer.appendChild(fieldContainer);
        });
      }

      function populateModelDropdown() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const modelSelect = document.getElementById("model");
        modelSelect.innerHTML =
          '<option value="">Select a model/service</option>';

        if (modelMenu) {
          if (selectedInferenceType === "ask_question_about_an_image") {
            const relevantModels = modelMenu.models.filter((model) =>
              model.supported_inference_type_strings.includes(
                selectedInferenceType
              )
            );

            relevantModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (relevantModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(relevantModels[0]);
            }
          } else {
            const filteredModels = modelMenu.models.filter(
              (model) =>
                model.supported_inference_type_strings &&
                model.supported_inference_type_strings.includes(
                  selectedInferenceType
                )
            );

            filteredModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (filteredModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(filteredModels[0]);
            }
          }
        }
      }

      function displayError(message) {
        // Implement user-friendly error handling/display mechanism
        alert(message); // Simplistic example, consider more sophisticated modal or notification systems
      }

      // Load inference request settings from localStorage
      function loadInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const storedSettings = localStorage.getItem(
          `inferenceRequestSettings_${selectedInferenceType}`
        );
        if (storedSettings) {
          const settings = JSON.parse(storedSettings);
          document.getElementById("model").value = settings.model || "";
          document.getElementById("prompt").value = settings.prompt || "";
          document.getElementById("maxCost").value = settings.maxCost || "";
          document.getElementById("imagePrompt").value =
            settings.imagePrompt || "";
        }
      }

      // Save inference request settings to localStorage
      function saveInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const settings = {
          model: document.getElementById("model").value,
          prompt: document.getElementById("prompt").value,
          maxCost: document.querySelector("#maxCost").dataset.rawValue,
          imagePrompt: document.getElementById("imagePrompt").value,
        };
        localStorage.setItem(
          `inferenceRequestSettings_${selectedInferenceType}`,
          JSON.stringify(settings)
        );
      }

      document.addEventListener("DOMContentLoaded", async () => {
        const noPastelIDContainer = document.getElementById(
          "noPastelIDContainer"
        );
        const createPastelIDForm =
          document.getElementById("createPastelIDForm");
        const importPastelIDButton = document.getElementById(
          "importPastelIDButton"
        );
        const messageContainer = document.getElementById("messageContainer");

        createPastelIDForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const passphrase = document.getElementById(
            "newPastelIDPassphrase"
          ).value;
          if (passphrase.length < 6) {
            displayMessage(
              "Passphrase must be at least 6 characters long.",
              false
            );
            return;
          }
          try {
            displayLoading(true);
            const response = await axios.post(
              "/create-and-register-pastel-id",
              { passphraseForNewPastelID: passphrase }
            );
            displayLoading(false);
            if (response.data.success) {
              displayMessage(
                `Successfully created and registered a new PastelID! Your new PastelID is ${response.data.PastelID}`,
                true
              );
              location.reload(); // Refresh the page to update the UI
            } else {
              displayMessage(response.data.message, false);
            }
          } catch (error) {
            displayLoading(false);
            console.error("Error creating PastelID:", error);
            displayMessage(
              "Failed to create PastelID. Please try again.",
              false
            );
          }
        });

        importPastelIDButton.addEventListener("click", async () => {
          const pastelIDFile =
            document.getElementById("importPastelIDFile").files[0];
          if (!pastelIDFile) {
            displayMessage("Please select a PastelID file to import.", false);
            return;
          }
          const formData = new FormData();
          formData.append("pastelIDFile", pastelIDFile);
          try {
            const { network } = await getNetworkInfo();
            const response = await axios.post(
              `/import-pastel-id?network=${network}`,
              formData
            );
            if (response.data.success) {
              displayMessage("PastelID imported successfully!", true);
              location.reload(); // Refresh the page to update the UI
            } else {
              displayMessage(response.data.message, false);
            }
          } catch (error) {
            console.error("Error importing PastelID:", error);
            displayMessage(
              "Failed to import PastelID. Please try again.",
              false
            );
          }
        });

        function displayLoading(show) {
          const loader = document.getElementById("loaderContainer");
          if (show) {
            loader.innerHTML = '<div class="btn is-loading">Loading...</div>';
          } else {
            loader.innerHTML = "";
          }
        }

        function displayMessage(message, isSuccess) {
          messageContainer.innerHTML = `<p class="${
            isSuccess ? "text-green-600" : "text-red-600"
          }">${message}</p>`;
        }

        async function getNetworkInfo() {
          const response = await axios.get("/get-network-info");
          return response.data;
        }

        // Check if there are any PastelIDs on initial load
        const pastelIDTickets = await listPastelIDTickets();
        if (pastelIDTickets.length === 0) {
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.add("hidden");
          noPastelIDContainer.classList.remove("hidden");
        } else {
          noPastelIDContainer.classList.add("hidden");
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.remove("hidden");
        }
      });

      document.addEventListener("DOMContentLoaded", async () => {
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const passphraseContainer = document.getElementById(
          "passphraseContainer"
        );
        const pastelIDPassphrase =
          document.getElementById("pastelIDPassphrase");
        const rememberPassphrase =
          document.getElementById("rememberPassphrase");
        const submitPassphraseButton = document.getElementById(
          "submitPassphraseButton"
        );
        const refreshButton = document.getElementById("refreshButton");

        pastelIDDropdown.addEventListener("change", () => {
          const selectedPastelID = pastelIDDropdown.value;
          if (selectedPastelID) {
            const storedPassphrase = localStorage.getItem(selectedPastelID);
            if (storedPassphrase) {
              pastelIDPassphrase.value = atob(storedPassphrase);
              passphraseContainer.classList.add("hidden");
            } else {
              passphraseContainer.classList.remove("hidden");
            }
          } else {
            passphraseContainer.classList.add("hidden");
          }
          refreshCreditPackTickets();
        });

        submitPassphraseButton.addEventListener("click", async () => {
          const selectedPastelID = pastelIDDropdown.value;
          const passphrase = pastelIDPassphrase.value;

          if (rememberPassphrase.checked) {
            const encryptedPassphrase = btoa(passphrase); // Simple base64 encoding
            localStorage.setItem(selectedPastelID, encryptedPassphrase);
          }

          try {
            const response = await axios.post("/set-pastel-id-passphrase", {
              pastelID: selectedPastelID,
              passphrase: passphrase,
            });

            if (response.data.success) {
              document.getElementById("messageContainer").innerText =
                "Successfully set PastelID and passphrase!";
            } else {
              document.getElementById("messageContainer").innerText =
                "Failed to set PastelID and passphrase.";
            }
          } catch (error) {
            console.error("Error setting PastelID and passphrase:", error);
            document.getElementById("messageContainer").innerText =
              "Failed to set PastelID and passphrase.";
          }
        });

        const pastelIDTickets = await listPastelIDTickets();
        if (pastelIDTickets.length === 0) {
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.add("hidden");
          noPastelIDContainer.classList.remove("hidden");
        } else {
          noPastelIDContainer.classList.add("hidden");
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.remove("hidden");
          pastelIDTickets.forEach((ticket) => {
            const option = document.createElement("option");
            option.value = ticket.ticket.pastelID;
            option.textContent = ticket.ticket.pastelID;
            pastelIDDropdown.appendChild(option);
          });
        }
      });

      async function refreshCreditPackTickets() {
        const refreshButton = document.getElementById("refreshButton");
        const loader = refreshButton.querySelector(".loader");
        const loadingMessage = document.getElementById("loadingMessage");

        loader.classList.remove("hidden");
        loadingMessage.classList.remove("hidden");

        await getMyValidCreditPacks(true);

        loader.classList.add("hidden");
        loadingMessage.classList.add("hidden");
      }

      // Add event listener for the refresh button
      document
        .getElementById("refreshButton")
        .addEventListener("click", refreshCreditPackTickets);

      // Fetch the model menu when the page loads
      fetchModelMenu();

      // Handle inference type change
      const inferenceTypeSelect = document.getElementById("inferenceType");
      const textCompletionSettings = document.getElementById(
        "textCompletionSettings"
      );
      const imageGenerationSettings = document.getElementById(
        "imageGenerationSettings"
      );

      inferenceTypeSelect.addEventListener("change", () => {
        const selectedInferenceType =
          document.getElementById("inferenceType").value;
        const textCompletionSettings = document.getElementById(
          "textCompletionSettings"
        );
        const imageGenerationSettings = document.getElementById(
          "imageGenerationSettings"
        );
        const embeddingDocumentSettings = document.getElementById(
          "embeddingDocumentSettings"
        );
        const embeddingAudioSettings = document.getElementById(
          "embeddingAudioSettings"
        );
        const askQuestionAboutImageSettings = document.getElementById(
          "askQuestionAboutImageSettings"
        );

        textCompletionSettings.style.display = "none";
        imageGenerationSettings.style.display = "none";
        embeddingDocumentSettings.style.display = "none";
        embeddingAudioSettings.style.display = "none";
        askQuestionAboutImageSettings.style.display = "none";

        if (selectedInferenceType === "text_completion") {
          textCompletionSettings.style.display = "block";
        } else if (selectedInferenceType === "text_to_image") {
          imageGenerationSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_document") {
          embeddingDocumentSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_audio") {
          embeddingAudioSettings.style.display = "block";
        } else if (selectedInferenceType === "ask_question_about_an_image") {
          askQuestionAboutImageSettings.style.display = "block";
        }
        // Update the model dropdown and parameter fields
        populateModelDropdown();
        loadInferenceRequestSettings();
      });

      document
        .getElementById("model")
        .addEventListener("change", handleModelChange);

      function handleCreditPackSelection() {
        const radioButtons = document.querySelectorAll(
          'input[name="creditPackTicket"]'
        );
        radioButtons.forEach((button) => {
          button.addEventListener("change", () => {
            document
              .querySelectorAll("#creditPackTicketTableBody tr")
              .forEach((row) => {
                row.classList.remove("bg-gray-200", "selected-row");
              });
            button.parentElement.parentElement.classList.add(
              "bg-gray-200",
              "selected-row"
            );
          });
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        handleCreditPackSelection();
      });

      let displayInferenceRequestLoggerMessages = false;
      let displayCreateTicketLoggerMessages = false;

      async function saveInferenceRequestToLocalStorage(requestData) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];

        if (
          requestData.selectedInferenceType === "ask_question_about_an_image"
        ) {
          try {
            const imageFile = document.getElementById("imageFile").files[0];
            const compressedImage = await compressImage(imageFile);
            requestData.inputFields.image = compressedImage;
          } catch (error) {
            console.error("Error compressing image:", error);
            // Handle the error gracefully, e.g., show an error message to the user
            // and continue with the original image or take appropriate action
          }
        } else if (
          requestData.selectedInferenceType === "embedding_document" ||
          requestData.selectedInferenceType === "embedding_audio"
        ) {
          const fileHash = sha3_256(
            requestData.inputFields.document || requestData.inputFields.audio
          );
          requestData.inputFields.fileHash = fileHash;
          delete requestData.inputFields.document;
          delete requestData.inputFields.audio;
        } else if (requestData.selectedInferenceType === "text_to_image") {
          const generatedImage = document.getElementById("generated-image");
          const compressedImage = await compressGeneratedImage(generatedImage);
          requestData.inferenceResultsDecoded = compressedImage;
        }

        requests.push(requestData);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      // Helper function to convert a base64 data URL to a Blob
      function dataURLToBlob(dataURL) {
        const [header, base64] = dataURL.split(",");
        const mime = header.match(/:(.*?);/)[1];
        const binary = atob(base64);
        const array = [];
        for (let i = 0; i < binary.length; i++) {
          array.push(binary.charCodeAt(i));
        }
        return new Blob([new Uint8Array(array)], { type: mime });
      }

      async function compressGeneratedImage(imgElement) {
        try {
          const options = {
            maxSizeMB: 0.05,
            maxWidthOrHeight: 600,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          };
          const response = await fetch(imgElement.src);
          const blob = await response.blob();
          const compressedFile = await imageCompression(blob, options);
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = (error) => {
              console.error("Reader error:", error);
              reject(error);
            };
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          console.error("Compression error:", error);
          throw error;
        }
      }
      async function compressImage(imageBlob) {
        try {
          const compressedFile = await imageCompression(imageBlob, {
            maxSizeMB: 0.03,
            maxWidthOrHeight: 500,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          });
          const reader = new FileReader();
          return new Promise((resolve, reject) => {
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          throw error;
        }
      }

      function updatePreviousRequestsList() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const listContainer = document.getElementById("previousRequestsList");
        listContainer.innerHTML = "";

        if (requests.length === 0) {
          const noRequestsMessage = document.createElement("p");
          noRequestsMessage.className = "text-gray-500";
          noRequestsMessage.textContent =
            "No saved inference requests to display. Create new ones and they will display here when they finish successfully.";
          listContainer.appendChild(noRequestsMessage);
        } else {
          requests.forEach((request, index) => {
            const inferenceTypeIcon =
              request.selectedInferenceType === "text_completion"
                ? "üñπ"
                : request.selectedInferenceType === "text_to_image"
                ? "üñºÔ∏è"
                : request.selectedInferenceType ===
                  "ask_question_about_an_image"
                ? "üñ∫"
                : "üî¢";
            const listItem = document.createElement("div");
            listItem.className =
              "mb-2 p-2 bg-white rounded-lg flex justify-between items-center cursor-pointer";
            const previewText =
              request.selectedInferenceType === "ask_question_about_an_image"
                ? request.inputFields.question
                : request.prompt;
            const promptPreview =
              request.selectedInferenceType === "text_to_image"
                ? request.inputFields.imagePrompt.substring(0, 40)
                : previewText
                ? previewText.substring(0, 40)
                : "No prompt available";
            listItem.innerHTML = `<span>${inferenceTypeIcon} ${promptPreview}...</span>
                        <button class="delete-btn" title="Delete entry?" onclick="deleteRequest(${index})">‚ùå</button>`;

            listItem.addEventListener("click", () =>
              displayRequestPreview(index)
            );
            listContainer.appendChild(listItem);
          });
        }
      }

      function deleteRequest(index) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        requests.splice(index, 1);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      function exportRequests() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        if (requests.length === 0) {
          alert("No saved inference requests to export.");
          return;
        }

        let markdownContent = "# Saved Inference Requests\n\n";
        requests.forEach((request, index) => {
          markdownContent += `## Inference Request ${index + 1}\n`;
          markdownContent += `**Prompt**: ${
            request.selectedInferenceType === "ask_question_about_an_image"
              ? request.inputFields.question
              : request.prompt
          }\n\n`;
          markdownContent += `**Inference Results**:\n\n`;

          if (request.selectedInferenceType === "text_to_image") {
            markdownContent += `![Generated Image](${request.compressedImage})\n\n`;
          } else {
            request.inferenceResultsDecoded.forEach((result, i) => {
              markdownContent += `### Completion ${i + 1}\n`;
              markdownContent += `\`\`\`\n${result}\n\`\`\`\n\n`;
            });
          }
          markdownContent += `**Model**: ${request.selectedModelCanonicalName}\n`;
          markdownContent += `**Actual Cost (Credits)**: ${request.actualCreditsUsed}\n`;
          markdownContent += `**Remaining Credits**: ${request.remainingCredits}\n`;
          markdownContent += `**Misc. Inference Parameters and Statistics**:\n`;
          markdownContent += `| Parameter | Value |\n`;
          markdownContent += `| --- | --- |\n`;
          markdownContent += `| Input Prompt to LLM | ${
            request.selectedInferenceType === "ask_question_about_an_image"
              ? request.inputFields.question
              : request.prompt
          } |\n`;
          markdownContent += `| Actual Cost (Credits) | ${request.actualCreditsUsed} |\n`;
          markdownContent += `| Remaining Credits | ${request.remainingCredits} |\n`;
          markdownContent += `| Model | ${request.selectedModelCanonicalName} |\n`;
          markdownContent += `| Request Timestamp | ${request.requestTimestamp} |\n`;
          markdownContent += `| Total Time (Seconds) | ${request.elapsedTimeInSeconds} |\n`;
          markdownContent += `\n\n`;
        });

        const blob = new Blob([markdownContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "inference_requests.md";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      document
        .getElementById("exportRequestsButton")
        .addEventListener("click", exportRequests);

      updatePreviousRequestsList();

      function displayRequestPreview(index) {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const request = requests[index];
        const previewContainer = document.getElementById("requestPreview");

        let combinedResults = "";
        if (request.selectedInferenceType === "text_completion") {
          const results = Array.isArray(request.inferenceResultsDecoded)
            ? request.inferenceResultsDecoded
            : [request.inferenceResultsDecoded];
          results.forEach((result, i) => {
            let parsedResult = result;
            try {
              const sanitizedResult = sanitizeJSON(result);
              const parsedJSON = JSON.parse(sanitizedResult);
              if (parsedJSON.text) {
                parsedResult = parsedJSON.text;
              }
            } catch (e) {
              parsedResult = fallbackParseResult(result);
            }
            combinedResults += `<h4>Completion ${i + 1} of ${
              results.length
            }</h4>`;
            combinedResults += `<github-md>${parsedResult}</github-md>`;
            if (i < results.length - 1) {
              combinedResults += "<hr>";
            }
          });
        } else if (
          request.selectedInferenceType === "ask_question_about_an_image"
        ) {
          combinedResults = `
            <img src="${request.inputFields.image}" alt="Input Image" style="max-width: 100%; max-height: 400px;">
            <p>Question: ${request.inputFields.question}</p>
            <p>Answer: ${request.inferenceResultsDecoded[0]}</p>
          `;
        } else if (
          request.selectedInferenceType === "embedding_document" ||
          request.selectedInferenceType === "embedding_audio"
        ) {
          combinedResults = `
                    <p>File SHA3-256 Hash: ${request.inputFields.fileHash}</p>
                    <p>Semantic Query String: ${
                      request.inputFields.question
                    }</p>
                    <pre class="json-preview">${getShortPreview(
                      request.inferenceResultsDecoded.decompressedJson
                    )}</pre>
                  `;
        } else if (request.selectedInferenceType === "text_to_image") {
          combinedResults = `
          <img src="${request.inferenceResultsDecoded}" alt="Generated Image" style="max-width: 100%; max-height: 400px;">
          <p>Please note that this is a compressed version of the original generated image.</p>
        `;
        }

        previewContainer.innerHTML = `
                  <div class="mb-4">
                      <h3 class="font-bold">Inference Result:</h3>
                      ${combinedResults}
                  </div>
                  <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
      <div class="table-responsive">
        <table class="table">
          <tr>
            <th>
              ${
                request.selectedInferenceType === "ask_question_about_an_image"
                  ? "Question"
                  : "Input Prompt to LLM"
              }
            </th>
            <td>
              ${
                request.selectedInferenceType === "ask_question_about_an_image"
                  ? request.inputFields.question
                  : request.prompt
              }
            </td>
          </tr>
          <tr><th>Actual Cost (Credits)</th><td>${
            request.actualCreditsUsed
          }</td></tr>
          <tr><th>Remaining Credits</th><td>${
            request.remainingCredits
          }</td></tr>
          <tr><th>Request Timestamp</th><td>${
            request.requestTimestamp
          }</td></tr>
          <tr><th>Model</th><td>${request.selectedModelCanonicalName}</td></tr>
          <tr><th>Total Time in Seconds to Process Request</th><td>${
            request.elapsedTimeInSeconds
          }</td></tr>
        </table>
      </div>`;

        if (request.selectedInferenceType === "text_completion") {
          renderMarkdown();
        }
      }

      function getShortPreview(jsonData) {
        const lines = jsonData.split("\n");
        return lines.slice(0, 300).join("\n");
      }

      function downloadZip(zipUrl) {
        const link = document.createElement("a");
        link.href = zipUrl;
        link.download = "inference_result.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Call updatePreviousRequestsList on page load
      document.addEventListener("DOMContentLoaded", updatePreviousRequestsList);

      async function createNewInferenceRequest(
        selectedCreditPackTicketId,
        selectedInferenceType,
        selectedModelCanonicalName,
        maxCost,
        modelParametersJSONBase64Encoded,
        modelInputDataJSONBase64Encoded
      ) {
        const resultContainer = document.getElementById(
          "inferenceRequestResult"
        );
        resultContainer.innerHTML = "";
        const loader = document.createElement("div");
        loader.className = "btn is-loading";
        loader.innerText = "Loading...";
        resultContainer.appendChild(loader);

        displayInferenceRequestLoggerMessages = true;
        const startTime = new Date();

        try {
          logStatusMessage("Creating new inference request...");

          if (!modelInputDataJSONBase64Encoded) {
            throw new Error(
              "Model input data is required and cannot be empty."
            );
          }

          const requestPayload = {
            model_inference_type_string: selectedInferenceType,
            model_parameters_json_b64: modelParametersJSONBase64Encoded,
            model_input_data_json_b64: modelInputDataJSONBase64Encoded,
            selectedCreditPackTicketId,
            maxCost,
            model_canonical_name: selectedModelCanonicalName,
          };

          const response = await axios.post(
            "/create-inference-request",
            requestPayload
          );

          if (response.data.success) {
            logStatusMessage("Inference request created successfully.");
            const contentType = response.headers["content-type"];

            const inferenceResultDict =
              response.data.result.inferenceResultDict;

            let combinedResults = "";
            const modelInputDataJSON =
              inferenceResultDict.model_input_data_json;
            const {
              proposed_cost_of_request_in_inference_credits,
              remaining_credits_in_pack_after_request_processed,
            } = inferenceResultDict.usage_request_response;

            const endTime = new Date();
            const elapsedTimeInSeconds = Math.floor(
              (endTime - startTime) / 1000
            );
            let compressedImage;
            if (selectedInferenceType === "text_to_image") {
              const imageBinaryData =
                inferenceResultDict.generated_image_decoded.data;
              if (imageBinaryData) {
                // Convert the binary data to a Blob
                const outputFormat =
                  document
                    .getElementById("output_format")
                    .value.replace("jpeg", "jpg") || "jpg";
                const imageBlob = new Blob([new Uint8Array(imageBinaryData)], {
                  type: `image/${outputFormat}`,
                });
                // Create an object URL for the image
                const imageUrl = URL.createObjectURL(imageBlob);
                // Generate the image name
                const imageName = modelInputDataJSON.imagePrompt.replace(
                  /\s+/g,
                  "_"
                );
                // Create the combined results HTML
                combinedResults = `
                <img id="generated-image" src="${imageUrl}" alt="Generated Image" style="max-width: 100%; max-height: 400px;">
                <p>
                  <a href="${imageUrl}" download="${imageName}.${outputFormat}" class="btn success outline m-4">Download Image</a>
                </p>
              `;
              } else {
                combinedResults = "Failed to generate image.";
              }
            } else if (
              selectedInferenceType === "ask_question_about_an_image"
            ) {
              combinedResults = `
                <img src="${modelInputDataJSON.image}" alt="Input Image" style="max-width: 100%; max-height: 400px;">
                <p>Question: ${modelInputDataJSON.question}</p>
                <p>Answer: ${inferenceResultDict.inference_result_decoded[0]}</p>
              `;
            } else if (selectedInferenceType === "text_completion") {
              const inferenceResultsDecoded =
                inferenceResultDict.inference_result_decoded;
              if (Array.isArray(inferenceResultsDecoded)) {
                inferenceResultsDecoded.forEach((result, i) => {
                  let parsedResult = result;
                  try {
                    const sanitizedResult = sanitizeJSON(result);
                    const parsedJSON = JSON.parse(sanitizedResult);
                    if (parsedJSON.text) {
                      parsedResult = parsedJSON.text;
                    }
                  } catch (e) {
                    try {
                      parsedResult = fallbackParseResult(result);
                    } catch (e) {
                      parsedResult = result;
                    }
                  }
                  combinedResults += `<h4>Completion ${i + 1} of ${
                    inferenceResultsDecoded.length
                  }</h4>`;
                  combinedResults += `<github-md>${parsedResult}</github-md>`;
                  if (i < inferenceResultsDecoded.length - 1) {
                    combinedResults += "<hr>";
                  }
                });
              } else {
                combinedResults = `<github-md>${inferenceResultsDecoded}</github-md>`;
              }
            }

            resultContainer.innerHTML = `
              <div class="mb-4">
                <h3 class="font-bold">Inference Result:</h3>
                ${combinedResults}
              </div>
              <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
              <div class="table-responsive">
                <table class="table">
                  <tr>
                    <th>${
                      selectedInferenceType === "embedding"
                        ? "Text to Embed"
                        : "Input Prompt to LLM"
                    }</th>
                    <td>${
                      selectedInferenceType === "embedding"
                        ? JSON.parse(atob(modelInputDataJSONBase64Encoded))[
                            "embeddingText"
                          ]
                        : modelInputDataJSON
                    }</td>
                  </tr>
                  <tr><th>Actual Cost (Credits)</th><td>${proposed_cost_of_request_in_inference_credits}</td></tr>
                  <tr><th>Remaining Credits</th><td>${remaining_credits_in_pack_after_request_processed}</td></tr>
                  <tr><th>Request Timestamp</th><td>${new Date().toISOString()}</td></tr>
                  <tr><th>Model</th><td>${selectedModelCanonicalName}</td></tr>
                  <tr><th>Total Time in Seconds to Process Request</th><td>${elapsedTimeInSeconds}</td></tr>
                </table>
              </div>
            `;

            saveInferenceRequestToLocalStorage({
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              inputFields: JSON.parse(atob(modelInputDataJSONBase64Encoded)),
              parameterFields: JSON.parse(
                atob(modelParametersJSONBase64Encoded)
              ),
              maxCost,
              inferenceResultsDecoded:
                inferenceResultDict.inference_result_decoded,
              prompt: document.getElementById("prompt").value,
              elapsedTimeInSeconds,
              actualCreditsUsed: proposed_cost_of_request_in_inference_credits,
              remainingCredits:
                remaining_credits_in_pack_after_request_processed,
              respondingSupernode:
                inferenceResultDict.responding_supernode_pastelid,
              requestTimestamp: startTime.toISOString(),
            });

            if (selectedInferenceType === "text_completion") {
              renderMarkdown();
            }
          } else {
            throw new Error("Failed to create inference request");
          }
        } catch (error) {
          console.error(
            `Error creating new inference request: ${error.message}`
          );
          resultContainer.innerHTML =
            "Failed to create inference request. Please try again.";
          logStatusMessage("Failed to create inference request.");
        } finally {
          loader.remove();
          displayInferenceRequestLoggerMessages = false;
        }
      }

      async function decompressJsonFromZip(zipUrl) {
        const response = await fetch(zipUrl);
        const blob = await response.blob();
        const jsZip = new JSZip();
        const zip = await jsZip.loadAsync(blob);
        const fileNames = Object.keys(zip.files);
        const jsonFile = await zip.files[fileNames[0]].async("text");
        return jsonFile;
      }

      // Function to fetch and display received messages
      async function fetchReceivedMessages() {
        try {
          const userPastelID =
            document.getElementById("pastelIDDropdown").value;

          const response = await axios.get("/get-best-supernode-url", {
            params: { userPastelID },
          });
          const supernodeURL = response.data.supernodeURL;
          const closestSupernodeIP = supernodeURL.match(
            /(?:https?:\/\/)?([^:/]+)/i
          )[1];

          const messagesResponse = await axios.get("/get-received-messages", {
            timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
          });
          const messageDict = messagesResponse.data.messageDict;

          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML = ""; // Clear previous messages

          for (const pastelId in messageDict) {
            const messages = messageDict[pastelId];
            messages.forEach((message) => {
              const messageElement = document.createElement("div");
              messageElement.classList.add(
                "mb-4",
                "border",
                "border-gray-300",
                "rounded-lg",
                "p-4"
              );

              const fromPastelIDElement = document.createElement("p");
              fromPastelIDElement.classList.add(
                "text-sm",
                "font-medium",
                "text-gray-600",
                "mb-2"
              );
              fromPastelIDElement.textContent = `From: ${pastelId}`;

              const messageBodyElement = document.createElement("p");
              messageBodyElement.classList.add(
                "text-base",
                "text-gray-800",
                "mb-2"
              );
              messageBodyElement.textContent = message.message_body;

              const timestampElement = document.createElement("p");
              timestampElement.classList.add("text-xs", "text-gray-500");
              timestampElement.textContent = new Date(
                message.timestamp
              ).toLocaleString();

              messageElement.appendChild(fromPastelIDElement);
              messageElement.appendChild(messageBodyElement);
              messageElement.appendChild(timestampElement);

              receivedMessagesContainer.appendChild(messageElement);
            });
          }
        } catch (error) {
          console.error("Error retrieving received messages:", error);
          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML =
            "Failed to retrieve received messages. Please try again later.";
        }
      }

      // Fetch received messages when the page loads
      window.addEventListener("DOMContentLoaded", fetchReceivedMessages);

      window.addEventListener("DOMContentLoaded", async () => {
        const pastelIDElement = document.getElementById("userPastelID");
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const pastelIDDropdownContainer = document.getElementById(
          "pastelIDDropdownContainer"
        );
        const createPastelIDButton = document.getElementById(
          "createPastelIDButton"
        );
        const changePastelIDButton = document.getElementById(
          "changePastelIDButton"
        );

        await getMyValidCreditPacks();
        if (!localStorage.getItem(STORAGE_KEY)) {
          await getMyValidCreditPacks();
        }

        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          const pastelIDTickets = response.data.result;

          // Clear existing options
          pastelIDDropdown.innerHTML = "";

          if (pastelIDTickets.length > 0) {
            pastelIDTickets.forEach((ticket, index) => {
              const option = document.createElement("option");
              option.value = ticket.ticket.pastelID;
              option.textContent = ticket.ticket.pastelID;
              pastelIDDropdown.appendChild(option);
              if (index === 0) {
                pastelIDElement.textContent = ticket.ticket.pastelID; // Display the first PastelID by default
              }
            });
            // Only show the change button and dropdown if there are multiple PastelIDs
            if (pastelIDTickets.length > 1) {
              changePastelIDButton.classList.remove("hidden");
              pastelIDDropdownContainer.classList.remove("hidden");
            } else {
              changePastelIDButton.classList.add("hidden");
              pastelIDDropdownContainer.classList.add("hidden");
            }
          } else {
            pastelIDElement.textContent = "No PastelID found";
            createPastelIDButton.style.display = "block"; // Show create button if no IDs
          }
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          pastelIDElement.textContent = "Failed to load PastelIDs";
        }
      });

      // Handle create PastelID button click
      document
        .getElementById("createPastelIDButton")
        .addEventListener("click", async () => {
          try {
            await axios.post("/check-for-pastel-id", { autoRegister: true });
            location.reload(); // Refresh the page to update the UI
          } catch (error) {
            console.error("Error creating PastelID:", error);
          }
        });

      // Handle import private key form submission
      document
        .getElementById("importPrivKeyButton")
        .addEventListener("click", async () => {
          const privKey = document.getElementById("importPrivKey").value;
          try {
            await axios.post("/import-priv-key", { zcashPrivKey: privKey });
            alert("Private key imported successfully!");
          } catch (error) {
            console.error("Error importing private key:", error);
          }
        });

      // Handle import wallet form submission
      document
        .getElementById("importWalletButton")
        .addEventListener("click", async () => {
          const walletFile = document.getElementById("importWallet").files[0];
          const formData = new FormData();
          formData.append("walletFile", walletFile);
          try {
            await axios.post("/import-wallet", formData);
            alert("Wallet imported successfully!");
          } catch (error) {
            console.error("Error importing wallet:", error);
          }
        });

      // Handle list address amounts button click
      document
        .getElementById("listAddressAmountsButton")
        .addEventListener("click", async () => {
          try {
            const response = await axios.get("/list-address-amounts");
            const addressAmounts = response.data.result;
            console.log("Address amounts:", addressAmounts);

            // Populate the table
            const addressAmountsTable = document.getElementById(
              "addressAmountsTable"
            );
            addressAmountsTable.innerHTML =
              "<thead><tr><th>Address</th><th>Amount</th></tr></thead><tbody></tbody>";
            const tbody = addressAmountsTable.querySelector("tbody");
            for (const [address, amount] of Object.entries(addressAmounts)) {
              const row = document.createElement("tr");
              row.innerHTML = `<td>${address}</td><td>${parseAndFormatNumber(
                amount.toString()
              )}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const addressAmountsContainer = document.getElementById(
              "addressAmountsContainer"
            );
            addressAmountsContainer.style.display = "block";
            document.getElementById("copyAddressAmountsButton").style.display =
              "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyAddressAmountsButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(addressAmounts)
                  .map(
                    ([address, amount]) =>
                      `${address},${amount.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Address amounts copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving address amounts:", error);
          }
        });
      // Handle get wallet info button click
      document
        .getElementById("getWalletInfoButton")
        .addEventListener("click", async () => {
          try {
            const response = await axios.get("/get-wallet-info");
            const walletInfo = response.data.result;
            console.log("Wallet info:", walletInfo);

            // Populate the table
            const walletInfoTable = document.getElementById("walletInfoTable");
            walletInfoTable.innerHTML =
              "<thead><tr><th>Key</th><th>Value</th></thead><tbody></tbody>";
            const tbody = walletInfoTable.querySelector("tbody");
            const balanceFields = [
              "balance",
              "unconfirmed_balance",
              "immature_balance",
            ]; // Add the balance fields you want to format

            for (const [key, value] of Object.entries(walletInfo)) {
              const formattedValue = balanceFields.includes(key)
                ? parseAndFormatNumber(value.toString())
                : value;
              const row = document.createElement("tr");
              row.innerHTML = `<td>${key}</td><td>${formattedValue}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const walletInfoContainer = document.getElementById(
              "walletInfoContainer"
            );
            walletInfoContainer.style.display = "block";
            document.getElementById("copyWalletInfoButton").style.display =
              "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyWalletInfoButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(walletInfo)
                  .map(
                    ([key, value]) =>
                      `${key},${value.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Wallet info copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving wallet info:", error);
          }
        });

      document
        .getElementById("clearLocalStorageButton")
        .addEventListener("click", () => {
          if (
            confirm(
              "Are you sure you want to clear all local storage data for this page?"
            )
          ) {
            localStorage.clear();
            alert("Local storage cleared. The page will now reload.");
            location.reload();
          }
        });

      // Create a terminal and load the fit addon
      const term = new Terminal({ cols: 175, rows: 24 });
      term.open(document.getElementById("terminal"));
      term.terminalOptions = {
        fontSize: 6,
        enableBold: true,
        cols: 175,
        rows: 24,
      };

      function resizeTerminal() {
        const terminalElement = document.getElementById("terminal");
        const cols = Math.floor(terminalElement.clientWidth / 10); // Approximate character width
        const rows = Math.floor(terminalElement.clientHeight / 20); // Approximate character height

        console.log(
          `Cols: ${cols}, Rows: ${rows}, Type of Cols: ${typeof cols}, Type of Rows: ${typeof rows}`
        );

        if (cols > 0 && rows > 0) {
          term.resize(cols, rows);
        }
      }

      resizeTerminal();
      window.addEventListener("resize", resizeTerminal);

      function displayStatusMessage(message) {
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.textContent = message;
      }

      function cleanAndFormatMessage(message) {
        if (typeof message === "object") {
          // If the message is a JSON object, stringify and format it
          return JSON.stringify(message, null, 2);
        } else if (typeof message === "string") {
          // Remove excess whitespace from strings
          return message.replace(/\s+/g, " ").trim();
        }
        return message;
      }

      function logMessageToTerminal(term, logMessage) {
        const cleanMessage = cleanAndFormatMessage(logMessage.message);
        const parts = cleanMessage.split(/(\{[\s\S]*?\})/);
        const formattedParts = parts
          .map((part) => {
            try {
              if (part.startsWith("{") && part.endsWith("}")) {
                const parsed = JSON.parse(part);
                const formatted = prettyJSON(parsed);
                const colored = formatted
                  .replace(/({|})/g, "\x1b[1;32m$1\x1b[0m") // Light green for braces
                  .replace(/"([^"]+)"(?=:)/g, '\x1b[1;34m"$1"\x1b[0m') // Pale blue for keys
                  .replace(/: ("[^"]+")/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for string values
                  .replace(/: (\d+)/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for numeric values
                  .replace(/: (true|false|null)/g, ": \x1b[1;33m$1\x1b[0m"); // Pale yellow for boolean and null values
                return `\n${colored}\n`;
              }
            } catch (e) {
              // If parsing fails, fall through to return the part as plain text
            }
            return part;
          })
          .join("");

        const timestamp = new Date(logMessage.timestamp).toISOString();
        const logLevel = logMessage.level;
        const messageLines =
          `[${timestamp}] [${logLevel}] ${formattedParts}`.split("\n");
        messageLines.forEach((line) => term.writeln(line));
      }

      fetch("/ws-url")
        .then((response) => response.json())
        .then((data) => {
          const socket = new WebSocket(data.wsUrl);

          socket.onopen = () => {
            console.log("WebSocket connection established");
          };

          socket.onmessage = (event) => {
            const logMessage = JSON.parse(event.data);
            logMessageToTerminal(term, logMessage);

            if (displayInferenceRequestLoggerMessages) {
              logStatusMessage(logMessage.message);
            }

            if (displayCreateTicketLoggerMessages) {
              const statusContainer = document.getElementById(
                "createTicketStatusContainer"
              );
              const statusContent =
                document.getElementById("createTicketStatus");
              logCreateTicketStatusMessage(logMessage.message, statusContent);
            }
          };

          socket.onclose = () => {
            console.log("WebSocket connection closed");
          };

          socket.onerror = (error) => {
            console.error("WebSocket error:", error);
          };
        })
        .catch((error) => {
          console.error("Error fetching WebSocket URL:", error);
        });

      function toggleTerminal() {
        const terminal = document.getElementById("terminal");
        if (terminal.style.display === "none") {
          terminal.style.display = "block";
        } else {
          terminal.style.display = "none";
        }
        resizeTerminal();
      }

      tailwind.config = {
        theme: {
          extend: {},
        },
      };

      var storedTheme =
        localStorage.getItem("theme") ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light");
      if (storedTheme)
        document.documentElement.setAttribute("data-theme", storedTheme);

      function toggleDarkMode() {
        var currentTheme = document.documentElement.getAttribute("data-theme");
        var targetTheme = currentTheme === "light" ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", targetTheme);
        localStorage.setItem("theme", targetTheme);
        document
          .querySelector("#theme-toggle")
          .setAttribute("data-content", targetTheme === "dark" ? "üåô" : "‚òÄ");
      }

      // Set the initial state of the switch toggle
      const toggle = document.querySelector("#theme-toggle");
      if (storedTheme === "dark") {
        toggle.checked = true;
        toggle.setAttribute("data-content", "üåô");
      } else {
        toggle.checked = false;
        toggle.setAttribute("data-content", "‚òÄ");
      }

      // Format the values and display them using template literals
      function formatAndDisplay(inputElement) {
        const value = inputElement.value.replace(/,/g, "");
        const number = parseFloat(value);
        if (!isNaN(number)) {
          inputElement.setAttribute("data-raw-value", number);
          inputElement.value = number.toLocaleString();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const createTicketForm = document.getElementById("createTicketForm");
        createTicketForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const numCredits = parseInt(
            document.querySelector("#numCredits").value.replace(/,/g, "")
          );
          const maxTotalPrice = parseFloat(
            document.querySelector("#maxTotalPrice").value.replace(/,/g, "")
          );
          const maxPerCreditPrice = parseFloat(
            document.querySelector("#maxPerCreditPrice").value.replace(/,/g, "")
          );

          const statusContainer = document.getElementById(
            "createTicketStatusContainer"
          );
          const statusContent = document.getElementById("createTicketStatus");
          statusContent.innerHTML = ""; // Clear previous logs

          logCreateTicketStatusMessage(
            "Initializing ticket creation...",
            statusContent
          );
          await createNewCreditPackTicket(
            numCredits,
            maxTotalPrice,
            maxPerCreditPrice
          );
        });

        // Add event listener to format and update raw values on input change
        const inputs = document.querySelectorAll(
          "#numCredits, #maxTotalPrice, #maxPerCreditPrice"
        );
        inputs.forEach((input) => {
          input.addEventListener("input", handleInputChange);
          input.addEventListener("blur", handleInputBlur);
        });

        document
          .getElementById("inferenceRequestForm")
          .addEventListener("submit", async (event) => {
            event.preventDefault();
            saveInferenceRequestSettings();

            const selectedCreditPackTicket = document.querySelector(
              'input[name="creditPackTicket"]:checked'
            );
            if (!selectedCreditPackTicket) {
              alert("Please select a credit pack ticket.");
              return;
            }
            const selectedRow = selectedCreditPackTicket.closest("tr");
            const selectedCreditPackTicketId = selectedRow
              .querySelector("td:last-child a")
              .textContent.trim();

            const selectedInferenceType =
              document.getElementById("inferenceType").value;
            const selectedModelCanonicalName =
              document.getElementById("model").value;
            const maxCost = parseFloat(
              document.querySelector("#maxCost").dataset.rawValue
            );

            const encodeToBase64 = (str) => {
              return btoa(unescape(encodeURIComponent(str)));
            };

            const encodeFileToBase64 = (file) => {
              return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(",")[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
            };

            const formData = new FormData(event.target);
            const modelParameters = {};
            formData.forEach((value, key) => {
              if (
                key !== "prompt" &&
                key !== "imagePrompt" &&
                key !== "embeddingDocumentFile" &&
                key !== "embeddingAudioFile"
              ) {
                modelParameters[key] = value;
              }
            });

            const modelParametersJSON = JSON.stringify(modelParameters);
            const modelParametersJSONBase64Encoded =
              encodeToBase64(modelParametersJSON);

            let inputPromptKey;
            if (selectedInferenceType === "text_completion") {
              inputPromptKey = "prompt";
            } else if (selectedInferenceType === "text_to_image") {
              inputPromptKey = "imagePrompt";
            } else if (selectedInferenceType === "embedding_document") {
              inputPromptKey = "embeddingDocumentFile";
            } else if (selectedInferenceType === "embedding_audio") {
              inputPromptKey = "embeddingAudioFile";
            } else {
              inputPromptKey = "prompt";
            }

            let modelInputDataBase64Encoded;
            if (selectedInferenceType === "ask_question_about_an_image") {
              const imageFile = document.getElementById("imageFile").files[0];
              const question = document.getElementById("question").value;
              if (!imageFile || !question) {
                alert("Please select an image and enter a question.");
                return;
              }
              const imageBase64 = await encodeFileToBase64(imageFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  image: imageBase64,
                  question: question,
                })
              );
            } else if (selectedInferenceType === "embedding_document") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "document_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Document file data cannot be empty.");
                return;
              }
              const documentBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  document: documentBase64,
                  question: semantic_query_string,
                })
              );
            } else if (selectedInferenceType === "embedding_audio") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "audio_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Audio file data cannot be empty.");
                return;
              }
              const audioBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  audio: audioBase64,
                  question: semantic_query_string,
                })
              );
            } else {
              const inputPromptValue =
                document.getElementById(inputPromptKey).value;
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({ [inputPromptKey]: inputPromptValue })
              );
            }

            await createNewInferenceRequest(
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              maxCost,
              modelParametersJSONBase64Encoded,
              modelInputDataBase64Encoded
            );

            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(STORAGE_TIMESTAMP_KEY);

            // Refresh the credit pack tickets to reflect the updated balance
            await getMyValidCreditPacks(true);
          });

        // Attach debounced input and blur event listeners to all relevant input elements
        const inferenceRequestForm = document.getElementById(
          "inferenceRequestForm"
        );
        const inputElements = inferenceRequestForm.querySelectorAll(
          "input, textarea, select"
        );

        inputElements.forEach((inputElement) => {
          inputElement.addEventListener(
            "input",
            debounce(handleInputChange, 300)
          );
          inputElement.addEventListener("blur", handleInputBlur);
        });

        const maxCostInput = document.getElementById("maxCost");
        const maxCostFormattedSpan =
          document.getElementById("maxCostFormatted");
        maxCostInput.addEventListener(
          "input",
          debounce(
            () => formatAndDisplay(maxCostInput, maxCostFormattedSpan),
            300
          )
        );
      });

      document
        .getElementById("exportTerminalButton")
        .addEventListener("click", () => {
          let termText = "";
          for (let i = 0; i < term.buffer.active.length; i++) {
            const line = term.buffer.active.getLine(i);
            if (line) {
              termText += line.translateToString(false) + "\n";
            }
          }
          const blob = new Blob([termText], { type: "text/plain" });
          const link = document.createElement("a");
          const currentDate = new Date().toISOString();
          const fileName = `Pastel_Inference_Client_Terminal_Session_Log__${currentDate}.txt`;
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
        handleCreditPackSelection();
        document.getElementById("inferenceType").value = "text_completion"; // Set default to Text Completion
        document
          .getElementById("inferenceType")
          .dispatchEvent(new Event("change")); // Trigger change event
      });
    </script>
    <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js"></script>
  </body>
</html>
