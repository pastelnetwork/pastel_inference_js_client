./end_to_end_functions.js
---
require("dotenv").config();
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const {
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackStorageRetryRequest,
  InferenceAPIUsageRequest,
  InferenceConfirmation,
} = require("./sequelize_data_models");
const {
  userMessageSchema,
  creditPackPurchaseRequestResponseSchema,
  creditPackPurchaseRequestConfirmationSchema,
  creditPackPurchaseRequestConfirmationResponseSchema,
  creditPackPurchaseRequestStatusSchema,
  creditPackStorageRetryRequestSchema,
  creditPackStorageRetryRequestResponseSchema,
  inferenceAPIUsageRequestSchema,
  inferenceAPIUsageResponseSchema,
  inferenceAPIOutputResultSchema,
  inferenceConfirmationSchema,
} = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const {
  signMessageWithPastelID,
  checkSupernodeList,
  getCurrentPastelBlockHeight,
  sendToAddress,
  sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest,
  checkPSLAddressBalanceAlternative,
} = require("./rpc_functions");
const { PastelInferenceClient } = require("./pastel_inference_client");
const {
  prettyJSON,
  filterSupernodes,
  getNClosestSupernodesToPastelIDURLs,
  validateCreditPackTicketMessageData,
  validateInferenceData,
  computeSHA3256HashOfSQLModelResponseFields,
  checkIfPastelIDIsValid,
  getSupernodeUrlFromPastelID,
  getClosestSupernodePastelIDFromList,
  getClosestSupernodeToPastelIDURL,
} = require("./utility_functions");
const globals = require("./globals");

async function checkForNewIncomingMessages() {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);

    if (!pastelID || !passphrase) {
      logger.error("PastelID or passphrase is not set");
      return [];
    }
    const { validMasternodeListFullDF } = await checkSupernodeList();

    logger.info("Retrieving incoming user messages...");
    logger.info(`My local pastelid: ${inferenceClient.pastelID}`);

    const closestSupernodesToLocal = await getNClosestSupernodesToPastelIDURLs(
      3,
      inferenceClient.pastelID,
      validMasternodeListFullDF
    );
    logger.info(
      `Closest Supernodes to local pastelid: ${closestSupernodesToLocal
        .map((sn) => `PastelID: ${sn.pastelID}, URL: ${sn.url}`)
        .join(", ")}`
    );

    const messageRetrievalTasks = closestSupernodesToLocal.map(({ url }) =>
      inferenceClient.getUserMessages(url).catch((error) => {
        logger.warn(
          `Failed to retrieve messages from supernode ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        return []; // Return an empty array on error
      })
    );
    const messageLists = await Promise.all(messageRetrievalTasks);

    const uniqueMessages = [];
    const messageIDs = new Set();
    for (const messageList of messageLists) {
      for (const message of messageList) {
        if (!messageIDs.has(message.id)) {
          uniqueMessages.push(message);
          messageIDs.add(message.id);
        }
      }
    }

    logger.info(
      `Retrieved unique user messages: ${safeStringify(uniqueMessages)}`
    );

    return uniqueMessages;
  } catch (error) {
    logger.error(`Error in checkForNewIncomingMessages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function sendMessageAndCheckForNewIncomingMessages(
  toPastelID,
  messageBody
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();

    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    logger.info("Sending user message...");
    logger.info(`Recipient pastelid: ${toPastelID}`);

    const closestSupernodesToRecipient =
      await getNClosestSupernodesToPastelIDURLs(
        3,
        toPastelID,
        validMasternodeListFullDF
      );
    logger.info(
      `Closest Supernodes to recipient pastelid: ${closestSupernodesToRecipient.map(
        (sn) => sn.pastelID
      )}`
    );

    const userMessage = UserMessage.build({
      from_pastelid: pastelID,
      to_pastelid: toPastelID,
      message_body: safeStringify(messageBody),
      message_signature: await signMessageWithPastelID(
        pastelID,
        messageBody,
        passphrase
      ),
    });

    const { error } = userMessageSchema.validate(userMessage.toJSON());
    if (error) {
      throw new Error(`Invalid user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    }

    const sendTasks = closestSupernodesToRecipient.map(({ url }) =>
      inferenceClient.sendUserMessage(url, userMessage)
    );
    const sendResults = await Promise.all(sendTasks);
    logger.info(`Sent user messages: ${safeStringify(sendResults)}`);

    const receivedMessages = await checkForNewIncomingMessages();

    const messageDict = {
      sent_messages: sendResults,
      received_messages: receivedMessages,
    };

    return messageDict;
  } catch (error) {
    logger.error(
      `Error in sendMessageAndCheckForNewIncomingMessages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function getIsoStringWithMicroseconds() {
  const now = new Date();
  const isoString = now.toISOString().replace("Z", "+00:00").replace(/\s/g, "");
  return isoString;
}

async function handleCreditPackTicketEndToEnd(
  numberOfCredits,
  creditUsageTrackingPSLAddress,
  burnAddress,
  maximumTotalCreditPackPriceInPSL,
  maximumPerCreditPriceInPSL
) {
  const pastelID = globals.getPastelId();
  const passphrase = globals.getPassphrase();
  if (!pastelID || !passphrase) {
    throw new Error("PastelID or passphrase is not set");
  }

  const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
  const { validMasternodeListFullDF } = await checkSupernodeList();
  const requestTimestamp = getIsoStringWithMicroseconds();

  const creditPackRequest = CreditPackPurchaseRequest.build({
    requesting_end_user_pastelid: pastelID,
    requested_initial_credits_in_credit_pack: parseInt(numberOfCredits, 10),
    list_of_authorized_pastelids_allowed_to_use_credit_pack: JSON.stringify([pastelID]),
    credit_usage_tracking_psl_address: creditUsageTrackingPSLAddress,
    request_timestamp_utc_iso_string: requestTimestamp,
    request_pastel_block_height: parseInt(await getCurrentPastelBlockHeight(), 10),
    credit_purchase_request_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_purchase_request_fields: "",
    requesting_end_user_pastelid_signature_on_request_hash: "",
  });

  creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields =
    await computeSHA3256HashOfSQLModelResponseFields(creditPackRequest);
  creditPackRequest.requesting_end_user_pastelid_signature_on_request_hash =
    await signMessageWithPastelID(
      pastelID,
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
      passphrase
    );

  const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(12, pastelID, validMasternodeListFullDF);
  if (closestSupernodes.length === 0) {
    throw new Error("No responsive supernodes found.");
  }

  const randomIndex = Math.floor(Math.random() * closestSupernodes.length);
  const selectedSupernode = closestSupernodes[randomIndex];
  const highestRankedSupernodeURL = selectedSupernode.url;

  logger.info(`Selected supernode URL for credit pack request: ${highestRankedSupernodeURL}`);

  try {
    const preliminaryPriceQuote = await inferenceClient.creditPackTicketInitialPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackRequest
    );

    const signedCreditPackTicketOrRejection = await inferenceClient.creditPackTicketPreliminaryPriceQuoteResponse(
      highestRankedSupernodeURL,
      creditPackRequest,
      preliminaryPriceQuote,
      maximumTotalCreditPackPriceInPSL,
      maximumPerCreditPriceInPSL
    );

    if (signedCreditPackTicketOrRejection instanceof CreditPackPurchaseRequestResponseTermination) {
      logger.info(`Credit pack purchase request terminated: ${signedCreditPackTicketOrRejection.termination_reason_string}`);
      return null;
    }

    const signedCreditPackTicket = signedCreditPackTicketOrRejection;

    const burnTransactionResponse = await sendToAddress(
      burnAddress,
      Math.round(signedCreditPackTicket.proposed_total_cost_of_credit_pack_in_psl * 100000) / 100000,
      "Burn transaction for credit pack ticket"
    );

    if (!burnTransactionResponse.success) {
      throw new Error(`Error sending PSL to burn address: ${burnTransactionResponse.message}`);
    }

    const burnTransactionTxid = burnTransactionResponse.result;

    const creditPackPurchaseRequestConfirmation = await buildCreditPackPurchaseRequestConfirmation(
      creditPackRequest,
      signedCreditPackTicket,
      burnTransactionTxid,
      pastelID,
      passphrase
    );

    await CreditPackPurchaseRequestConfirmation.create(creditPackPurchaseRequestConfirmation.toJSON());

    const creditPackPurchaseRequestConfirmationResponse = await inferenceClient.confirmCreditPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackPurchaseRequestConfirmation
    );

    if (!creditPackPurchaseRequestConfirmationResponse) {
      throw new Error("Credit pack ticket storage failed");
    }

    let creditPackPurchaseRequestStatus = await checkCreditPackPurchaseRequestStatus(
      inferenceClient,
      highestRankedSupernodeURL,
      creditPackRequest,
      closestSupernodes
    );

    if (creditPackPurchaseRequestStatus.status !== "completed") {
      const creditPackStorageRetryRequestResponse = await initiateStorageRetry(
        inferenceClient,
        creditPackRequest,
        signedCreditPackTicket,
        validMasternodeListFullDF,
        pastelID,
        passphrase
      );

      return creditPackStorageRetryRequestResponse;
    } else {
      return creditPackPurchaseRequestConfirmationResponse;
    }
  } catch (error) {
    logger.error(`Error in handleCreditPackTicketEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw new Error("An unexpected error occurred while processing your credit pack purchase. Please try again later.");
  }
}

async function buildCreditPackPurchaseRequestConfirmation(creditPackRequest, signedCreditPackTicket, burnTransactionTxid, pastelID, passphrase) {
  const confirmation = CreditPackPurchaseRequestConfirmation.build({
    sha3_256_hash_of_credit_pack_purchase_request_fields:
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    txid_of_credit_purchase_burn_transaction: burnTransactionTxid,
    credit_purchase_request_confirmation_utc_iso_string: new Date().toISOString(),
    credit_purchase_request_confirmation_pastel_block_height: await getCurrentPastelBlockHeight(),
    credit_purchase_request_confirmation_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: "",
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: "",
  });

  confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await computeSHA3256HashOfSQLModelResponseFields(confirmation);
  confirmation.requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await signMessageWithPastelID(
      pastelID,
      confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields,
      passphrase
    );

  const { error: confirmationValidationError } = creditPackPurchaseRequestConfirmationSchema.validate(confirmation.toJSON());
  if (confirmationValidationError) {
    throw new Error(`Invalid credit pack purchase request confirmation: ${confirmationValidationError.message}`);
  }

  return confirmation;
}

async function checkCreditPackPurchaseRequestStatus(inferenceClient, highestRankedSupernodeURL, creditPackRequest, closestSupernodes) {
  try {
    const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
    );
    logger.info(`Credit pack purchase request status from the original supernode: ${JSON.stringify(status)}`);
    return status;
  } catch (error) {
    logger.debug(`Error checking status with original supernode: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}. Trying other supernodes.`);
    for (const supernode of closestSupernodes) {
      try {
        const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
          supernode.url,
          creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
        );
        logger.info(`Credit pack purchase request status: ${JSON.stringify(status)}`);
        return status;
      } catch (retryError) {
        logger.debug(`Error checking status with supernode ${supernode.url}: ${retryError.message}`);
      }
    }
    throw new Error("Failed to check status of credit purchase request with all Supernodes");
  }
}

async function initiateStorageRetry(inferenceClient, creditPackRequest, signedCreditPackTicket, validMasternodeListFullDF, pastelID, passphrase) {
  const closestAgreeingSupernodePastelID = await getClosestSupernodePastelIDFromList(
    pastelID,
    signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms
  );

  const creditPackStorageRetryRequest = await buildCreditPackStorageRetryRequest(
    creditPackRequest,
    signedCreditPackTicket,
    closestAgreeingSupernodePastelID,
    pastelID,
    passphrase
  );

  await CreditPackStorageRetryRequest.create(creditPackStorageRetryRequest.toJSON());

  const closestAgreeingSupernodeURL = await getSupernodeUrlFromPastelID(
    closestAgreeingSupernodePastelID,
    validMasternodeListFullDF
  );

  const creditPackStorageRetryRequestResponse = await inferenceClient.creditPackStorageRetryRequest(
    closestAgreeingSupernodeURL,
    creditPackStorageRetryRequest
  );

  const { error: storageRetryResponseValidationError } = creditPackStorageRetryRequestResponseSchema.validate(
    creditPackStorageRetryRequestResponse.toJSON()
  );

  if (storageRetryResponseValidationError) {
    throw new Error(`Invalid credit pack storage retry request response: ${storageRetryResponseValidationError.message}`);
  }

  // Silently attempt to announce completion to all agreeing supernodes
  const announcementPromises = signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms.map(
    async (supernodePastelID) => {
      if (checkIfPastelIDIsValid(supernodePastelID)) {
        try {
          const supernodeURL = await getSupernodeUrlFromPastelID(supernodePastelID, validMasternodeListFullDF);
          await inferenceClient.creditPackPurchaseCompletionAnnouncement(
            supernodeURL,
            creditPackStorageRetryRequestResponse
          );
        } catch (error) {
          // Silently ignore errors in completion announcements
        }
      }
    }
  );

  await Promise.allSettled(announcementPromises);

  return creditPackStorageRetryRequestResponse;
}

async function buildCreditPackStorageRetryRequest(creditPackRequest, signedCreditPackTicket, closestAgreeingSupernodePastelID, pastelID, passphrase) {
  const storageRetryRequest = CreditPackStorageRetryRequest.build({
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    closest_agreeing_supernode_to_retry_storage_pastelid: closestAgreeingSupernodePastelID,
    credit_pack_storage_retry_request_timestamp_utc_iso_string: new Date().toISOString(),
    credit_pack_storage_retry_request_pastel_block_height: await getCurrentPastelBlockHeight(),
    credit_pack_storage_retry_request_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_storage_retry_request_fields: "",
    requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash: "",
  });

  storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields =
    await computeSHA3256HashOfSQLModelResponseFields(storageRetryRequest);
  storageRetryRequest.requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash =
    await signMessageWithPastelID(
      pastelID,
      storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields,
      passphrase
    );

  const { error: storageRetryRequestValidationError } = creditPackStorageRetryRequestSchema.validate(storageRetryRequest.toJSON());
  if (storageRetryRequestValidationError) {
    throw new Error(`Invalid credit pack storage retry request: ${storageRetryRequestValidationError.message}`);
  }

  return storageRetryRequest;
}

async function getCreditPackTicketInfoEndToEnd(creditPackTicketPastelTxid) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();
    const { url: supernodeURL } = await getClosestSupernodeToPastelIDURL(
      pastelID,
      validMasternodeListFullDF
    );
    if (!supernodeURL) {
      throw new Error("Supernode URL is undefined");
    }
    logger.info(
      `Getting credit pack ticket data from Supernode URL: ${supernodeURL}...`
    );

    const {
      creditPackPurchaseRequestResponse,
      creditPackPurchaseRequestConfirmation,
    } = await inferenceClient.getCreditPackTicketFromTxid(
      supernodeURL,
      creditPackTicketPastelTxid
    );

    const balanceInfo = await inferenceClient.checkCreditPackBalance(
      supernodeURL,
      creditPackTicketPastelTxid
    );

    return {
      requestResponse: creditPackPurchaseRequestResponse,
      requestConfirmation: creditPackPurchaseRequestConfirmation,
      balanceInfo,
    };
  } catch (error) {
    logger.error(`Error in getCreditPackTicketInfoEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getMyValidCreditPackTicketsEndToEnd() {
  const initialMinimumNonEmptyResponses = 5;
  const maxTotalResponsesIfAllEmpty = 20;
  const retryLimit = 1;

  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();

    const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(
      120,
      pastelID,
      validMasternodeListFullDF
    );

    let allResponses = [];
    let nonEmptyResponses = [];
    let isResolved = false;

    await new Promise((resolve, reject) => {
      let completedRequests = 0;

      const handleResponse = () => {
        if (isResolved) return;

        if (nonEmptyResponses.length >= initialMinimumNonEmptyResponses) {
          logger.info(
            `Received ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        } else if (allResponses.length >= maxTotalResponsesIfAllEmpty) {
          logger.info(
            `Reached maximum total responses (${maxTotalResponsesIfAllEmpty}) with ${nonEmptyResponses.length} non-empty responses`
          );
          isResolved = true;
          resolve();
        } else if (completedRequests >= closestSupernodes.length) {
          logger.warn(
            `Queried all available supernodes. Got ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        }
      };

      closestSupernodes.forEach(({ url }) => {
        if (isResolved) return;

        retryPromise(
          () => inferenceClient.getValidCreditPackTicketsForPastelID(url),
          retryLimit
        )
          .then((response) => {
            if (isResolved) return;

            logger.info(
              `Response received from supernode at ${url}; response length: ${response.length}`
            );
            allResponses.push({ response, url });
            if (response.length > 0) {
              nonEmptyResponses.push({ response, url });
            }
            completedRequests++;
            handleResponse();
          })
          .catch((error) => {
            if (isResolved) return;

            logger.error(
              `Error querying supernode at ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
            );
            completedRequests++;
            handleResponse();
          });
      });
    });

    if (nonEmptyResponses.length > 0) {
      // Return the longest non-empty response
      const longestResponse = nonEmptyResponses.reduce((prev, current) => {
        return current.response.length > prev.response.length ? current : prev;
      }).response;
      logger.info(
        `Returning longest non-empty response with length: ${longestResponse.length}`
      );
      return longestResponse;
    } else {
      logger.info("All responses were empty. Returning empty list.");
      return [];
    }
  } catch (error) {
    logger.error(
      `Error in getMyValidCreditPackTicketsEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return [];
  }
}

async function retryPromise(promiseFunc, limit, count = 0) {
  try {
    return await promiseFunc();
  } catch (error) {
    if (count < limit) {
      return retryPromise(promiseFunc, limit, count + 1);
    } else {
      throw error;
    }
  }
}

async function estimateCreditPackCostEndToEnd(
  desiredNumberOfCredits,
  creditPriceCushionPercentage
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const estimatedTotalCostOfTicket =
      await inferenceClient.internalEstimateOfCreditPackTicketCostInPSL(
        desiredNumberOfCredits,
        creditPriceCushionPercentage
      );
    return estimatedTotalCostOfTicket;
  } catch (error) {
    logger.error(`Error in estimateCreditPackCostEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function handleInferenceRequestEndToEnd(
  creditPackTicketPastelTxid,
  modelInputData,
  requestedModelCanonicalString,
  modelInferenceTypeString,
  modelParameters,
  maximumInferenceCostInCredits,
  burnAddress
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const modelParametersJSON = safeStringify(modelParameters);

    // Get the closest N supernode URLs that support the desired model, ordered by response time
    const supernodeURLs = await inferenceClient.getClosestSupernodeURLsThatSupportsDesiredModel(
      requestedModelCanonicalString,
      modelInferenceTypeString,
      modelParametersJSON,
      12 // Limit to the closest 12 supernodes
    );

    if (!supernodeURLs || supernodeURLs.length === 0) {
      logger.error(
        `No supporting supernode found with adequate performance for the desired model: ${requestedModelCanonicalString} with inference type: ${modelInferenceTypeString}`
      );
      return null;
    }

    let inferenceResultDict = null;
    let auditResults = null;
    let validationResults = null;
    let error = null;

    // Limit to trying the 5 fastest supernodes (based on response times)
    const maxTries = Math.min(5, supernodeURLs.length);

    for (let i = 0; i < maxTries; i++) {
      const supernodeURL = supernodeURLs[i];
      logger.info(`Attempting inference request to Supernode URL: ${supernodeURL}`);

      try {
        const modelInputDataJSONBase64Encoded = Buffer.from(
          JSON.stringify(modelInputData)
        ).toString("base64");

        const modelParametersJSONBase64Encoded =
          Buffer.from(modelParametersJSON).toString("base64");

        const currentBlockHeight = await getCurrentPastelBlockHeight();

        const inferenceRequestData = InferenceAPIUsageRequest.build({
          requesting_pastelid: pastelID,
          credit_pack_ticket_pastel_txid: creditPackTicketPastelTxid,
          requested_model_canonical_string: requestedModelCanonicalString,
          model_inference_type_string: modelInferenceTypeString,
          model_parameters_json_b64: modelParametersJSONBase64Encoded,
          model_input_data_json_b64: modelInputDataJSONBase64Encoded,
          inference_request_utc_iso_string: new Date().toISOString(),
          inference_request_pastel_block_height: currentBlockHeight,
          status: "initiating",
          inference_request_message_version_string: "1.0",
          sha3_256_hash_of_inference_request_fields: "",
          requesting_pastelid_signature_on_request_hash: "",
        });

        const sha3256HashOfInferenceRequestFields =
          await computeSHA3256HashOfSQLModelResponseFields(inferenceRequestData);
        inferenceRequestData.sha3_256_hash_of_inference_request_fields =
          sha3256HashOfInferenceRequestFields;
        const requestingPastelIDSignatureOnRequestHash =
          await signMessageWithPastelID(
            pastelID,
            sha3256HashOfInferenceRequestFields,
            passphrase
          );
        inferenceRequestData.requesting_pastelid_signature_on_request_hash =
          requestingPastelIDSignatureOnRequestHash;

        const usageRequestResponse =
          await inferenceClient.makeInferenceAPIUsageRequest(
            supernodeURL,
            inferenceRequestData
          );

        const validationErrors = await validateCreditPackTicketMessageData(
          usageRequestResponse
        );
        if (validationErrors && validationErrors.length > 0) {
          throw new Error(
            `Invalid inference request response from Supernode URL ${supernodeURL}: ${validationErrors.join(
              ", "
            )}`
          );
        }

        const usageRequestResponseDict = usageRequestResponse.toJSON();
        const inferenceRequestID = usageRequestResponseDict.inference_request_id;
        const inferenceResponseID = usageRequestResponseDict.inference_response_id;
        const proposedCostInCredits = parseFloat(
          usageRequestResponseDict.proposed_cost_of_request_in_inference_credits
        );
        const creditUsageTrackingPSLAddress =
          usageRequestResponseDict.credit_usage_tracking_psl_address;
        const creditUsageTrackingAmountInPSL =
          parseFloat(
            usageRequestResponseDict.request_confirmation_message_amount_in_patoshis
          ) / 100000;
        const trackingAddressBalance = await checkPSLAddressBalanceAlternative(
          creditUsageTrackingPSLAddress
        );

        if (trackingAddressBalance < creditUsageTrackingAmountInPSL) {
          logger.error(
            `Insufficient balance in tracking address: ${creditUsageTrackingPSLAddress}; amount needed: ${creditUsageTrackingAmountInPSL}; current balance: ${trackingAddressBalance}; shortfall: ${creditUsageTrackingAmountInPSL - trackingAddressBalance
            }`
          );
          return null;
        }

        if (proposedCostInCredits <= maximumInferenceCostInCredits) {
          const trackingTransactionTxid =
            await sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
              inferenceRequestID,
              creditUsageTrackingPSLAddress,
              creditUsageTrackingAmountInPSL,
              burnAddress
            );

          const txidLooksValid = /^[0-9a-fA-F]{64}$/.test(trackingTransactionTxid);

          if (txidLooksValid) {
            const confirmationData = InferenceConfirmation.build({
              inference_request_id: inferenceRequestID,
              requesting_pastelid: pastelID,
              confirmation_transaction: { txid: trackingTransactionTxid },
            });

            const confirmationResult =
              await inferenceClient.sendInferenceConfirmation(
                supernodeURL,
                confirmationData
              );

            logger.info(
              `Sent inference confirmation: ${prettyJSON(confirmationResult)}`
            );

            const maxTriesToGetConfirmation = 60;
            let initialWaitTimeInSeconds = 3;
            let waitTimeInSeconds = initialWaitTimeInSeconds;

            for (let cnt = 0; cnt < maxTriesToGetConfirmation; cnt++) {
              waitTimeInSeconds = waitTimeInSeconds * 1.04 ** cnt;
              logger.info(
                `Waiting for the inference results for ${Math.round(
                  waitTimeInSeconds
                )} seconds... (Attempt ${cnt + 1
                }/${maxTriesToGetConfirmation}); Checking with Supernode URL: ${supernodeURL}`
              );

              await new Promise((resolve) =>
                setTimeout(resolve, waitTimeInSeconds * 1000)
              );

              if (
                inferenceRequestID.length === 0 ||
                inferenceResponseID.length === 0
              ) {
                throw new Error("Inference request ID or response ID is empty");
              }

              const resultsAvailable =
                await inferenceClient.checkStatusOfInferenceRequestResults(
                  supernodeURL,
                  inferenceResponseID
                );

              if (resultsAvailable) {
                const outputResults =
                  await inferenceClient.retrieveInferenceOutputResults(
                    supernodeURL,
                    inferenceRequestID,
                    inferenceResponseID
                  );

                const outputResultsDict = outputResults.toJSON();
                const outputResultsSize =
                  outputResults.inference_result_json_base64.length;
                const maxResponseSizeToLog = 20000;

                inferenceResultDict = {
                  supernode_url: supernodeURL,
                  request_data: inferenceRequestData.toJSON(),
                  usage_request_response: usageRequestResponseDict,
                  model_input_data_json: modelInputData,
                  output_results: outputResultsDict,
                };

                if (modelInferenceTypeString === "text_to_image") {
                  let jsonString = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString("utf-8");
                  let jsonObject = JSON.parse(jsonString);
                  let imageBase64 = jsonObject.image;
                  inferenceResultDict.generated_image_decoded = Buffer.from(
                    imageBase64,
                    "base64"
                  );
                } else if (modelInferenceTypeString === "embedding_document") {
                  const inferenceResultDecoded = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString("utf-8");
                  let zipBinary = Buffer.from(inferenceResultDecoded, "base64");
                  inferenceResultDict.zip_file_data = zipBinary;
                } else {
                  const inferenceResultDecoded = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString();
                  logger.info(`Decoded response:\n${inferenceResultDecoded}`);
                  inferenceResultDict.inference_result_decoded =
                    inferenceResultDecoded;
                }

                const useAuditFeature = false;

                if (useAuditFeature) {
                  logger.info(
                    "Waiting 3 seconds for audit results to be available..."
                  );
                  await new Promise((resolve) => setTimeout(resolve, 3000));

                  auditResults =
                    await inferenceClient.auditInferenceRequestResponseID(
                      inferenceResponseID,
                      supernodeURL
                    );
                  validationResults = validateInferenceData(
                    inferenceResultDict,
                    auditResults
                  );
                  logger.info(
                    `Validation results: ${prettyJSON(validationResults)}`
                  );
                  if (!auditResults) {
                    logger.warn("Audit results are null");
                  }
                  if (!validationResults) {
                    logger.warn("Validation results are null");
                  }
                } else {
                  auditResults = null;
                  validationResults = null;
                }

                if (!inferenceResultDict) {
                  logger.error("Inference result is null");
                  return {
                    inferenceResultDict: null,
                    auditResults: null,
                    validationResults: null,
                  };
                }
                return { inferenceResultDict, auditResults, validationResults };
              } else {
                logger.info("Inference results not available yet; retrying...");
              }
            }
          }
        } else {
          logger.info(
            `Quoted price of ${proposedCostInCredits} credits exceeds the maximum allowed cost of ${maximumInferenceCostInCredits} credits. Inference request not confirmed.`
          );
          return {
            inferenceResultDict: null,
            auditResults: null,
            validationResults: null,
          };
        }
      } catch (err) {
        error = err;
        logger.warn(`Failed inference request to Supernode URL ${supernodeURL}. Moving on to the next one.`);
      }
    }

    // If no inference request succeeded after all retries
    if (!inferenceResultDict) {
      throw new Error(
        `Failed to make inference request after ${maxTries} tries. Last error: ${error ? error.message : 'Unknown error'}`
      );
    }
  } catch (error) {
    logger.error(`Error in handleInferenceRequestEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

module.exports = {
  checkForNewIncomingMessages,
  sendMessageAndCheckForNewIncomingMessages,
  handleCreditPackTicketEndToEnd,
  getCreditPackTicketInfoEndToEnd,
  getMyValidCreditPackTicketsEndToEnd,
  handleInferenceRequestEndToEnd,
  estimateCreditPackCostEndToEnd,
};


---
./eslint.config.mjs
---
import globals from "globals";
import pluginJs from "@eslint/js";

export default [
  // Configuration for JavaScript files
  {
    files: ["**/*.js"], // Applies to all JavaScript files
    parserOptions: {
      // Correct from `languageOptions` to `parserOptions`
      sourceType: "commonjs", // Specifies CommonJS modules
    },
    env: {
      node: true, // Ensure Node.js environment is enabled
    },
    globals: { ...globals.node }, // Adds Node.js globals
    rules: {
      // Customize the `no-unused-vars` rule
      "no-unused-vars": [
        "warn",
        { argsIgnorePattern: "^_", varsIgnorePattern: "^_" },
      ],
    },
  },
  // Configuration for handling global variables in a browser context
  {
    parserOptions: {
      sourceType: "module",
    },
    env: {
      browser: true, // Explicitly set browser environment if needed
    },
    globals: globals.browser,
  },
  pluginJs.configs.recommended,
  // Your custom rule modifications can also go here
  {
    rules: {
      // ... other rules
    },
  },
];


---
./globals.js
---
let MY_LOCAL_PASTELID = null;
let MY_PASTELID_PASSPHRASE = null;

const MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE = 1000;

function setPastelIdAndPassphrase(pastelId, passphrase) {
    MY_LOCAL_PASTELID = pastelId;
    MY_PASTELID_PASSPHRASE = passphrase;
}

function getPastelIdAndPassphrase() {
    return { pastelID: MY_LOCAL_PASTELID, passphrase: MY_PASTELID_PASSPHRASE };
}

function getPastelId() {
    return MY_LOCAL_PASTELID;
}

function getPassphrase() {
    return MY_PASTELID_PASSPHRASE;
}

module.exports = {
    setPastelIdAndPassphrase,
    getPastelIdAndPassphrase,
    getPastelId,
    getPassphrase,
    MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE
};


---
./index.html
---
<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pastel Inference Client UI</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sira-ui/tailwind/dist/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/json.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.9.3/sha3.min.js"></script>
  <style>
    .ground-glass {
      background-color: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
    }

    body {
      font-family: Montserrat, sans-serif;
    }

    .btn.success.outline {
      border-color: #4caf50;
      color: #4caf50;
    }

    .btn.success.outline:hover {
      background-color: #4caf50;
      color: #ffffff;
    }

    .btn.success.outline:active {
      background-color: #388e3c;
      border-color: #388e3c;
      color: #ffffff;
    }

    .icon-large {
      font-size: 1.5rem;
      /* Adjust this size as needed */
    }

    .xterm {
      width: 100% !important;
      border-radius: 0.5rem;
      /* Adds rounded corners */
    }

    .table-container {
      overflow-x: auto;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .table th,
    .table td {
      padding: 0.5rem;
      border: 1px solid #ccc;
    }

    .table th:last-child,
    .table td:last-child {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 170px;
    }

    .table td:last-child:hover {
      white-space: normal;
    }

    [data-theme="dark"] {
      background-color: #121212;
      color: #ffffff;
    }

    [data-theme="dark"] .bg-white {
      background-color: #333333;
    }

    [data-theme="dark"] .text-bw-50 {
      color: #cccccc;
    }

    [data-theme="dark"] .text-bw-600 {
      color: #ffffff;
    }

    [data-theme="dark"] .text-bw-700 {
      color: #eeeeee;
    }

    [data-theme="dark"] .text-bw-800 {
      color: #ffffff;
    }

    [data-theme="dark"] .bg-bw-50 {
      background-color: #333333;
    }

    [data-theme="dark"] .btn.outline.bw {
      border-color: #ffffff;
      color: #ffffff;
    }

    [data-theme="dark"] .btn.outline.bw:hover {
      background-color: #ffffff;
      color: #000000;
    }

    [data-theme="dark"] .table .bg-gray-200 {
      background-color: #333333;
      color: #ffffff;
      /* This needs to be adjusted */
    }

    [data-theme="dark"] .table .bg-gray-200.selected-row {
      color: #000000;
      /* Adjust this color to be dark for legibility */
    }

    [data-theme="dark"] #previousRequestsList {
      background-color: #333333;
      color: #ffffff;
    }

    [data-theme="dark"] .input,
    [data-theme="dark"] .select {
      border-color: #cccccc;
    }

    [data-theme="dark"] .input::placeholder {
      color: #cccccc;
      opacity: 1;
      /* Firefox */
    }

    [data-theme="dark"] .input::-ms-input-placeholder {
      /* Edge 12-18 */
      color: #cccccc;
    }

    [data-theme="dark"] .select option {
      color: #333333;
    }

    [data-theme="dark"] .delete-btn {
      color: #ffffff;
      border-color: #ffffff;
    }

    [data-theme="dark"] .bg-bw-800 {
      background-color: #111827;
    }

    .table-responsive {
      overflow-x: auto;
    }

    .table.bordered tbody tr:last-child td:first-child {
      border-bottom-left-radius: 12px;
    }

    .table.bordered tbody tr:last-child td:last-child {
      border-bottom-right-radius: 12px;
    }

    .truncate {
      max-width: 150px;
      /* Adjust as needed */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .prompt.success.xs {
      display: inline-block;
      flex-grow: 1;
      /* Allow it to take up the remaining space */
      max-width: calc(100% - 2rem);
      /* Leave some padding for better readability */
      word-wrap: break-word;
      /* Ensure the text wraps correctly */
      height: 333px;
      /* Set a fixed height */
      overflow-y: auto;
      /* Add a scrollbar if the content exceeds the height */
      padding: 0.5rem;
      /* Add padding for better readability */
      border: 1px solid #ccc;
      /* Optional: Add a border for better visibility */
      border-radius: 0.5rem;
      /* Optional: Add rounded corners */
    }

    .prompt.success.xs .content {
      overflow-wrap: break-word;
    }

    .flex {
      display: flex;
    }

    .items-center {
      align-items: center;
    }

    .gap-4 {
      gap: 1rem;
      /* Adjust gap as needed */
    }

    .hidden {
      display: none;
    }

    #previousRequestsList {
      background-color: #f9f9f9;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1rem;
      max-height: 1200px;
      overflow-y: auto;
    }

    #requestPreview {
      background-color: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1.5rem;
    }

    [data-theme="dark"] #requestPreview {
      background-color: #0f291e;
    }

    .delete-btn {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      transition: box-shadow 0.3s;
    }

    .delete-btn:hover {
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    #exportRequestsButton {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: auto;
    }

    .align-middle {
      vertical-align: middle;
    }

    .credit-pack-details-container {
      width: 100%;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .new-ticket-table th {
      width: 25%;
      /* As we have 4 columns, each gets 25% width */
    }

    .tooltip-icon {
      margin-left: 5px;
      font-size: 14px;
      color: #6b7280;
    }

    .select-column {
      width: 6%;
    }

    .initial-credits-column {
      width: 16%;
    }

    .current-credit-balance-column {
      width: 16.5%;
    }

    .tracking-address-column {
      width: 25%;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
    }

    .registration-txid-column {
      width: 25%;
    }

    .sha3256-hash-of-credit-pack-column {
      width: 30%;
    }

    .responding-supernode-pastelid-column {
      width: 30%;
    }

    .outcome-column {
      width: 15%;
    }

    .btn.is-loading:before {
      display: inline-block;
      vertical-align: middle;
    }

    * {
      scroll-margin-top: 72px;
    }
  </style>
</head>

<body class="flex flex-col gap-6 transition-all duration-300 bg-bw-50">
  <div class="max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8">
    <div class="flex gap-6 items-center sticky top-0 p-4 bg-bw-50 z-10 ground-glass shadow-md" id="title">
      <h1 class="text-4xl font-bold text-bw-600">
        Pastel Inference Client
        <span id="networkName" class="text-xl font-normal align-middle"></span>
      </h1>
      <input id="theme-toggle" class="switch success lg" data-content="☀" type="checkbox" onchange="toggleDarkMode()" />
    </div>
    <div class="grid grid-cols-5 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl col-span-full text-bw-800">User Information</h2>
      <div class="col-span-full">
        <div id="noPastelIDContainer" class="hidden">
          <p class="text-bw-700">
            No PastelID found. Would you like to create a new one for 1,000
            PSL?
          </p>
          <form id="createPastelIDForm" class="mt-4">
            <label class="block text-bw-700 font-bold mb-2" for="newPastelIDPassphrase">
              Enter Passphrase (min 6 characters):
            </label>
            <input id="newPastelIDPassphrase" class="input w-full" type="password" placeholder="Enter passphrase"
              minlength="6" required />
            <div class="flex items-center gap-3">
              <button type="submit" class="btn success outline mt-4">
                Create PastelID
              </button>
              <div id="createPastelIDLoading"></div>
            </div>
            <div id="createPastelIDMessageContainer" class="my-4"></div>
            <!-- Container for messages -->
          </form>
          <p class="mt-4">
            Already have an existing PastelID? Import the file here:
          </p>
          <input id="importPastelIDFile" class="input w-full" type="file" />
          <div class="flex items-center gap-2 m-2 ml-0">
            <button id="importPastelIDButton" class="btn outline success">
              Import PastelID
            </button>
            <div class="hidden" id="importPastelIDBLoading"></div>
          </div>
        </div>

        <button id="changePastelIDButton" class="btn outline success" onclick="togglePastelIDDropdown()">
          Switch to a Different PastelID
        </button>
        <div id="pastelIDDropdownContainer" class="mt-4 hidden">
          <label class="block text-bw-700 font-bold mb-2">Select Existing PastelID to Use:</label>
          <select id="pastelIDDropdown" class="select w-full">
            <!-- Options will be dynamically populated -->
          </select>
        </div>
        <div class="mt-4 hidden" id="passphraseContainer">
          <label class="block text-bw-700 font-bold mb-2" for="pastelIDPassphrase">Enter Passphrase:</label>
          <input id="pastelIDPassphrase" class="input w-full" type="password" placeholder="Enter passphrase"
            minlength="6" required />
          <div class="mt-2">
            <input type="checkbox" id="rememberPassphrase" />
            <label for="rememberPassphrase" class="text-bw-700">Remember password?</label>
          </div>
          <button id="submitPassphraseButton" class="btn success outline mt-4">
            Submit
          </button>
          <div id="messageContainer" class="my-4"></div>
          <!-- Container for messages -->
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2">Your Currently Selected PastelID:</label>
          <span id="userPastelID" class="text-bw-700">Loading...</span>
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2">Wallet Balance (PSL):</label>
          <span id="walletBalance" class="text-bw-700">
            Loading...
            <script>
              document.addEventListener("DOMContentLoaded", async () => {
                try {
                  const walletInfoResponse = await axios.get(
                    "/get-wallet-info"
                  );
                  const walletInfo = walletInfoResponse.data.result;
                  const formattedWalletBalance =
                    walletInfo.balance.toLocaleString(undefined, {
                      minimumFractionDigits: 1,
                      maximumFractionDigits: 1,
                    });
                  document.getElementById(
                    "walletBalance"
                  ).textContent = `${formattedWalletBalance} PSL`;
                } catch (error) {
                  console.error("Error retrieving wallet info:", error);
                  document.getElementById("walletBalance").textContent =
                    "Failed to load balance";
                }
              });
            </script>
          </span>
        </div>

        <div class="mt-4 flex items-center">
          <label class="block text-bw-700 font-bold mb-2">My PSL Address:</label>
          <span id="myPslAddress" class="text-bw-700 ml-2"></span>
          <button id="copyAddressButton" class="ml-2 tooltip" data-tooltip="Copy address to clipboard">
            📋
          </button>
        </div>

        <button id="createPastelIDButton" class="btn success outline m-4 hidden">
          Create a PastelID so you can make inference requests? (Costs 1,000
          PSL)
        </button>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Create New Credit Pack Ticket</h2>
      <form id="createTicketForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="numCredits">Number of Credits</label>
          <input class="input w-full" id="numCredits" type="text" placeholder="Enter number of credits" value="1500"
            data-raw-value="1500" required />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxTotalPrice">Maximum Total Price (PSL)</label>
          <input class="input w-full" id="maxTotalPrice" type="text" placeholder="Enter maximum total price"
            value="150000" data-raw-value="150000" required />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxPerCreditPrice">Maximum Per Credit Price (PSL)</label>
          <input class="input w-full" id="maxPerCreditPrice" type="text" placeholder="Enter maximum per credit price"
            value="100.0" data-raw-value="100.0" required />
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button class="btn success outline" type="submit" id="createCreditPackButton">
              Create Credit Pack
            </button>
            <div id="loaderContainer"></div>
            <!-- Add this div for the loader -->
            <div class="prompt success xs" id="createTicketStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="createTicketStatus">Current Status:</label>
              <div class="content p-2" id="createTicketStatus"></div>
            </div>
          </div>
        </div>
      </form>
      <div class="credit-pack-details-container" id="newCreditPackTicketDetailsContainer" style="display: none">
        <h3 class="text-xl text-bw-800">New Credit Pack Ticket Details</h3>
        <div class="table-responsive">
          <table class="table bordered bw new-ticket-table">
            <thead>
              <tr>
                <th>Registration TXID</th>
                <th>
                  SHA3-256 Hash of Credit Pack Purchase Request Fields
                </th>
                <th>Responding Supernode PastelID</th>
                <th>Outcome</th>
              </tr>
            </thead>
            <tbody id="newCreditPackTicketDetails">
              <!-- New ticket details will be dynamically populated here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Select Existing Credit Pack Ticket</h2>
      <div class="relative text-bw-700 table-responsive">
        <table class="table bordered bw">
          <thead>
            <tr>
              <th class="select-column">Select</th>
              <th class="initial-credits-column">Initial Credits in Pack</th>
              <th class="current-credit-balance-column">
                Current Credit Balance
              </th>
              <th class="tracking-address-column">Tracking Address</th>
              <th>Blockheight Registered</th>
              <th>Credit Pack Registration TXID</th>
            </tr>
          </thead>
          <tbody id="creditPackTicketTableBody">
            <!-- Rows will be dynamically populated here -->
          </tbody>
        </table>
        <div class="flex items-center gap-4 mt-4">
          <button id="refreshButton" class="btn success outline p-4 relative">
            Manually Refresh Credit Pack Tickets
            <span class="loader hidden absolute inset-0 flex items-center justify-center">
              <div class="is-loading"></div>
            </span>
          </button>
          <div class="btn is-loading hidden" id="loadingMessage">
            Loading...
          </div>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Create New Inference Request</h2>
      <form id="inferenceRequestForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="inferenceType">Inference Type</label>
          <div class="relative text-bw-700">
            <select id="inferenceType" class="select w-full">
              <option value="">Select an inference type</option>
              <option value="text_completion">Text Completion</option>
              <option value="ask_question_about_an_image">
                Ask a Question About an Image
              </option>
              <option value="text_to_image">Image Generation</option>
              <option value="embedding_document">Embedding Document</option>
              <option value="embedding_audio">
                Audio Transcript and Embedding
              </option>
            </select>
          </div>
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="model">Model/Service</label>
          <div class="relative text-bw-700">
            <select id="model" class="select w-full">
              <option value="">Select a model/service</option>
              <option value="groq-llama3-70b-8192" selected></option>
              <option value="claude3-opus">Claude3-Opus</option>
            </select>
          </div>
        </div>

        <div id="textCompletionSettings" class="col-span-full">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="prompt">Prompt</label>
            <textarea class="input w-full" id="prompt" rows="5" placeholder="Enter your prompt">
Write me a Shakespeare-style sonnet about Pastel Network and how it's really decentralized and powerful. </textarea>
          </div>
        </div>
        <div class="hidden col-span-full" id="modelAdvancedSettingsSection">
          <div>
            <button type="button" class="btn success outline" id="advancedSettingsButton">Show advanced
              settings</button>
          </div>
          <div id="modelAdvancedSettingsContent" class="hidden mt-4">
            <div id="modelParametersContainer" class="col-span-full"></div>
          </div>
        </div>

        <div id="imageGenerationSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imagePrompt">Image Prompt</label>
            <textarea class="input w-full" id="imagePrompt" rows="5" placeholder="Enter your image prompt">
A picture of a clown holding a sign that says PASTEL</textarea>
          </div>
        </div>

        <div id="embeddingDocumentSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="embeddingDocumentFile">Document to Embed</label>
            <input type="file" class="input w-full" id="embeddingDocumentFile" accept=".pdf,.doc,.docx,.txt" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="document_semantic_query_string">Semantic Query String
              (Optional):</label>
            <input class="input w-full" id="document_semantic_query_string" type="text"
              placeholder="Enter your query" />
          </div>
        </div>

        <div id="embeddingAudioSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="embeddingAudioFile">Audio File to Transcribe and
              Embed</label>
            <input type="file" class="input w-full" id="embeddingAudioFile" accept="audio/*" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="audio_semantic_query_string">Semantic Query String
              (Optional):</label>
            <input class="input w-full" id="audio_semantic_query_string" type="text" placeholder="Enter your query" />
          </div>
        </div>

        <div id="askQuestionAboutImageSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imageFile">Image File</label>
            <input type="file" class="input w-full" id="imageFile" accept="image/*" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="question">Question</label>
            <input class="input w-full" id="question" type="text" placeholder="Enter your question" />
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-bw-700 font-bold mb-2" for="maxCost">Maximum Cost (Credits)</label>
          <input class="input w-full" id="maxCost" type="text" placeholder="Enter maximum cost" value="200"
            data-raw-value="200" />
          <span id="maxCostFormatted" class="text-bw-700"></span>
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <div class="flex items-center gap-2">
              <button class="btn success outline" type="submit" style="width: 180px">
                Create Inference Request
              </button>
            </div>
            <div class="prompt success xs" id="currentStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="currentStatus">Current Status:</label>
              <div class="content p-2" id="currentStatus"></div>
            </div>
          </div>
        </div>

        <div id="inferenceRequestResult"></div>
      </form>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 has-border rounded-xl bg-white shadow-md"
      style="height: 1000px; overflow-y: auto">
      <div class="lg:col-span-1 flex flex-col">
        <h2 class="text-2xl mb-4 text-bw-800">
          View Previous Inference Requests
        </h2>
        <div id="previousRequestsList" class="bg-gray-100 p-4 rounded-lg overflow-y-auto flex-grow"
          style="max-height: 1200px">
          <!-- List of previous inference requests will be dynamically populated here -->
        </div>
        <button id="exportRequestsButton" class="btn success outline mt-4 flex items-center self-start">
          💾 Export all Saved Inference Requests
        </button>
      </div>
      <div id="requestPreview" class="lg:col-span-2 bg-gray-50 p-4 rounded-lg">
        <!-- Preview of selected inference request will be shown here -->
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 p-4 has-border rounded-xl bg-white shadow-md">
      <div>
        <h2 class="text-2xl mb-4 text-bw-800">
          Send and Receive Messages using PastelIDs
        </h2>
        <form id="sendMessageForm" class="grid grid-cols-1 gap-4">
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="toPastelID">Recipient Pastel ID</label>
            <input class="input w-full" id="toPastelID" type="text" placeholder="Enter recipient Pastel ID"
              value="jXXiVgtFzLto4eYziePHjjb1hj3c6eXdABej5ndnQ62B8ouv1GYveJaD5QUMfainQM3b4MTieQuzFEmJexw8Cr" required />
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="messageBody">Message Body</label>
            <textarea class="input w-full" id="messageBody" rows="5" placeholder="Enter your message" required>
Hello, this is a brand 🍉 NEW test message from a regular user!</textarea>
          </div>
          <div class="flex justify-between">
            <button class="btn success outline" type="submit">
              Send Message
            </button>
          </div>
        </form>
      </div>
      <div>
        <h2 class="text-2xl mb-4">Received Messages</h2>
        <div id="receivedMessages" class="bg-bw-50 p-4 rounded-xl">
          <!-- Received messages will be dynamically populated here -->
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl">
      <h2 class="text-2xl">Manage Wallet</h2>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importPrivKey">
          Import Private Key
          <span class="tooltip" data-tooltip="Import a private key into your wallet.">&#9432;</span>
        </label>
        <input id="importPrivKey" class="input w-full" type="text" placeholder="Enter private key" />
        <div class="flex items-center gap-2 mt-2">
          <button id="importPrivKeyButton" class="btn success outline">
            Import Private Key
          </button>
          <div class="hidden" id="importPrivKeyLoading"></div>
        </div>
      </div>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importWallet">
          Import Wallet
          <span class="tooltip" data-tooltip="Import a wallet file into your wallet.">&#9432;</span>
        </label>
        <input id="importWallet" class="input w-full" type="file" accept=".dat" />
        <div class="flex items-center gap-2 mt-2">
          <button id="importWalletButton" class="btn success outline mt-2">
            Import Wallet
          </button>
          <div class="hidden" id="importWalletLoading"></div>
        </div>
      </div>
      <label class="block text-bw-700 font-bold mb-2" for="listAddressAmountsButton">
        Misc Functions:
      </label>

      <div class="mb-4">
        <div class="flex items-center gap-2">
          <button id="listAddressAmountsButton" class="btn success outline">
            List Address Amounts
            <span class="tooltip" data-tooltip="List the amounts associated with each address in your wallet.">
              &#9432;
            </span>
          </button>
          <div class="hidden" id="listAddressAmountsLoading"></div>
        </div>

        <div id="addressAmountsContainer" class="mt-4" style="display: none; position: relative">
          <h2 class="text-2xl text-bw-800">Address Amounts:</h2>
          <button id="copyAddressAmountsButton" class="btn success outline" style="
                position: absolute;
                top: -1.5rem;
                right: 0.5rem;
                display: none;
              ">
            📋
          </button>
          <div class="table-responsive">
            <table id="addressAmountsTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <div class="flex items-center gap-2">
          <button id="getWalletInfoButton" class="btn success outline">
            Get Wallet Info
            <span class="tooltip" data-tooltip="Retrieve information about your wallet.">
              &#9432;
            </span>
          </button>
          <div class="hidden" id="getWalletInfoLoading"></div>
        </div>

        <div id="walletInfoContainer" class="mt-4" style="display: none; position: relative">
          <h2 class="text-2xl text-bw-800">Wallet Info:</h2>
          <button id="copyWalletInfoButton" class="btn success outline" style="
                position: absolute;
                top: -1.5rem;
                right: 0.5rem;
                display: none;
              ">
            📋
          </button>
          <div class="table-responsive">
            <table id="walletInfoTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <button id="clearLocalStorageButton" class="btn success outline">
          Clear Inference Client Local Storage
          <span class="tooltip" data-tooltip="Clear all local storage data for this page.">
            &#9432;
          </span>
        </button>
      </div>
    </div>
    <button onclick="toggleTerminal()" class="btn success outline mt-4">
      Toggle Terminal
    </button>

    <h2 class="text-2xl mt-5">Terminal</h2>

    <div id="terminal" class="bg-gray-900 text-white p-4 rounded-xl"></div>
    <div class="flex justify-between items-center mb-4">
      <button id="exportTerminalButton" class="btn success outline">
        Export Terminal Session Text
      </button>
    </div>

    <div class="bg-bw-800 text-bw-50 py-6">
      <div class="container mx-auto px-4">
        <p class="text-center">
          &copy; 2024 Pastel Inference Client UI. All rights reserved.
        </p>
      </div>
    </div>

    <script>
      const MESSAGING_TIMEOUT_IN_SECONDS = 60;
      const LOADING_MESSAGE = "Wait while data is loaded...";
      const STORAGE_KEY = "validCreditPackTickets";
      const STORAGE_TIMESTAMP_KEY = "creditPackTicketsTimestamp";
      const REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      function formatNumberWithCommas(number) {
        return number.toLocaleString();
      }

      function parseAndFormatNumber(value) {
        const number = parseFloat(value.replace(/,/g, ""));
        return isNaN(number) ? value : formatNumberWithCommas(number);
      }

      function handleInputChange(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const rawValue = inputElement.value.replace(/,/g, "");
        inputElement.setAttribute("data-raw-value", rawValue);

        if (["numCredits", "maxPerCreditPrice"].includes(inputElement.id)) {
          const numCredits = Number(
            document.getElementById("numCredits").value.replace(/,/g, "")
          );
          const maxPerCreditPrice = Number(
            document
              .getElementById("maxPerCreditPrice")
              .value.replace(/,/g, "")
          );
          let maxTotalPrice = numCredits * maxPerCreditPrice;
          maxTotalPrice = isNaN(maxTotalPrice)
            ? 0
            : formatNumberWithCommas(maxTotalPrice);
          const elMaxTotalPrice = document.getElementById("maxTotalPrice");
          elMaxTotalPrice.value = maxTotalPrice;
          elMaxTotalPrice.setAttribute(
            "data-raw-value",
            maxTotalPrice.replace(/,/g, "")
          );
        }
      }

      function handleInputBlur(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const formattedValue = parseAndFormatNumber(inputElement.value);
        inputElement.value = formattedValue;
      }

      async function fetchImageSize(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob.size;
      }

      async function getMyPslAddressWithLargestBalance() {
        try {
          const response = await axios.get(
            "/get-my-psl-address-with-largest-balance"
          );
          return response.data.result;
        } catch (error) {
          console.error(
            "Error retrieving PSL address with largest balance:",
            error
          );
          return "";
        }
      }

      function parseAndFormat(value) {
        try {
          if (typeof value === "string") {
            // Check if the JSON string is already formatted
            if (value.includes("\n")) {
              return value;
            }
            // Parse JSON string to handle it properly
            const parsedValue = JSON.parse(value);
            return JSON.stringify(parsedValue, null, 4); // Indent JSON string
          }
          return JSON.stringify(value, null, 4); // Format other values
        } catch (error) {
          return value; // Return original value if parsing fails
        }
      }

      function prettyJSON(data) {
        if (data instanceof Map) {
          data = Object.fromEntries(data); // Convert Map to object
        }
        if (
          Array.isArray(data) ||
          (typeof data === "object" && data !== null)
        ) {
          const formattedData = {};
          for (const [key, value] of Object.entries(data)) {
            if (typeof value === "string" && key.endsWith("_json")) {
              formattedData[key] = parseAndFormat(value);
            } else if (typeof value === "object" && value !== null) {
              formattedData[key] = prettyJSON(value); // Recurse for nested objects
            } else {
              formattedData[key] = value; // Handle other types
            }
          }
          return JSON.stringify(formattedData, null, 4); // Pretty print the object
        } else if (typeof data === "string") {
          return parseAndFormat(data); // Handle strings separately
        }
        return data; // Return data as is for other types
      }

      function sanitizeJSON(jsonString) {
        return jsonString.replace(/[^\x20-\x7E]+/g, ""); // Remove non-printable ASCII characters
      }

      function fallbackParseResult(result) {
        // If the result starts with {"text": ", strip it and the ending }
        if (result.startsWith(' {"text": "')) {
          result = result.slice(10); // Remove the prefix {"text": "
          const endIndex = result.indexOf('"}');
          if (endIndex !== -1) {
            result = result.slice(0, endIndex); // Remove the closing }
          }
        }

        // Remove anything including and after "} {"prompt":" from the end of the string
        const promptPattern = /"} {"prompt":".*$/;
        result = result.replace(promptPattern, "");

        return result;
      }

      async function fetchValidPastelIDs() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result.map((ticket) => ticket.ticket.pastelID);
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      function formatAndHighlightMessage(message) {
        const parts = message.split(/(\{[\s\S]*?\})/);
        return parts
          .map((part) => {
            try {
              if (part.startsWith("{") && part.endsWith("}")) {
                const parsed = JSON.parse(part);
                const formatted = prettyJSON(parsed);
                return `<pre><code class="json">${hljs.highlight(formatted, {
                  language: "json",
                  ignoreIllegals: true,
                }).value
                  }</code></pre>`;
              }
            } catch (e) {
              // If parsing fails, fall through to return the part as plain text
            }
            return `<span>${part}</span>`;
          })
          .join("");
      }

      function logCreateTicketStatusMessage(message, container) {
        if (message.includes("ECONNREFUSED")) return;
        container.innerHTML = ""; // Clear previous log messages
        const logElement = document.createElement("div");
        logElement.style.fontFamily = "Montserrat, sans-serif";
        logElement.innerHTML = formatAndHighlightMessage(message);
        container.appendChild(logElement);
        container.scrollTop = container.scrollHeight; // Scroll to bottom
      }

      function logStatusMessage(message) {
        if (message.includes("ECONNREFUSED")) return;
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.style.fontFamily = "Montserrat, sans-serif";
        currentStatus.style.whiteSpace = "pre-wrap"; // Ensure wrapping
        currentStatus.innerHTML = formatAndHighlightMessage(message);
      }

      function abbreviateJSON(jsonString, maxLength) {
        if (jsonString.length <= maxLength) return jsonString;
        const abbreviated = jsonString.slice(0, maxLength) + "...";
        const openBraces =
          (jsonString.match(/{/g) || []).length -
          (abbreviated.match(/{/g) || []).length;
        const openBrackets =
          (jsonString.match(/\[/g) || []).length -
          (abbreviated.match(/\[/g) || []).length;
        return (
          abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets)
        );
      }

      function logActionWithPayload(action, payloadName, jsonPayload) {
        const maxPayloadLength = 10000;
        let formattedPayload = prettyJSON(jsonPayload);

        // Truncate file contents in the payload
        if (typeof formattedPayload === 'string') {
          const fileContentRegex = /"(document|audio|image)":\s*"([^"]+)"/g;
          formattedPayload = formattedPayload.replace(fileContentRegex, (match, key, value) => {
            if (value.length > 100) {
              return `"${key}": "${value.substring(0, 100)}..."`;
            }
            return match;
          });
        }

        if (formattedPayload.length > maxPayloadLength) {
          formattedPayload = abbreviateJSON(formattedPayload, maxPayloadLength);
        }
        logger.info(`Now ${action} ${payloadName} with payload:\n${formattedPayload}`);
      }

      async function setSelectedPastelIDAndPassphrase(selectedPastelID) {
        let storedPassphrase = localStorage.getItem(selectedPastelID);

        try {
          const response = await axios.post("/check-pastel-id-validity", { pastelID: selectedPastelID });
          const isValid = response.data.isValid;

          if (!isValid) {
            console.log(`PastelID ${selectedPastelID} is not valid. Removing from localStorage.`);
            localStorage.removeItem(selectedPastelID);
            updatePastelIDUI();
            return;
          }

          if (!storedPassphrase) {
            const dialogHtml = `
        <div style="background-color: rgba(0, 0, 0, 0.5); position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center;">
          <div style="background-color: white; padding: 20px; border-radius: 5px; text-align: center;">
            <h2 style="margin-bottom: 10px;">Enter passphrase for PastelID:</h2>
            <p style="font-weight: bold; margin-bottom: 10px;">${selectedPastelID}</p>
            <input type="password" id="passphraseInput" class="input w-full" style="margin-bottom: 10px;" placeholder="Enter password">
            <div>
              <button id="submitPassphrase" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">Submit</button>
            </div>
          </div>
        </div>
      `;

            const dialog = document.createElement("div");
            dialog.innerHTML = dialogHtml;
            document.body.appendChild(dialog);

            return new Promise((resolve) => {
              const submitButton = dialog.querySelector("#submitPassphrase");
              const passphraseInput = dialog.querySelector("#passphraseInput");

              submitButton.addEventListener("click", async () => {
                const inputPassphrase = passphraseInput.value;
                if (inputPassphrase) {
                  try {
                    localStorage.setItem(
                      selectedPastelID,
                      btoa(inputPassphrase)
                    );
                    storedPassphrase = btoa(inputPassphrase);
                    dialog.remove();
                    await postPassphrase(selectedPastelID, storedPassphrase);
                    resolve();
                  } catch (error) {
                    console.error("Error handling passphrase:", error);
                  }
                } else {
                  console.error("No passphrase entered");
                }
              });
            });
          } else {
            await postPassphrase(selectedPastelID, storedPassphrase);
          }
        } catch (error) {
          console.error("Error checking PastelID validity:", error);
        }
      }


      function updatePastelIDUI() {
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const userPastelID = document.getElementById("userPastelID");

        // Remove the invalid PastelID from the dropdown
        Array.from(pastelIDDropdown.options).forEach(option => {
          if (!localStorage.getItem(option.value)) {
            pastelIDDropdown.remove(option.index);
          }
        });

        // Update the displayed PastelID
        if (pastelIDDropdown.options.length > 0) {
          userPastelID.textContent = pastelIDDropdown.value;
        } else {
          userPastelID.textContent = "No valid PastelID available";
        }
      }


      async function postPassphrase(pastelID, encodedPassphrase) {
        try {
          await axios.post("/set-pastel-id-passphrase", {
            pastelID: pastelID,
            passphrase: atob(encodedPassphrase),
          });

          // Fetch the model menu after setting the PastelID and passphrase
          await fetchModelMenu();

          // Fetch received messages after setting the PastelID and passphrase
          await fetchReceivedMessages();
        } catch (error) {
          console.error("Error setting PastelID and passphrase:", error);
        }
      }

      function togglePastelIDDropdown() {
        const dropdown = document.getElementById("pastelIDDropdown");
        dropdown.classList.toggle("hidden");
        document
          .getElementById("pastelIDDropdownContainer")
          .classList.toggle("hidden");
      }

      function updatePastelIDSelection() {
        const selectedID = document.getElementById("pastelIDDropdown").value;
        document.getElementById("userPastelID").textContent =
          selectedID || "No PastelID selected";
      }

      async function checkCreditPackTicketInfo(txid) {
        try {
          const response = await axios.get(`/credit-pack-info/${txid}`);
          const { requestResponse, requestConfirmation, balanceInfo } =
            response.data;
          document.getElementById("requestResponse").textContent =
            JSON.stringify(requestResponse, null, 2);
          document.getElementById("requestConfirmation").textContent =
            JSON.stringify(requestConfirmation, null, 2);
          document.getElementById("currentCreditBalance").textContent =
            balanceInfo.current_credit_balance;
          document.getElementById("numberOfTransactions").textContent =
            balanceInfo.number_of_confirmation_transactions;
        } catch (error) {
          console.error("Error checking credit pack ticket info:", error);
          document.getElementById("requestResponse").textContent =
            "Failed to load credit pack info";
          document.getElementById("requestConfirmation").textContent = "";
          document.getElementById("currentCreditBalance").textContent = "";
          document.getElementById("numberOfTransactions").textContent = "";
        }
      }

      function getAddressURL(address) {
        let baseURL = "https://explorer.pastel.network/address/";
        if (address.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/address/";
        } else if (address.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/address/";
        }
        return `${baseURL}${address}`;
      }

      function getTxidURL(trackingAddress, txid) {
        let baseURL = "https://explorer.pastel.network/tx/";
        if (trackingAddress.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/tx/";
        } else if (trackingAddress.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/tx/";
        }
        return `${baseURL}${txid}`;
      }

      async function listPastelIDTickets() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result;
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      async function checkTrackingAddresses() {
        try {
          const response = await fetch("/list-address-amounts");
          if (!response.ok) {
            throw new Error("Failed to fetch address amounts");
          }
          const data = await response.json();
          const walletAddresses = Object.keys(data.result);

          const trackingAddresses =
            document.querySelectorAll(".tracking-address");
          trackingAddresses.forEach((element) => {
            const address = element.textContent.trim();
            if (walletAddresses.includes(address)) {
              element.classList.add("valid-address");
              element.classList.remove("invalid-address");
            } else {
              element.classList.add("invalid-address");
              element.classList.remove("valid-address");
            }
          });
        } catch (error) {
          console.error("Error checking tracking addresses:", error.message);
        }
      }

      async function getMyValidCreditPacks(forceRefresh = false) {
        console.log(
          "getMyValidCreditPacks function called with forceRefresh:",
          forceRefresh
        );
        const loadingMessage = document.getElementById("loadingMessage");
        const tableBody = document.getElementById(
          "creditPackTicketTableBody"
        );
        loadingMessage.style.display = "block";

        let tooltip = document.getElementById("credit-pack-tooltip");
        if (!tooltip) {
          tooltip = document.createElement("div");
          tooltip.id = "credit-pack-tooltip";
          tooltip.className =
            "hidden fixed z-50 p-3 bg-white text-black rounded-lg shadow-lg border border-gray-300 transition-opacity duration-300 opacity-0 max-w-5xl text-xs";
          tooltip.style.pointerEvents = "none";
          document.body.appendChild(tooltip);
        }

        try {
          let validCreditPackTickets = [];
          const now = new Date().getTime();

          if (!forceRefresh) {
            const savedData = localStorage.getItem("validCreditPackTickets");
            const savedTimestamp = localStorage.getItem(
              "validCreditPackTicketsTimestamp"
            );

            if (
              savedData &&
              savedTimestamp &&
              now - savedTimestamp < 300000
            ) {
              validCreditPackTickets = JSON.parse(savedData);
            } else {
              const response = await axios.get("/get-my-valid-credit-packs");
              validCreditPackTickets = response.data.success
                ? response.data.result
                : [];
              localStorage.setItem(
                "validCreditPackTickets",
                JSON.stringify(validCreditPackTickets)
              );
              localStorage.setItem("validCreditPackTicketsTimestamp", now);
            }
          } else {
            const response = await axios.get("/get-my-valid-credit-packs");
            validCreditPackTickets = response.data.success
              ? response.data.result
              : [];
            localStorage.setItem(
              "validCreditPackTickets",
              JSON.stringify(validCreditPackTickets)
            );
            localStorage.setItem("validCreditPackTicketsTimestamp", now);
          }

          validCreditPackTickets = validCreditPackTickets.filter(
            (ticket) =>
              typeof ticket.credit_pack_current_credit_balance === "number" &&
              ticket.credit_pack_current_credit_balance > 0
          );

          let highestBalanceTicket = validCreditPackTickets.reduce(
            (max, ticket) =>
              ticket.credit_pack_current_credit_balance >
                (max?.credit_pack_current_credit_balance || 0)
                ? ticket
                : max,
            null
          );

          tableBody.innerHTML = "";

          const displayedColumns = [
            "credit_pack_registration_txid",
            "requested_initial_credits_in_credit_pack",
            "credit_pack_current_credit_balance",
            "credit_usage_tracking_psl_address",
            "credit_purchase_request_confirmation_pastel_block_height",
          ];

          for (const ticket of validCreditPackTickets) {
            const row = document.createElement("tr");
            row.className =
              "hover:bg-gray-100 transition-colors duration-200 cursor-pointer";

            const tooltipContent = Object.entries(ticket)
              .filter(([key]) => !displayedColumns.includes(key))
              .map(
                ([key, value]) => `
          <div class="flex justify-between py-1">
            <span class="font-semibold text-gray-800 mr-2 whitespace-nowrap">${key.replace(
                  /_/g,
                  " "
                )}:</span>
            <span class="text-gray-700">${value}</span>
          </div>
        `
              )
              .join("");

            let hoverTimeout;

            row.addEventListener("mouseenter", (e) => {
              hoverTimeout = setTimeout(() => {
                tooltip.innerHTML = tooltipContent;

                // Calculate position to keep tooltip within viewport and closer to the cursor
                const tooltipRect = tooltip.getBoundingClientRect();
                const xPos = Math.min(
                  e.clientX + 15,
                  window.innerWidth - tooltipRect.width - 10
                );
                const yPos = Math.min(
                  e.clientY + 15,
                  window.innerHeight - tooltipRect.height - 10
                );

                tooltip.style.left = `${xPos}px`;
                tooltip.style.top = `${yPos}px`;
                tooltip.classList.remove("hidden");
                setTimeout(() => {
                  tooltip.style.opacity = 1;
                }, 50);
              }, 300);
            });

            row.addEventListener("mousemove", (e) => {
              const tooltipRect = tooltip.getBoundingClientRect();
              const xPos = Math.min(
                e.clientX + 15,
                window.innerWidth - tooltipRect.width - 10
              );
              const yPos = Math.min(
                e.clientY + 15,
                window.innerHeight - tooltipRect.height - 10
              );

              tooltip.style.left = `${xPos}px`;
              tooltip.style.top = `${yPos}px`;
            });

            row.addEventListener("mouseleave", () => {
              clearTimeout(hoverTimeout);
              tooltip.style.opacity = 0;
              setTimeout(() => {
                tooltip.classList.add("hidden");
              }, 300);
            });

            const radioCell = document.createElement("td");
            const radioInput = document.createElement("input");
            radioInput.type = "radio";
            radioInput.name = "creditPackTicket";
            radioInput.value = ticket.requesting_end_user_pastelid;
            radioInput.dataset.txid = ticket.credit_pack_registration_txid;
            radioCell.appendChild(radioInput);
            row.appendChild(radioCell);

            const initialCreditsCell = document.createElement("td");
            initialCreditsCell.classList.add("truncate");
            initialCreditsCell.textContent = formatNumberWithCommas(
              ticket.requested_initial_credits_in_credit_pack
            );
            row.appendChild(initialCreditsCell);

            const currentCreditsCell = document.createElement("td");
            currentCreditsCell.classList.add("truncate");
            currentCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_current_credit_balance
            );
            row.appendChild(currentCreditsCell);

            const trackingAddressCell = document.createElement("td");
            trackingAddressCell.classList.add("truncate", "tracking-address");
            const addressLink = document.createElement("a");
            addressLink.href = `https://explorer.pastel.network/address/${ticket.credit_usage_tracking_psl_address}`;
            addressLink.target = "_blank";
            addressLink.textContent =
              ticket.credit_usage_tracking_psl_address;
            trackingAddressCell.appendChild(addressLink);
            row.appendChild(trackingAddressCell);

            const blockheightCell = document.createElement("td");
            blockheightCell.classList.add("truncate");
            blockheightCell.textContent = formatNumberWithCommas(
              ticket.credit_purchase_request_confirmation_pastel_block_height
            );
            row.appendChild(blockheightCell);

            const creditPackRegistrationTxidCell =
              document.createElement("td");
            creditPackRegistrationTxidCell.classList.add("truncate");
            const txLink = document.createElement("a");
            txLink.href = `https://explorer.pastel.network/tx/${ticket.credit_pack_registration_txid}`;
            txLink.target = "_blank";
            txLink.textContent = ticket.credit_pack_registration_txid;
            creditPackRegistrationTxidCell.appendChild(txLink);
            row.appendChild(creditPackRegistrationTxidCell);

            tableBody.appendChild(row);

            if (ticket === highestBalanceTicket) {
              radioInput.checked = true;
              row.classList.add("bg-gray-200", "selected-row");
            }
          }

          handleCreditPackSelection();
        } catch (error) {
          console.error("Error retrieving valid credit pack tickets:", error);
        } finally {
          loadingMessage.style.display = "none";
        }
      }

      function showLoading(id) {
        if (!id) {
          return;
        }
        const loaderContainer = document.getElementById(id);
        if (!loaderContainer) {
          return;
        }
        loaderContainer.innerHTML = "";
        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader);
        loaderContainer.classList.remove("hidden");
      }

      function hideLoading(id) {
        if (!id) {
          return;
        }
        const loaderContainer = document.getElementById(id);
        if (!loaderContainer) {
          return;
        }
        loaderContainer.classList.add("hidden");
      }

      async function createNewCreditPackTicket(
        numCredits,
        maxTotalPrice,
        maxPerCreditPrice
      ) {
        const statusContainer = document.getElementById(
          "createTicketStatusContainer"
        );
        const statusContent = document.getElementById("createTicketStatus");
        const loaderContainer = document.getElementById("loaderContainer");

        if (!statusContainer || !statusContent || !loaderContainer) {
          console.error(
            "Status container, status content, or loader container element not found."
          );
          return;
        }

        statusContent.innerHTML = "";
        loaderContainer.innerHTML = "";

        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader);

        const newTicketDetailsContainer = document.getElementById(
          "newCreditPackTicketDetailsContainer"
        );
        const newTicketDetails = document.getElementById(
          "newCreditPackTicketDetails"
        );

        if (!newTicketDetailsContainer || !newTicketDetails) {
          console.error(
            "New ticket details container or new ticket details element not found."
          );
          return;
        }

        displayCreateTicketLoggerMessages = true;

        try {
          logCreateTicketStatusMessage(
            "Starting the creation of a new credit pack ticket...",
            statusContent
          );

          const desiredNumberOfCredits = numCredits;
          const amountOfPSLForTrackingTransactions = 10.0;
          const creditPriceCushionPercentage = 0.15;

          const estimatedTotalCostInPSLForCreditPackResponse =
            await axios.post("/estimate-credit-pack-cost", {
              desiredNumberOfCredits,
              creditPriceCushionPercentage,
            });

          const estimatedTotalCostInPSLForCreditPack =
            estimatedTotalCostInPSLForCreditPackResponse.data.result;

          if (estimatedTotalCostInPSLForCreditPack === undefined) {
            throw new Error(
              "Failed to estimate total cost for the credit pack"
            );
          }

          const amountToFundCreditTrackingAddress = Math.round(
            amountOfPSLForTrackingTransactions +
            estimatedTotalCostInPSLForCreditPack
          );

          const walletBalance = parseFloat(
            document
              .getElementById("walletBalance")
              .textContent.replace(/,/g, "")
          );
          if (amountToFundCreditTrackingAddress > walletBalance) {
            const insufficientFundsMessage = `The purchase of this credit pack would require ${amountToFundCreditTrackingAddress.toLocaleString()} PSL, but you only have ${walletBalance.toLocaleString()} PSL in your wallet. Please send at least ${(
              amountToFundCreditTrackingAddress - walletBalance
            ).toLocaleString()} more PSL to your wallet and try again. Alternatively, you can reduce the number of credits in the credit pack you are trying to purchase to ${Math.floor(
              walletBalance /
              (estimatedTotalCostInPSLForCreditPack / numCredits)
            ).toLocaleString()} credits instead of ${numCredits.toLocaleString()} credits.`;

            const errorMessageElement = document.createElement("div");
            errorMessageElement.classList.add(
              "text-red-800",
              "font-bold",
              "mt-4"
            );
            errorMessageElement.textContent = insufficientFundsMessage;
            statusContent.appendChild(errorMessageElement);

            console.error(insufficientFundsMessage);
            throw new Error(insufficientFundsMessage);
          }

          const response = await axios.post("/create-and-fund-new-address", {
            amount: amountToFundCreditTrackingAddress,
          });

          if (!response.data.success) {
            throw new Error(
              "Failed to create and fund new credit tracking address"
            );
          }

          const creditUsageTrackingPSLAddress =
            response.data.result.newCreditTrackingAddress;

          logCreateTicketStatusMessage(
            "Credit tracking address created and funded successfully.",
            statusContent
          );

          const ticketResponse = await axios.post(
            "/create-credit-pack-ticket",
            {
              numCredits,
              creditUsageTrackingPSLAddress,
              maxTotalPrice,
              maxPerCreditPrice,
            }
          );

          if (ticketResponse.data.success) {
            logCreateTicketStatusMessage(
              "Credit pack ticket created successfully.",
              statusContent
            );
            const result = ticketResponse.data.result;
            const formattedResult = prettyJSON(result);
            logCreateTicketStatusMessage(
              `Result: ${formattedResult}`,
              statusContent
            );

            newTicketDetails.innerHTML = `
        <tr>
          <td class="truncate">
            <a href="${getTxidURL(
              creditUsageTrackingPSLAddress,
              result.pastel_api_credit_pack_ticket_registration_txid
            )}" target="_blank">
              ${result.pastel_api_credit_pack_ticket_registration_txid}
            </a>
          </td>
          <td class="truncate">${result.sha3_256_hash_of_credit_pack_purchase_request_fields
              }</td>
          <td class="truncate">${result.responding_supernode_pastelid}</td>
          <td class="truncate">${result.credit_pack_confirmation_outcome_string
              }</td>
        </tr>
      `;

            newTicketDetailsContainer.style.display = "block";

            logCreateTicketStatusMessage(
              "Credit pack ticket created. Waiting for blockchain confirmation...",
              statusContent
            );

            pollCreditPackStatus(
              result.pastel_api_credit_pack_ticket_registration_txid
            );

            return result;
          } else {
            throw new Error("Failed to create new credit pack ticket");
          }
        } catch (error) {
          console.error(
            `Error creating new credit pack ticket: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
          );
          logCreateTicketStatusMessage(
            "Failed to create credit pack ticket. Please try again.",
            statusContent
          );
          throw error;
        } finally {
          creditPackLoader.remove();
          displayCreateTicketLoggerMessages = false;
        }
      }

      function pollCreditPackStatus(txid) {
        const pollInterval = 30000; // 30 seconds
        const maxAttempts = 20; // 10 minutes total
        let attempts = 0;

        const checkStatus = async () => {
          try {
            const response = await axios.get(`/credit-pack-status/${txid}`);
            if (response.data.confirmed) {
              logCreateTicketStatusMessage(
                "Credit pack ticket has been confirmed. Refreshing the table...",
                document.getElementById("createTicketStatus")
              );
              await getMyValidCreditPacks(true);
              logCreateTicketStatusMessage(
                "Credit pack ticket is now available for use.",
                document.getElementById("createTicketStatus")
              );
            } else {
              attempts++;
              if (attempts < maxAttempts) {
                logCreateTicketStatusMessage(
                  `Waiting for credit pack ticket confirmation... (Attempt ${attempts}/${maxAttempts})`,
                  document.getElementById("createTicketStatus")
                );
                setTimeout(checkStatus, pollInterval);
              } else {
                logCreateTicketStatusMessage(
                  "Credit pack ticket confirmation is taking longer than expected. It should appear soon. You can manually refresh the table to check.",
                  document.getElementById("createTicketStatus")
                );
              }
            }
          } catch (error) {
            console.error("Error checking credit pack status:", error);
            logCreateTicketStatusMessage(
              "An error occurred while checking the credit pack status. Please try refreshing the table manually.",
              document.getElementById("createTicketStatus")
            );
          }
        };

        checkStatus();
      }

      // Handle inference request stuff:
      let modelMenu = null;

      async function fetchModelMenu() {
        try {
          const response = await axios.get("/get-inference-model-menu");
          modelMenu = response.data.modelMenu;
          console.log("Model Menu:", modelMenu); // Debugging line, consider removing for production
          populateModelDropdown();
        } catch (error) {
          console.error("Error fetching model menu:", error);
          //displayError("Failed to load model menu. Please try again later.");
        }
      }

      function handleModelChange() {
        const selectedModelName = document.getElementById("model").value;
        const selectedModel = modelMenu.models.find(
          (model) => model.model_name === selectedModelName
        );

        if (selectedModel) {
          generateModelParameterFields(selectedModel);
        }
      }

      function generateModelParameterFields(selectedModel) {
        const modelAdvancedSettingsSection = document.getElementById("modelAdvancedSettingsSection");
        const modelParametersContainer = document.getElementById("modelParametersContainer");
        modelParametersContainer.innerHTML = "";
        const selectedInferenceType = document.getElementById("inferenceType").value;

        // Filter parameters based on the selected inference type
        const applicableParameters = selectedModel.model_parameters.filter(param => {
          const inferenceTypes = param.inference_types_parameter_applies_to;
          if (Array.isArray(inferenceTypes)) {
            return inferenceTypes.includes(selectedInferenceType);
          } else if (typeof inferenceTypes === 'string') {
            try {
              // Try parsing as JSON-like string (replacing single quotes with double quotes)
              const parsedTypes = JSON.parse(inferenceTypes.replace(/'/g, '"'));
              return Array.isArray(parsedTypes) && parsedTypes.includes(selectedInferenceType);
            } catch (e) {
              // If parsing fails, treat it as a comma-separated string
              return inferenceTypes.split(',').map(type => type.trim()).includes(selectedInferenceType);
            }
          }
          return false;
        });
        applicableParameters.forEach((param) => {
          const fieldContainer = document.createElement("div");
          fieldContainer.className = "mb-4";

          const labelText = param.description.split("[Optional]")[0].trim();
          const tooltipText = param.description.split("[Optional]")[1]?.trim().replace(/^\(|\)$/g, "") || "";

          const label = document.createElement("label");
          label.className = "block font-bold mb-2" + (param.description.includes("[Optional]") ? " text-bw-800" : "");
          label.htmlFor = param.name;
          label.textContent = labelText;
          fieldContainer.appendChild(label);

          if (tooltipText) {
            const tooltipSpan = document.createElement("span");
            tooltipSpan.className = "tooltip bw top";
            tooltipSpan.dataset.tooltip = tooltipText;
            const tooltipButton = document.createElement("button");
            tooltipButton.className = "tooltip-icon";
            tooltipButton.textContent = "ⓘ";
            tooltipSpan.appendChild(tooltipButton);
            label.appendChild(tooltipSpan);
          }

          const input = document.createElement("input");
          input.className = "input w-full";
          input.id = param.name;
          input.name = param.name;
          input.type = param.type === "float" || param.type === "int" ? "number" : "text";
          input.placeholder = `Enter ${param.description.toLowerCase()}`;
          input.value = param.default;

          if (param.name === "number_of_tokens_to_generate") {
            input.min = "1";
            input.max = "5000";
            input.step = "1";
          } else if (param.name === "temperature") {
            input.min = "0";
            input.max = "1";
            input.step = "0.01";
          } else if (param.name === "number_of_completions_to_generate") {
            input.min = "1";
            input.max = "10";
            input.step = "1";
          } else if (param.name === "grammar_file_string" || param.name === "query_string" || param.name === "corpus_identifier_string") {
            input.type = "text"; // Ensure it's a text input
          }

          fieldContainer.appendChild(input);
          modelParametersContainer.appendChild(fieldContainer);
        });

        if (applicableParameters.length) {
          modelAdvancedSettingsSection.classList.remove("hidden");
        } else {
          modelAdvancedSettingsSection.classList.add("hidden");
        }
      }

      function populateModelDropdown() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const modelSelect = document.getElementById("model");
        modelSelect.innerHTML =
          '<option value="">Select a model/service</option>';

        if (modelMenu) {
          if (selectedInferenceType === "ask_question_about_an_image") {
            const relevantModels = modelMenu.models.filter((model) =>
              model.supported_inference_type_strings.includes(
                selectedInferenceType
              )
            );

            relevantModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (relevantModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(relevantModels[0]);
            }
          } else {
            const filteredModels = modelMenu.models.filter(
              (model) =>
                model.supported_inference_type_strings &&
                model.supported_inference_type_strings.includes(
                  selectedInferenceType
                )
            );

            filteredModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (filteredModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(filteredModels[0]);
            }
          }
        }
      }

      function displayError(message) {
        // Implement user-friendly error handling/display mechanism
        alert(message); // Simplistic example, consider more sophisticated modal or notification systems
      }

      // Load inference request settings from localStorage
      function loadInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const storedSettings = localStorage.getItem(
          `inferenceRequestSettings_${selectedInferenceType}`
        );
        if (storedSettings) {
          const settings = JSON.parse(storedSettings);
          document.getElementById("model").value = settings.model || "";
          document.getElementById("prompt").value = settings.prompt || "";
          document.getElementById("maxCost").value = settings.maxCost || "";
          document.getElementById("imagePrompt").value =
            settings.imagePrompt || "";
        }
      }

      // Save inference request settings to localStorage
      function saveInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const settings = {
          model: document.getElementById("model").value,
          prompt: document.getElementById("prompt").value,
          maxCost: document.querySelector("#maxCost").dataset.rawValue,
          imagePrompt: document.getElementById("imagePrompt").value,
        };
        localStorage.setItem(
          `inferenceRequestSettings_${selectedInferenceType}`,
          JSON.stringify(settings)
        );
      }

      async function pollWalletAndPastelIDStatus(pastelID) {
        const pollInterval = 30000; // 30 seconds
        const maxAttempts = 20; // 10 minutes total
        let attempts = 0;

        const checkStatus = async () => {
          try {
            const response = await axios.get(
              `/check-pastel-id-status/${pastelID}`
            );
            const walletResponse = await axios.get("/get-wallet-info");
            const walletBalance = walletResponse.data.result.balance;
            if (response.data.registered && walletBalance > 0) {
              displayMessage(
                "Your PastelID has been registered and your wallet has been funded. The page will refresh shortly.",
                false,
                "createPastelIDMessageContainer"
              );
              setTimeout(() => location.reload(), 5000);
            } else {
              attempts++;
              if (attempts < maxAttempts) {
                let message =
                  "PastelID registration and wallet funding in progress...";
                if (response.data.registered) {
                  message =
                    "PastelID registered. Waiting for wallet to be funded...";
                } else if (walletBalance > 0) {
                  message =
                    "Wallet funded. Waiting for PastelID registration...";
                }
                displayMessage(
                  `${message} (Attempt ${attempts}/${maxAttempts})`,
                  false,
                  "createPastelIDMessageContainer"
                );
                setTimeout(checkStatus, pollInterval);
              } else {
                displayMessage(
                  "The process is taking longer than expected. Please refresh the page in a few minutes.",
                  false,
                  "createPastelIDMessageContainer"
                );
              }
            }
          } catch (error) {
            console.error(
              "Error checking PastelID and wallet status:",
              error
            );
            displayMessage(
              "An error occurred while checking your PastelID and wallet status. Please refresh the page in a few minutes.",
              false,
              "createPastelIDMessageContainer"
            );
          }
        };

        checkStatus();
      }
      createPastelIDForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const passphrase = document.getElementById(
          "newPastelIDPassphrase"
        ).value;
        if (passphrase.length < 6) {
          displayMessage(
            "Passphrase must be at least 6 characters long.",
            false,
            "createPastelIDMessageContainer"
          );
          return;
        }
        try {
          displayLoading(true, "createPastelIDLoading");
          const response = await axios.post(
            "/create-and-register-pastel-id",
            {
              passphraseForNewPastelID: passphrase,
            }
          );
          displayLoading(false, "createPastelIDLoading");
          if (response.data.success) {
            displayMessage(
              `PastelID creation initiated. Your new PastelID is ${response.data.PastelID}. Please wait while it's being registered on the blockchain...`,
              true,
              "createPastelIDMessageContainer"
            );
            localStorage.setItem(response.data.PastelID, btoa(passphrase));
            pollWalletAndPastelIDStatus(response.data.PastelID);
          } else {
            displayMessage(
              response.data.message,
              false,
              "createPastelIDMessageContainer"
            );
          }
        } catch (error) {
          displayLoading(false, "createPastelIDLoading");
          console.error("Error creating PastelID:", error);
          displayMessage(
            "Failed to create PastelID. Please try again.",
            false,
            "createPastelIDMessageContainer"
          );
        }
      });

      importPastelIDButton.addEventListener("click", async () => {
        const pastelIDFile =
          document.getElementById("importPastelIDFile").files[0];
        if (!pastelIDFile) {
          displayMessage("Please select a PastelID file to import.", false);
          return;
        }
        showLoading("importPastelIDBLoading");
        const formData = new FormData();
        formData.append("pastelIDFile", pastelIDFile);
        try {
          const { network } = await getNetworkInfo();
          const response = await axios.post(
            `/import-pastel-id?network=${network}`,
            formData
          );
          if (response.data.success) {
            displayMessage("PastelID imported successfully!", true);
            location.reload(); // Refresh the page to update the UI
          } else {
            displayMessage(response.data.message, false);
          }
        } catch (error) {
          console.error("Error importing PastelID:", error);
          displayMessage(
            "Failed to import PastelID. Please try again.",
            false
          );
        }
        hideLoading("importPastelIDBLoading");
      });

      function displayLoading(show, id = null) {
        const loader = document.getElementById(id || "loaderContainer");
        if (show) {
          loader.innerHTML = '<div class="btn is-loading">Loading...</div>';
        } else {
          loader.innerHTML = "";
        }
      }

      (async function () {
        try {
          const myPslAddress = await getMyPslAddressWithLargestBalance();
          document.getElementById("myPslAddress").textContent = myPslAddress;
        } catch (error) {
          console.error(
            "Error displaying PSL address with largest balance:",
            error
          );
        }
      })();

      function displayMessage(message, isSuccess, id = null) {
        const messageContainer = document.getElementById(
          id || "messageContainer"
        );
        messageContainer.innerHTML = `<p class="${isSuccess ? "text-green-600" : "text-red-600"
          } font-bold text-lg">${message}</p>`;
        messageContainer.scrollIntoView({ behavior: "smooth" });
      }

      async function getNetworkInfo() {
        const response = await axios.get("/get-network-info");
        return response.data;
      }

      (async function () {
        try {
          // Check if there are any PastelIDs on initial load
          const pastelIDTickets = await listPastelIDTickets();
          if (pastelIDTickets.length === 0) {
            document
              .getElementById("pastelIDDropdownContainer")
              .classList.add("hidden");
            document
              .getElementById("changePastelIDButton")
              .classList.add("hidden");
            noPastelIDContainer.classList.remove("hidden");
          } else {
            const validPastelIDs = await fetchValidPastelIDs();
            const storedPastelIDs = Object.keys(localStorage);
            let hasPastelID = false;
            storedPastelIDs.forEach((pastelID) => {
              if (validPastelIDs.includes(pastelID)) {
                hasPastelID = true;
              }
            });
            if (!hasPastelID) {
              await setSelectedPastelIDAndPassphrase(
                pastelIDTickets[0].ticket.pastelID
              );
              location.reload();
            }
            noPastelIDContainer.classList.add("hidden");
            document
              .getElementById("pastelIDDropdownContainer")
              .classList.remove("hidden");
            document
              .getElementById("changePastelIDButton")
              .classList.remove("hidden");
          }
        } catch (error) {
          console.error("Error checking PastelIDs:", error);
        }
      })();

      document.addEventListener("DOMContentLoaded", async () => {
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const passphraseContainer = document.getElementById(
          "passphraseContainer"
        );
        const pastelIDPassphrase =
          document.getElementById("pastelIDPassphrase");
        const rememberPassphrase =
          document.getElementById("rememberPassphrase");
        const submitPassphraseButton = document.getElementById(
          "submitPassphraseButton"
        );
        const refreshButton = document.getElementById("refreshButton");

        async function fetchValidPastelIDs() {
          try {
            const response = await axios.get("/list-pastel-id-tickets", {
              params: { filter: "mine" },
            });
            return response.data.result.map(
              (ticket) => ticket.ticket.pastelID
            );
          } catch (error) {
            console.error("Error retrieving Pastel ID tickets:", error);
            return [];
          }
        }

        const validPastelIDs = await fetchValidPastelIDs();
        const storedPastelIDs = Object.keys(localStorage);

        storedPastelIDs.forEach((pastelID) => {
          if (validPastelIDs.includes(pastelID)) {
            const option = document.createElement("option");
            option.value = pastelID;
            option.textContent = pastelID;
            pastelIDDropdown.appendChild(option);
          }
        });

        pastelIDDropdown.addEventListener("change", async () => {
          const selectedPastelID = pastelIDDropdown.value;
          document.getElementById("userPastelID").textContent =
            selectedPastelID || "No PastelID selected";
          if (selectedPastelID) {
            const storedPassphrase = localStorage.getItem(selectedPastelID);
            if (storedPassphrase) {
              pastelIDPassphrase.value = atob(storedPassphrase);
              passphraseContainer.classList.add("hidden");
            } else {
              passphraseContainer.classList.remove("hidden");
            }
            await setSelectedPastelIDAndPassphrase(selectedPastelID);
          } else {
            passphraseContainer.classList.add("hidden");
          }
          refreshCreditPackTickets();
        });

        submitPassphraseButton.addEventListener("click", async () => {
          const selectedPastelID = pastelIDDropdown.value;
          const passphrase = pastelIDPassphrase.value;

          if (rememberPassphrase.checked) {
            const encryptedPassphrase = btoa(passphrase); // Simple base64 encoding
            localStorage.setItem(selectedPastelID, encryptedPassphrase);
          }

          try {
            const response = await axios.post("/set-pastel-id-passphrase", {
              pastelID: selectedPastelID,
              passphrase: passphrase,
            });

            if (response.data.success) {
              document.getElementById("messageContainer").innerText =
                "Successfully set PastelID and passphrase!";
            } else {
              document.getElementById("messageContainer").innerText =
                "Failed to set PastelID and passphrase.";
            }
          } catch (error) {
            console.error("Error setting PastelID and passphrase:", error);
            document.getElementById("messageContainer").innerText =
              "Failed to set PastelID and passphrase.";
          }
        });

        if (validPastelIDs.length === 0) {
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.add("hidden");
          document
            .getElementById("changePastelIDButton")
            .classList.add("hidden");
          noPastelIDContainer.classList.remove("hidden");
        } else {
          noPastelIDContainer.classList.add("hidden");
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.remove("hidden");
          document
            .getElementById("changePastelIDButton")
            .classList.remove("hidden");
        }

        // Call setSelectedPastelIDAndPassphrase based on the number of PastelIDs
        if (validPastelIDs.length === 1) {
          const pastelID = validPastelIDs[0];
          document.getElementById("userPastelID").textContent = pastelID;
          pastelIDDropdown.value = pastelID; // Set the selected value of the dropdown
          await setSelectedPastelIDAndPassphrase(pastelID);
        } else {
          const selectedPastelID = pastelIDDropdown.value;
          document.getElementById("userPastelID").textContent =
            selectedPastelID || "No PastelID selected";
          if (selectedPastelID) {
            await setSelectedPastelIDAndPassphrase(selectedPastelID);
          }
        }
      });

      async function refreshCreditPackTickets() {
        const refreshButton = document.getElementById("refreshButton");
        const loader = refreshButton.querySelector(".loader");
        const loadingMessage = document.getElementById("loadingMessage");

        loader.classList.remove("hidden");
        loadingMessage.classList.remove("hidden");

        await getMyValidCreditPacks(true);

        loader.classList.add("hidden");
        loadingMessage.classList.add("hidden");
      }

      // Add event listener for the refresh button
      document
        .getElementById("refreshButton")
        .addEventListener("click", refreshCreditPackTickets);

      // Handle inference type change
      const inferenceTypeSelect = document.getElementById("inferenceType");
      const textCompletionSettings = document.getElementById(
        "textCompletionSettings"
      );
      const imageGenerationSettings = document.getElementById(
        "imageGenerationSettings"
      );

      inferenceTypeSelect.addEventListener("change", () => {
        const selectedInferenceType =
          document.getElementById("inferenceType").value;
        const textCompletionSettings = document.getElementById(
          "textCompletionSettings"
        );
        const imageGenerationSettings = document.getElementById(
          "imageGenerationSettings"
        );
        const embeddingDocumentSettings = document.getElementById(
          "embeddingDocumentSettings"
        );
        const embeddingAudioSettings = document.getElementById(
          "embeddingAudioSettings"
        );
        const askQuestionAboutImageSettings = document.getElementById(
          "askQuestionAboutImageSettings"
        );

        textCompletionSettings.style.display = "none";
        imageGenerationSettings.style.display = "none";
        embeddingDocumentSettings.style.display = "none";
        embeddingAudioSettings.style.display = "none";
        askQuestionAboutImageSettings.style.display = "none";

        if (selectedInferenceType === "text_completion") {
          textCompletionSettings.style.display = "block";
        } else if (selectedInferenceType === "text_to_image") {
          imageGenerationSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_document") {
          embeddingDocumentSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_audio") {
          embeddingAudioSettings.style.display = "block";
        } else if (selectedInferenceType === "ask_question_about_an_image") {
          askQuestionAboutImageSettings.style.display = "block";
        }
        // Update the model dropdown and parameter fields
        populateModelDropdown();
        loadInferenceRequestSettings();
      });

      document
        .getElementById("model")
        .addEventListener("change", handleModelChange);

      document
        .getElementById("advancedSettingsButton")
        .addEventListener("click", handleAdvancedSettingsButtonChange);

      function handleAdvancedSettingsButtonChange() {
        const advancedSettingsButton = document.getElementById("advancedSettingsButton");
        const modelAdvancedSettingsContent = document.getElementById("modelAdvancedSettingsContent");
        if (modelAdvancedSettingsContent.classList.contains('hidden')) {
          advancedSettingsButton.innerHTML = 'Hide advanced settings';
        } else {
          advancedSettingsButton.innerHTML = 'Show advanced settings';
        }
        modelAdvancedSettingsContent.classList.toggle("hidden");
      }

      function handleCreditPackSelection() {
        const radioButtons = document.querySelectorAll(
          'input[name="creditPackTicket"]'
        );
        radioButtons.forEach((button) => {
          button.addEventListener("change", () => {
            document
              .querySelectorAll("#creditPackTicketTableBody tr")
              .forEach((row) => {
                row.classList.remove("bg-gray-200", "selected-row");
              });
            button.parentElement.parentElement.classList.add(
              "bg-gray-200",
              "selected-row"
            );
          });
        });
      }

      document
        .getElementById("copyAddressButton")
        .addEventListener("click", () => {
          const addressElement = document.getElementById("myPslAddress");
          const address = addressElement.textContent;

          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(address).then(() => {
              const tooltip = document.getElementById("copyAddressButton");
              tooltip.setAttribute(
                "data-tooltip",
                "Copied address to clipboard!"
              );

              setTimeout(() => {
                tooltip.setAttribute(
                  "data-tooltip",
                  "Copy address to clipboard"
                );
              }, 2000);
            });
          } else {
            const tempInput = document.createElement("input");
            tempInput.value = address;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand("copy");
            document.body.removeChild(tempInput);

            const tooltip = document.getElementById("copyAddressButton");
            tooltip.setAttribute(
              "data-tooltip",
              "Copied address to clipboard!"
            );

            setTimeout(() => {
              tooltip.setAttribute(
                "data-tooltip",
                "Copy address to clipboard"
              );
            }, 2000);
          }
        });

      document.addEventListener("DOMContentLoaded", () => {
        handleCreditPackSelection();
      });

      let displayInferenceRequestLoggerMessages = false;
      let displayCreateTicketLoggerMessages = false;

      async function saveInferenceRequestToLocalStorage(requestData) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        if (
          requestData.selectedInferenceType === "ask_question_about_an_image"
        ) {
          try {
            const imageFile = document.getElementById("imageFile").files[0];
            const compressedImage = await compressImage(imageFile);
            requestData.inputFields.image = compressedImage;
          } catch (error) {
            console.error("Error compressing image:", error);
          }
        } else if (
          requestData.selectedInferenceType === "embedding_document"
        ) {
          const fileInput = document.getElementById("embeddingDocumentFile");
          const originalFileName = fileInput.files[0].name;
          const fileHash = sha3_256(requestData.inputFields.document);
          requestData.inputFields.document_details = `
            <div>
              <p>Original File Name: ${originalFileName}</p>
              <p>File Hash: ${fileHash}</p>
            </div>
          `;
          delete requestData.inputFields.document;
        } else if (requestData.selectedInferenceType === "embedding_audio") {
          const fileHash = sha3_256(requestData.inputFields.audio);
          requestData.inputFields.fileHash = fileHash;
          delete requestData.inputFields.audio;
        } else if (requestData.selectedInferenceType === "text_to_image") {
          const generatedImage = document.getElementById("generated-image");
          const compressedImage = await compressGeneratedImage(
            generatedImage
          );
          requestData.inferenceResultsDecoded = compressedImage;
        }
        if (requestData.selectedInferenceType === "embedding_document") {
          const embeddingDocumentFileInput = document.getElementById(
            "embeddingDocumentFile"
          );
          if (
            embeddingDocumentFileInput &&
            embeddingDocumentFileInput.files.length > 0
          ) {
            requestData.inputFields.document_file_name =
              embeddingDocumentFileInput.files[0].name;
          }
        } else if (requestData.selectedInferenceType === "embedding_audio") {
          const embeddingAudioFileInput =
            document.getElementById("embeddingAudioFile");
          if (
            embeddingAudioFileInput &&
            embeddingAudioFileInput.files.length > 0
          ) {
            requestData.inputFields.audio_file_name =
              embeddingAudioFileInput.files[0].name;
          }
        }
        requests.push(requestData);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      async function compressGeneratedImage(imgElement) {
        try {
          const options = {
            maxSizeMB: 0.05,
            maxWidthOrHeight: 600,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          };
          const response = await fetch(imgElement.src);
          const blob = await response.blob();
          const compressedFile = await imageCompression(blob, options);
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = (error) => {
              console.error("Reader error:", error);
              reject(error);
            };
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          console.error("Compression error:", error);
          throw error;
        }
      }
      async function compressImage(imageBlob) {
        try {
          const compressedFile = await imageCompression(imageBlob, {
            maxSizeMB: 0.03,
            maxWidthOrHeight: 500,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          });
          const reader = new FileReader();
          return new Promise((resolve, reject) => {
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          throw error;
        }
      }
      function updatePreviousRequestsList() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const listContainer = document.getElementById("previousRequestsList");
        listContainer.innerHTML = "";

        if (requests.length === 0) {
          const noRequestsMessage = document.createElement("p");
          noRequestsMessage.className = "text-gray-500";
          noRequestsMessage.textContent =
            "No saved inference requests to display. Create new ones and they will display here when they finish successfully.";
          listContainer.appendChild(noRequestsMessage);
        } else {
          requests.forEach((request, index) => {
            let inferenceTypeIcon;
            let promptPreview;
            if (request.selectedInferenceType === "text_completion") {
              inferenceTypeIcon = "🖹";
              promptPreview = request.prompt;
            } else if (request.selectedInferenceType === "text_to_image") {
              inferenceTypeIcon = "🖼️";
              promptPreview = request.inputFields.imagePrompt;
            } else if (
              request.selectedInferenceType === "ask_question_about_an_image"
            ) {
              inferenceTypeIcon = "🖺";
              promptPreview = request.inputFields.question;
            } else if (
              request.selectedInferenceType === "embedding_document"
            ) {
              inferenceTypeIcon = "🔢";
              promptPreview = request.inputFields.document_file_name || "";
            } else if (request.selectedInferenceType === "embedding_audio") {
              inferenceTypeIcon = "🕪";
              promptPreview = request.inputFields.audio_file_name || "";
            } else {
              inferenceTypeIcon = "❔";
              promptPreview = request.prompt;
            }
            if (
              request.selectedInferenceType !== "embedding_document" &&
              request.selectedInferenceType !== "embedding_audio"
            ) {
              const previewText =
                request.selectedInferenceType ===
                  "ask_question_about_an_image"
                  ? request.inputFields.question
                  : request.prompt;
              promptPreview =
                request.selectedInferenceType === "text_to_image"
                  ? request.inputFields.imagePrompt.substring(0, 40)
                  : previewText
                    ? previewText.substring(0, 40)
                    : "No prompt available";
            }

            const listItem = document.createElement("div");
            listItem.className =
              "mb-2 p-2 bg-white rounded-lg flex justify-between items-center cursor-pointer";
            listItem.innerHTML = `<span><span class="icon-large">${inferenceTypeIcon}</span> ${promptPreview}...</span>
              <button class="delete-btn" style="font-size: 0.75rem;" title="Delete entry?" onclick="deleteRequest(${index})">❌</button>`;
            listItem.addEventListener("click", () =>
              displayRequestPreview(index)
            );
            listContainer.appendChild(listItem);
          });
        }
      }

      function deleteRequest(index) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        requests.splice(index, 1);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      function exportRequests() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        if (requests.length === 0) {
          alert("No saved inference requests to export.");
          return;
        }

        let markdownContent = "# Saved Inference Requests\n\n";
        requests.forEach((request, index) => {
          markdownContent += `## Inference Request ${index + 1}\n`;
          markdownContent += `**Prompt**: ${request.selectedInferenceType === "ask_question_about_an_image"
            ? request.inputFields.question
            : request.prompt
            }\n\n`;
          markdownContent += `**Inference Results**:\n\n`;

          if (request.selectedInferenceType === "text_to_image") {
            markdownContent += `![Generated Image](${request.compressedImage})\n\n`;
          } else {
            request.inferenceResultsDecoded.forEach((result, i) => {
              markdownContent += `### Completion ${i + 1}\n`;
              markdownContent += `\`\`\`\n${result}\n\`\`\`\n\n`;
            });
          }
          markdownContent += `**Model**: ${request.selectedModelCanonicalName}\n`;
          markdownContent += `**Actual Cost (Credits)**: ${request.actualCreditsUsed}\n`;
          markdownContent += `**Remaining Credits**: ${request.remainingCredits}\n`;
          markdownContent += `**Misc. Inference Parameters and Statistics**:\n`;
          markdownContent += `| Parameter | Value |\n`;
          markdownContent += `| --- | --- |\n`;
          markdownContent += `| Input Prompt to LLM | ${request.selectedInferenceType === "ask_question_about_an_image"
            ? request.inputFields.question
            : request.prompt
            } |\n`;
          markdownContent += `| Actual Cost (Credits) | ${request.actualCreditsUsed} |\n`;
          markdownContent += `| Remaining Credits | ${request.remainingCredits} |\n`;
          markdownContent += `| Model | ${request.selectedModelCanonicalName} |\n`;
          markdownContent += `| Request Timestamp | ${request.requestTimestamp} |\n`;
          markdownContent += `| Total Time (Seconds) | ${request.elapsedTimeInSeconds} |\n`;
          markdownContent += `\n\n`;
        });

        const blob = new Blob([markdownContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "inference_requests.md";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      document
        .getElementById("exportRequestsButton")
        .addEventListener("click", exportRequests);

      updatePreviousRequestsList();

      function displayRequestPreview(index) {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const request = requests[index];
        const previewContainer = document.getElementById("requestPreview");
        let combinedResults = "";
        if (request.selectedInferenceType === "text_completion") {
          const results = Array.isArray(
            JSON.parse(request.inferenceResultsDecoded)
          )
            ? JSON.parse(request.inferenceResultsDecoded)
            : [JSON.parse(request.inferenceResultsDecoded)];
          results.forEach((result, i) => {
            let parsedResult = result;
            try {
              const sanitizedResult = sanitizeJSON(result);
              const parsedJSON = JSON.parse(sanitizedResult);
              if (parsedJSON.text) {
                parsedResult = parsedJSON.text;
              }
            } catch (e) {
              parsedResult = fallbackParseResult(result);
            }
            combinedResults += `<h4>Completion ${i + 1} of ${results.length
              }</h4>`;
            combinedResults += `<github-md>${parsedResult}</github-md>`;
            if (i < results.length - 1) {
              combinedResults += "<hr>";
            }
          });
        } else if (
          request.selectedInferenceType === "ask_question_about_an_image"
        ) {
          combinedResults = `
            <img src="${request.inputFields.image
            }" alt="Input Image" style="max-width: 100%; max-height: 400px;">
            <p>Question: ${request.inputFields.question}</p>
            <p>Answer:</p>
            <github-md>${JSON.parse(request.inferenceResultsDecoded)[0]
            }</github-md>
          `;
        } else if (request.selectedInferenceType === "embedding_document") {
          combinedResults = `
                    <p>Semantic Query String: ${request.inputFields.question}</p>
                    `;
        } else if (request.selectedInferenceType === "embedding_audio") {
          const inferenceResultDecoded = request.inferenceResultsDecoded;
          const formattedResult = prettyJSON(inferenceResultDecoded);
          const coloredResult = formattedResult
            .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
            .replace(
              /"([^"]+)"(?=:)/g,
              '<span style="color: #2196F3;">$1</span>'
            ) // Pale blue for keys
            .replace(
              /: ("[^"]+")/g,
              ': <span style="color: #FFC107;">$1</span>'
            ) // Pale yellow for string values
            .replace(/: (\d+)/g, ': <span style="color: #FFC107;">$1</span>') // Pale yellow for numeric values
            .replace(
              /: (true|false|null)/g,
              ': <span style="color: #FFC107;">$1</span>'
            ); // Pale yellow for boolean and null values
          combinedResults = `
            <p>Original File Name: ${request.inputFields.audio_file_name}</p>
            <p>File SHA3-256 Hash: ${request.inputFields.fileHash}</p>
            <p>Semantic Query String: ${request.inputFields.question}</p>
            <div style="max-height: 1000px; overflow-y: auto;">
              <pre>${coloredResult}</pre>
            </div>
          `;
        } else if (request.selectedInferenceType === "text_to_image") {
          combinedResults = `
          <img src="${request.inferenceResultsDecoded}" alt="Generated Image" style="max-width: 100%; max-height: 400px;">
          <p class="text-sm italic m-2">(Please note that this is a compressed version of the original generated image.)</p>
        `;
        }
        previewContainer.innerHTML = `
        <div class="mb-4">
          <h3 class="font-bold">Inference Result:</h3>
          ${combinedResults}
        </div>
        <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
        <div class="table-responsive">
          <table class="table">
            <tr>
              <th>
                ${request.selectedInferenceType ===
            "ask_question_about_an_image"
            ? "Question"
            : request.selectedInferenceType === "embedding_document"
              ? "Input Document Name"
              : request.selectedInferenceType === "text_to_image"
                ? "Image Generation Prompt"
                : "Input Prompt to LLM"
          }
              </th>
              <td>
                ${request.selectedInferenceType ===
            "ask_question_about_an_image"
            ? request.inputFields.question
            : request.selectedInferenceType === "embedding_document"
              ? request.inputFields.document_file_name
              : request.selectedInferenceType === "text_to_image"
                ? request.inputFields.imagePrompt
                : request.prompt
          }
              </td>
            </tr>
            <tr><th>Actual Cost (Credits)</th><td>${request.actualCreditsUsed
          }</td></tr>
            <tr><th>Remaining Credits</th><td>${request.remainingCredits
          }</td></tr>
            <tr><th>Request Timestamp</th><td>${request.requestTimestamp
          }</td></tr>
            <tr><th>Model</th><td>${request.selectedModelCanonicalName
          }</td></tr>
            <tr><th>Total Time in Seconds to Process Request</th><td>${request.elapsedTimeInSeconds
          }</td></tr>
          </table>
        </div>`;

        renderMarkdown();
      }

      function downloadZip(zipUrl) {
        const link = document.createElement("a");
        link.href = zipUrl;
        link.download = "inference_result.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Call updatePreviousRequestsList on page load
      document.addEventListener(
        "DOMContentLoaded",
        updatePreviousRequestsList
      );

      async function createNewInferenceRequest(
        selectedCreditPackTicketId,
        selectedInferenceType,
        selectedModelCanonicalName,
        maxCost,
        modelParametersJSONBase64Encoded,
        modelInputDataJSONBase64Encoded
      ) {
        const resultContainer = document.getElementById(
          "inferenceRequestResult"
        );
        resultContainer.innerHTML = "";
        const loader = document.createElement("div");
        loader.className = "btn is-loading";
        loader.innerText = "Loading...";
        resultContainer.appendChild(loader);

        displayInferenceRequestLoggerMessages = true;
        const startTime = new Date();

        try {
          logStatusMessage("Creating new inference request...");

          if (!modelInputDataJSONBase64Encoded) {
            throw new Error("Model input data is required and cannot be empty.");
          }

          const requestPayload = {
            model_inference_type_string: selectedInferenceType,
            model_parameters_json_b64: modelParametersJSONBase64Encoded,
            model_input_data_json_b64: modelInputDataJSONBase64Encoded, // Use the original, untruncated data
            selectedCreditPackTicketId,
            maxCost,
            model_canonical_name: selectedModelCanonicalName,
          };

          // Create a truncated version only for logging
          const truncatedPayload = { ...requestPayload };
          if (typeof truncatedPayload.model_input_data_json_b64 === 'string' && truncatedPayload.model_input_data_json_b64.length > 100) {
            truncatedPayload.model_input_data_json_b64 = truncatedPayload.model_input_data_json_b64.substring(0, 100) + '...';
          }

          console.log('Creating inference request with payload:', JSON.stringify(truncatedPayload, null, 2));

          const response = await axios.post("/create-inference-request", requestPayload);

          if (response.data.success) {
            logStatusMessage("Inference request created successfully.");
            const contentType = response.headers["content-type"];

            const inferenceResultDict =
              response.data.result.inferenceResultDict;

            let combinedResults = "";
            const modelInputDataJSON =
              inferenceResultDict.model_input_data_json;
            const {
              proposed_cost_of_request_in_inference_credits,
              remaining_credits_in_pack_after_request_processed,
            } = inferenceResultDict.usage_request_response;

            const endTime = new Date();
            const elapsedTimeInSeconds = Math.floor(
              (endTime - startTime) / 1000
            );
            let compressedImage;
            if (selectedInferenceType === "text_to_image") {
              const imageBinaryData =
                inferenceResultDict.generated_image_decoded.data;
              if (imageBinaryData) {
                // Convert the binary data to a Blob
                const outputFormat =
                  document
                    .getElementById("output_format")
                    .value.replace("jpeg", "jpg") || "jpg";
                const imageBlob = new Blob(
                  [new Uint8Array(imageBinaryData)],
                  {
                    type: `image/${outputFormat}`,
                  }
                );
                // Create an object URL for the image
                const imageUrl = URL.createObjectURL(imageBlob);
                // Generate the image name
                const imageName = modelInputDataJSON.imagePrompt
                  .replace(/[^\w]/g, "_")
                  .replace(/_+/g, "_")
                  .substring(0, 100);
                // Create the combined results HTML
                const imageSizeBytes = await fetchImageSize(imageUrl);
                const imageSizeMB = (imageSizeBytes / (1024 * 1024)).toFixed(
                  2
                );
                combinedResults = `
                  <div class="m-8">
                    <img id="generated-image" src="${imageUrl}" alt="Generated Image" class="max-w-full max-h-96 mx-auto mb-4">
                    <p class="text-center">
                      <a href="${imageUrl}" download="${imageName}.${outputFormat}" class="btn success outline m-4">Download Image</a>
                    </p>
                    <p class="text-center text-gray-500">File size: ${imageSizeMB} MB</p>
                  </div>
                `;
              } else {
                combinedResults = "Failed to generate image.";
              }
            } else if (selectedInferenceType === "embedding_audio") {
              const embeddingAudioFileInput =
                document.getElementById("embeddingAudioFile");
              const originalFileName = embeddingAudioFileInput.files[0].name;
              const inferenceResultDecoded =
                inferenceResultDict.inference_result_decoded;
              const formattedResult = prettyJSON(inferenceResultDecoded);
              const coloredResult = formattedResult
                .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
                .replace(
                  /"([^"]+)"(?=:)/g,
                  '<span style="color: #2196F3;">$1</span>'
                ) // Pale blue for keys
                .replace(
                  /: ("[^"]+")/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ) // Pale yellow for string values
                .replace(
                  /: (\d+)/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ) // Pale yellow for numeric values
                .replace(
                  /: (true|false|null)/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ); // Pale yellow for boolean and null values
              combinedResults = `
                <p>Original File Name: ${originalFileName}</p>
                <p>Semantic Query String: ${modelInputDataJSON.question}</p>
                <div style="max-height: 1000px; overflow-y: auto;">
                  <pre>${coloredResult}</pre>
                </div>
              `;
            } else if (
              selectedInferenceType === "ask_question_about_an_image"
            ) {
              const imageFile = document.getElementById("imageFile").files[0];
              const imageUrl = URL.createObjectURL(imageFile);
              combinedResults = `
                <img src="${imageUrl}" alt="Input Image" style="max-width: 100%; max-height: 400px;">
                <p>Question: ${modelInputDataJSON.question}</p>
                <p>Answer:</p>
                <github-md>${JSON.parse(inferenceResultDict.inference_result_decoded)[0]
                }</github-md> 
              `;
            } else if (selectedInferenceType === "text_completion") {
              const inferenceResultsDecoded = JSON.parse(
                inferenceResultDict.inference_result_decoded
              );
              if (Array.isArray(inferenceResultsDecoded)) {
                inferenceResultsDecoded.forEach((result, i) => {
                  let parsedResult = result;
                  try {
                    const sanitizedResult = sanitizeJSON(result);
                    const parsedJSON = JSON.parse(sanitizedResult);
                    if (parsedJSON.text) {
                      parsedResult = parsedJSON.text;
                    }
                  } catch (e) {
                    try {
                      parsedResult = fallbackParseResult(result);
                    } catch (e) {
                      parsedResult = result;
                    }
                  }
                  combinedResults += `<h4>Completion ${i + 1} of ${inferenceResultsDecoded.length
                    }</h4>`;
                  combinedResults += `<github-md>${parsedResult}</github-md>`;
                  if (i < inferenceResultsDecoded.length - 1) {
                    combinedResults += "<hr>";
                  }
                });
              } else {
                // It's not an array, just a single result; so wrap it in markdown tags
                combinedResults = `<github-md>${inferenceResultsDecoded}</github-md>`;
              }
            }

            resultContainer.innerHTML = `
            <div class="mb-4">
              <h3 class="font-bold">Inference Result:</h3>
              ${combinedResults}
            </div>
            <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
            <div class="table-responsive">
              <table class="table">
                <tr>
                  <th>${selectedInferenceType === "embedding_document"
                ? "Input Document File Name"
                : selectedInferenceType === "embedding_audio"
                  ? "Input Audio File Name"
                  : "Input Prompt to LLM"
              }</th>
                  <td>${selectedInferenceType === "embedding_document"
                ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                  .document_file_name
                : selectedInferenceType === "embedding_audio"
                  ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                    .audio_file_name
                  : modelInputDataJSON.prompt
              }</td>
                </tr>
                <tr><th>Actual Cost (Credits)</th><td>${proposed_cost_of_request_in_inference_credits}</td></tr>
                <tr><th>Remaining Credits</th><td>${remaining_credits_in_pack_after_request_processed}</td></tr>
                <tr><th>Request Timestamp</th><td>${new Date().toISOString()}</td></tr>
                <tr><th>Model</th><td>${selectedModelCanonicalName}</td></tr>
                <tr><th>Total Time in Seconds to Process Request</th><td>${elapsedTimeInSeconds}</td></tr>
              </table>
            </div>
            ${selectedInferenceType === "embedding_document"
                ? `<p class="text-center">
                    <a href="#" id="downloadZipButton" class="btn success outline m-4">
                      Download Zip File of JSON Document Embeddings${inferenceResultDict.semantic_query_result
                  ? " and Semantic Search Results"
                  : ""
                }
                    </a>
                  </p>`
                : ""
              }
          `;

            saveInferenceRequestToLocalStorage({
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              inputFields: JSON.parse(atob(modelInputDataJSONBase64Encoded)),
              parameterFields: JSON.parse(
                atob(modelParametersJSONBase64Encoded)
              ),
              maxCost,
              inferenceResultsDecoded:
                inferenceResultDict.inference_result_decoded,
              prompt: document.getElementById("prompt").value,
              elapsedTimeInSeconds,
              actualCreditsUsed:
                proposed_cost_of_request_in_inference_credits,
              remainingCredits:
                remaining_credits_in_pack_after_request_processed,
              respondingSupernode:
                inferenceResultDict.responding_supernode_pastelid,
              requestTimestamp: startTime.toISOString(),
            });

            if (selectedInferenceType === "embedding_document") {
              const embeddingDocumentFileInput = document.getElementById(
                "embeddingDocumentFile"
              );
              const originalFileName =
                embeddingDocumentFileInput.files[0].name;
              document
                .getElementById("downloadZipButton")
                .addEventListener("click", () => {
                  const processedFileName = originalFileName
                    .replace(/\.[^/.]+$/, "")
                    .replace(/[^\w]/g, "_")
                    .replace(/_+/g, "_")
                    .substring(0, 100);
                  // Convert the buffer data to a Uint8Array
                  const zipFileDataBuffer =
                    inferenceResultDict.zip_file_data.data;
                  const zipFileUint8Array = new Uint8Array(zipFileDataBuffer);
                  const zipBlob = new Blob([zipFileUint8Array], {
                    type: "application/zip",
                  });
                  const downloadLink = document.createElement("a");
                  downloadLink.href = URL.createObjectURL(zipBlob);
                  downloadLink.download = `${processedFileName}.zip`;
                  downloadLink.click();
                });
              // Update the table cell with the original file name
              resultContainer.querySelector("td").textContent =
                originalFileName;
            }
            renderMarkdown();
          } else {
            throw new Error("Failed to create inference request");
          }
        } catch (error) {
          console.error(
            `Error creating new inference request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
          );
          resultContainer.innerHTML =
            "Failed to create inference request. Please try again.";
          logStatusMessage("Failed to create inference request.");
        } finally {
          loader.remove();
          displayInferenceRequestLoggerMessages = false;
        }
      }

      async function decompressJsonFromZip(zipUrl) {
        const response = await fetch(zipUrl);
        const blob = await response.blob();
        const jsZip = new JSZip();
        const zip = await jsZip.loadAsync(blob);
        const fileNames = Object.keys(zip.files);
        const jsonFile = await zip.files[fileNames[0]].async("text");
        return jsonFile;
      }

      // Function to fetch and display received messages
      async function fetchReceivedMessages() {
        try {
          const userPastelID =
            document.getElementById("pastelIDDropdown").value;

          const response = await axios.get("/get-best-supernode-url", {
            params: { userPastelID },
          });
          const supernodeURL = response.data.supernodeURL;
          const closestSupernodeIP = supernodeURL.match(
            /(?:https?:\/\/)?([^:/]+)/i
          )[1];

          const messagesResponse = await axios.get("/get-received-messages", {
            timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
          });
          const messageDict = messagesResponse.data.messageDict;

          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML = ""; // Clear previous messages

          for (const pastelId in messageDict) {
            const messages = messageDict[pastelId];
            messages.forEach((message) => {
              const messageElement = document.createElement("div");
              messageElement.classList.add(
                "mb-4",
                "border",
                "border-gray-300",
                "rounded-lg",
                "p-4"
              );

              const fromPastelIDElement = document.createElement("p");
              fromPastelIDElement.classList.add(
                "text-sm",
                "font-medium",
                "text-gray-600",
                "mb-2"
              );
              fromPastelIDElement.textContent = `From: ${pastelId}`;

              const messageBodyElement = document.createElement("p");
              messageBodyElement.classList.add(
                "text-base",
                "text-gray-800",
                "mb-2"
              );
              messageBodyElement.textContent = message.message_body;

              const timestampElement = document.createElement("p");
              timestampElement.classList.add("text-xs", "text-gray-500");
              timestampElement.textContent = new Date(
                message.timestamp
              ).toLocaleString();

              messageElement.appendChild(fromPastelIDElement);
              messageElement.appendChild(messageBodyElement);
              messageElement.appendChild(timestampElement);

              receivedMessagesContainer.appendChild(messageElement);
            });
          }
        } catch (error) {
          console.log("Error retrieving received messages:", error);
          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML =
            "Failed to retrieve received messages. Please try again later.";
        }
      }

      // Handle create PastelID button click
      document
        .getElementById("createPastelIDButton")
        .addEventListener("click", async () => {
          try {
            await axios.post("/check-for-pastel-id", { autoRegister: true });
            location.reload(); // Refresh the page to update the UI
          } catch (error) {
            console.error("Error creating PastelID:", error);
          }
        });

      // Handle import private key form submission
      document
        .getElementById("importPrivKeyButton")
        .addEventListener("click", async () => {
          const privKey = document.getElementById("importPrivKey").value;
          if (!privKey) {
            alert("Please enter private key!");
            return;
          }
          showLoading("importPrivKeyLoading");
          try {
            await axios.post("/import-priv-key", { zcashPrivKey: privKey });
            alert("Private key imported successfully!");
          } catch (error) {
            console.error("Error importing private key:", error);
          }
          hideLoading("importPrivKeyLoading");
        });

      // Handle import wallet form submission
      document
        .getElementById("importWalletButton")
        .addEventListener("click", async () => {
          const walletFile = document.getElementById("importWallet").files[0];
          if (!walletFile) {
            alert("Please select a Wallet file to import.");
            return;
          }
          showLoading("importWalletLoading");
          const formData = new FormData();
          formData.append("walletFile", walletFile);
          try {
            await axios.post("/import-wallet", formData);
            alert("Wallet imported successfully!");
          } catch (error) {
            console.error("Error importing wallet:", error);
          }
          hideLoading("importWalletLoading");
        });

      // Handle list address amounts button click
      document
        .getElementById("listAddressAmountsButton")
        .addEventListener("click", async () => {
          showLoading("listAddressAmountsLoading");
          try {
            const response = await axios.get("/list-address-amounts");
            const addressAmounts = response.data.result;
            console.log("Address amounts:", addressAmounts);

            // Populate the table
            const addressAmountsTable = document.getElementById(
              "addressAmountsTable"
            );
            addressAmountsTable.innerHTML =
              "<thead><tr><th>Address</th><th>Amount</th></tr></thead><tbody></tbody>";
            const tbody = addressAmountsTable.querySelector("tbody");
            for (const [address, amount] of Object.entries(addressAmounts)) {
              const row = document.createElement("tr");
              row.innerHTML = `<td>${address}</td><td>${parseAndFormatNumber(
                amount.toString()
              )}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const addressAmountsContainer = document.getElementById(
              "addressAmountsContainer"
            );
            addressAmountsContainer.style.display = "block";
            document.getElementById(
              "copyAddressAmountsButton"
            ).style.display = "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyAddressAmountsButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(addressAmounts)
                  .map(
                    ([address, amount]) =>
                      `${address},${amount.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Address amounts copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving address amounts:", error);
          }
          hideLoading("listAddressAmountsLoading");
        });
      // Handle get wallet info button click
      document
        .getElementById("getWalletInfoButton")
        .addEventListener("click", async () => {
          showLoading("getWalletInfoLoading");
          try {
            const response = await axios.get("/get-wallet-info");
            const walletInfo = response.data.result;
            console.log("Wallet info:", walletInfo);

            // Populate the table
            const walletInfoTable =
              document.getElementById("walletInfoTable");
            walletInfoTable.innerHTML =
              "<thead><tr><th>Key</th><th>Value</th></thead><tbody></tbody>";
            const tbody = walletInfoTable.querySelector("tbody");
            const balanceFields = [
              "balance",
              "unconfirmed_balance",
              "immature_balance",
            ]; // Add the balance fields you want to format

            for (const [key, value] of Object.entries(walletInfo)) {
              const formattedValue = balanceFields.includes(key)
                ? parseAndFormatNumber(value.toString())
                : value;
              const row = document.createElement("tr");
              row.innerHTML = `<td>${key}</td><td>${formattedValue}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const walletInfoContainer = document.getElementById(
              "walletInfoContainer"
            );
            walletInfoContainer.style.display = "block";
            document.getElementById("copyWalletInfoButton").style.display =
              "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyWalletInfoButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(walletInfo)
                  .map(
                    ([key, value]) =>
                      `${key},${value.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Wallet info copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving wallet info:", error);
          }
          hideLoading("getWalletInfoLoading");
        });

      document
        .getElementById("clearLocalStorageButton")
        .addEventListener("click", () => {
          if (
            confirm(
              "Are you sure you want to clear all local storage data for this page?"
            )
          ) {
            localStorage.clear();
            alert("Local storage cleared. The page will now reload.");
            location.reload();
          }
        });

      // Create a terminal and load the fit addon
      const term = new Terminal({ cols: 175, rows: 24 });
      term.open(document.getElementById("terminal"));
      term.terminalOptions = {
        fontSize: 6,
        enableBold: true,
        cols: 175,
        rows: 24,
      };

      function resizeTerminal() {
        const terminalElement = document.getElementById("terminal");
        const cols = Math.floor(terminalElement.clientWidth / 10); // Approximate character width
        const rows = Math.floor(terminalElement.clientHeight / 20); // Approximate character height

        console.log(
          `Cols: ${cols}, Rows: ${rows}, Type of Cols: ${typeof cols}, Type of Rows: ${typeof rows}`
        );

        if (cols > 0 && rows > 0) {
          term.resize(cols, rows);
        }
      }

      resizeTerminal();
      window.addEventListener("resize", resizeTerminal);

      function displayStatusMessage(message) {
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.textContent = message;
      }

      function cleanAndFormatMessage(message) {
        if (typeof message === "object") {
          // If the message is a JSON object, stringify and format it
          return JSON.stringify(message, null, 2);
        } else if (typeof message === "string") {
          // Remove excess whitespace from strings
          return message.replace(/\s+/g, " ").trim();
        }
        return message;
      }

      function logMessageToTerminal(term, logMessage) {
        const message =
          typeof logMessage.message === "string" ? logMessage.message : "";
        const cleanMessage = cleanAndFormatMessage(message);
        if (typeof cleanMessage !== "string") {
          console.error("cleanMessage is not a string:", cleanMessage);
          return;
        }
        const parts = cleanMessage.split(/(\{[\s\S]*?\})/);
        const formattedParts = parts
          .map((part) => {
            if (part.startsWith("{") && part.endsWith("}")) {
              let parsed;
              try {
                parsed = JSON.parse(part);
              } catch (e) {
                try {
                  // Fix common JSON issues
                  let fixedPart = part
                    .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Ensure keys are quoted
                    .replace(/:\s*(['"])?([^\n\r\t,}\]]+)(['"])?/g, ': "$2"') // Ensure values are quoted
                    .replace(/,\s*([\]}])/g, "$1") // Remove trailing commas
                    .replace(/\\n/g, "\\n") // Handle newlines
                    .replace(/\\r/g, "\\r") // Handle carriage returns
                    .replace(/\\t/g, "\\t") // Handle tabs
                    .replace(/[\u0000-\u001F\u007F-\u009F]/g, ""); // Remove control characters

                  // Fix for unterminated strings
                  const quotesBalanced =
                    fixedPart.split('"').length % 2 === 1;
                  if (quotesBalanced) {
                    fixedPart = fixedPart + '"';
                  }

                  parsed = JSON.parse(fixedPart);
                } catch (innerE) {
                  // Silently fail
                  return part;
                }
              }
              const formatted = prettyJSON(parsed);
              return formatted
                .replace(/({|})/g, "\x1b[1;32m$1\x1b[0m") // Light green for braces
                .replace(/"([^"]+)"(?=:)/g, '\x1b[1;34m"$1"\x1b[0m') // Pale blue for keys
                .replace(/: ("[^"]+")/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for string values
                .replace(/: (\d+)/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for numeric values
                .replace(/: (true|false|null)/g, ": \x1b[1;33m$1\x1b[0m"); // Pale yellow for boolean and null values
            }
            return part;
          })
          .join("");
        const timestamp = logMessage.timestamp
          ? new Date(logMessage.timestamp).toISOString()
          : "Invalid timestamp";
        const logLevel = logMessage.level || "Unknown level";
        const messageLines =
          `[${timestamp}] [${logLevel}] ${formattedParts}`.split("\n");
        messageLines.forEach((line) => term.writeln(line));
      }

      fetch("/ws-url")
        .then((response) => response.json())
        .then((data) => {
          const socket = new WebSocket(data.wsUrl);

          socket.onopen = () => {
            console.log("WebSocket connection established");
          };

          socket.onmessage = (event) => {
            if (event.data) {
              const logMessage = JSON.parse(event.data);
              logMessageToTerminal(term, logMessage);

              if (displayInferenceRequestLoggerMessages) {
                logStatusMessage(logMessage.message);
              }

              if (displayCreateTicketLoggerMessages) {
                const statusContainer = document.getElementById(
                  "createTicketStatusContainer"
                );
                const statusContent =
                  document.getElementById("createTicketStatus");
                if (logMessage.message) {
                  logCreateTicketStatusMessage(
                    logMessage.message,
                    statusContent
                  );
                }
              }
            }
          };

          socket.onclose = () => {
            console.log("WebSocket connection closed");
          };

          socket.onerror = (error) => {
            console.error("WebSocket error:", error);
          };
        })
        .catch((error) => {
          console.error("Error fetching WebSocket URL:", error);
        });

      function toggleTerminal() {
        const terminal = document.getElementById("terminal");
        if (terminal.style.display === "none") {
          terminal.style.display = "block";
        } else {
          terminal.style.display = "none";
        }
        resizeTerminal();
      }

      tailwind.config = {
        theme: {
          extend: {},
        },
      };

      var storedTheme =
        localStorage.getItem("theme") ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light");
      if (storedTheme)
        document.documentElement.setAttribute("data-theme", storedTheme);

      function toggleDarkMode() {
        var currentTheme =
          document.documentElement.getAttribute("data-theme");
        var targetTheme = currentTheme === "light" ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", targetTheme);
        localStorage.setItem("theme", targetTheme);
        document
          .querySelector("#theme-toggle")
          .setAttribute("data-content", targetTheme === "dark" ? "🌙" : "☀");
      }

      // Set the initial state of the switch toggle
      const toggle = document.querySelector("#theme-toggle");
      if (storedTheme === "dark") {
        toggle.checked = true;
        toggle.setAttribute("data-content", "🌙");
      } else {
        toggle.checked = false;
        toggle.setAttribute("data-content", "☀");
      }

      // Format the values and display them using template literals
      function formatAndDisplay(inputElement) {
        const value = inputElement.value.replace(/,/g, "");
        const number = parseFloat(value);
        if (!isNaN(number)) {
          inputElement.setAttribute("data-raw-value", number);
          inputElement.value = number.toLocaleString();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const createTicketForm = document.getElementById("createTicketForm");
        createTicketForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const numCredits = parseInt(
            document.querySelector("#numCredits").value.replace(/,/g, "")
          );
          const maxTotalPrice = parseFloat(
            document.querySelector("#maxTotalPrice").value.replace(/,/g, "")
          );
          const maxPerCreditPrice = parseFloat(
            document
              .querySelector("#maxPerCreditPrice")
              .value.replace(/,/g, "")
          );

          const statusContainer = document.getElementById(
            "createTicketStatusContainer"
          );
          const statusContent = document.getElementById("createTicketStatus");
          statusContent.innerHTML = ""; // Clear previous logs

          logCreateTicketStatusMessage(
            "Initializing ticket creation...",
            statusContent
          );
          try {
            await createNewCreditPackTicket(
              numCredits,
              maxTotalPrice,
              maxPerCreditPrice
            );
          } catch (error) {
            console.error(
              "Error creating credit pack ticket:",
              error.message
            );
            logCreateTicketStatusMessage(
              `Failed to create credit pack ticket: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`,
              statusContent
            );
          }
        });

        // Add event listener to format and update raw values on input change
        const inputs = document.querySelectorAll(
          "#numCredits, #maxTotalPrice, #maxPerCreditPrice"
        );
        inputs.forEach((input) => {
          input.addEventListener("input", handleInputChange);
          input.addEventListener("blur", handleInputBlur);
        });

        document
          .getElementById("inferenceRequestForm")
          .addEventListener("submit", async (event) => {
            event.preventDefault();
            saveInferenceRequestSettings();

            const selectedCreditPackTicket = document.querySelector(
              'input[name="creditPackTicket"]:checked'
            );
            if (!selectedCreditPackTicket) {
              alert("Please select a credit pack ticket.");
              return;
            }
            const selectedRow = selectedCreditPackTicket.closest("tr");
            const selectedCreditPackTicketId = selectedRow
              .querySelector("td:last-child a")
              .textContent.trim();

            const selectedInferenceType =
              document.getElementById("inferenceType").value;
            const selectedModelCanonicalName =
              document.getElementById("model").value;
            const maxCost = parseFloat(
              document.querySelector("#maxCost").dataset.rawValue
            );
            const encodeToBase64 = (str) => {
              return btoa(unescape(encodeURIComponent(str)));
            };

            const encodeFileToBase64 = (file) => {
              return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(",")[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
            };

            const formData = new FormData(event.target);
            const modelParameters = {};
            formData.forEach((value, key) => {
              if (
                key !== "prompt" &&
                key !== "imagePrompt" &&
                key !== "embeddingDocumentFile" &&
                key !== "embeddingAudioFile"
              ) {
                modelParameters[key] = value;
              }
            });

            const modelParametersJSON = JSON.stringify(modelParameters);
            const modelParametersJSONBase64Encoded =
              encodeToBase64(modelParametersJSON);

            let inputPromptKey;
            if (selectedInferenceType === "text_completion") {
              inputPromptKey = "prompt";
            } else if (selectedInferenceType === "text_to_image") {
              inputPromptKey = "imagePrompt";
            } else if (selectedInferenceType === "embedding_document") {
              inputPromptKey = "embeddingDocumentFile";
            } else if (selectedInferenceType === "embedding_audio") {
              inputPromptKey = "embeddingAudioFile";
            } else {
              inputPromptKey = "prompt";
            }

            let modelInputDataBase64Encoded;
            if (selectedInferenceType === "ask_question_about_an_image") {
              const imageFile = document.getElementById("imageFile").files[0];
              const question = document.getElementById("question").value;
              if (!imageFile || !question) {
                alert("Please select an image and enter a question.");
                return;
              }
              const imageBase64 = await encodeFileToBase64(imageFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  image: imageBase64,
                  question: question,
                })
              );
            } else if (selectedInferenceType === "embedding_document") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "document_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Document file data cannot be empty.");
                return;
              }
              const documentBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  document: documentBase64,
                  question: semantic_query_string,
                })
              );
            } else if (selectedInferenceType === "embedding_audio") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "audio_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Audio file data cannot be empty.");
                return;
              }
              const audioBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  audio: audioBase64,
                  question: semantic_query_string,
                })
              );
            } else {
              const inputPromptValue =
                document.getElementById(inputPromptKey).value;
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({ [inputPromptKey]: inputPromptValue })
              );
            }
            if (!maxCost) {
              alert("Maximum Cost (Credits) cannot be empty.");
              return;
            }
            await createNewInferenceRequest(
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              maxCost,
              modelParametersJSONBase64Encoded,
              modelInputDataBase64Encoded
            );

            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(STORAGE_TIMESTAMP_KEY);

            // Refresh the credit pack tickets to reflect the updated balance
            await getMyValidCreditPacks(true);
          });

        // Attach debounced input and blur event listeners to all relevant input elements
        const inferenceRequestForm = document.getElementById(
          "inferenceRequestForm"
        );
        const inputElements = inferenceRequestForm.querySelectorAll(
          "input, textarea, select"
        );

        inputElements.forEach((inputElement) => {
          inputElement.addEventListener(
            "input",
            debounce(handleInputChange, 300)
          );
          inputElement.addEventListener("blur", handleInputBlur);
        });

        const maxCostInput = document.getElementById("maxCost");
        const maxCostFormattedSpan =
          document.getElementById("maxCostFormatted");
        maxCostInput.addEventListener(
          "input",
          debounce(
            () => formatAndDisplay(maxCostInput, maxCostFormattedSpan),
            300
          )
        );
      });

      document
        .getElementById("exportTerminalButton")
        .addEventListener("click", () => {
          let termText = "";
          for (let i = 0; i < term.buffer.active.length; i++) {
            const line = term.buffer.active.getLine(i);
            if (line) {
              termText += line.translateToString(false) + "\n";
            }
          }
          const blob = new Blob([termText], { type: "text/plain" });
          const link = document.createElement("a");
          const currentDate = new Date().toISOString();
          const fileName = `Pastel_Inference_Client_Terminal_Session_Log__${currentDate}.txt`;
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
        handleCreditPackSelection();
        document.getElementById("inferenceType").value = "text_completion"; // Set default to Text Completion
        document
          .getElementById("inferenceType")
          .dispatchEvent(new Event("change")); // Trigger change event

        // Automatically refresh the table of existing credit packs on initial page load
        getMyValidCreditPacks(true).catch((error) => {
          console.error("Error refreshing credit pack tickets:", error);
        });
      });

      // This function ensures that the tracking addresses have a minimum balance of 1 PSL; only runs every 10 minutes to give time for a new block to be mined including the transactions
      document.addEventListener("DOMContentLoaded", function () {
        const refreshButton = document.getElementById("refreshButton");
        let lastRunTime = 0;
        const runInterval = 10 * 60 * 1000; // 10 minutes in milliseconds

        async function ensureMinimalPSLBalance() {
          const currentTime = new Date().getTime();
          if (currentTime - lastRunTime < runInterval) {
            console.log(
              "Skipping balance check: Less than 10 minutes since last run."
            );
            return; // Skip execution if not enough time has passed
          }

          try {
            // Wait for the table to load with a timeout
            await waitForTableLoad();

            // Once the table is confirmed to be loaded, proceed to gather addresses
            const table = document.getElementById(
              "creditPackTicketTableBody"
            );
            const trackingAddresses = Array.from(
              table.querySelectorAll("tr")
            ).map((row) => {
              return row.cells[3].textContent.trim(); // Assuming the tracking address is in the 4th column
            });

            const uniqueAddresses = [...new Set(trackingAddresses)];

            const response = await axios.post("/ensure-minimal-psl-balance", {
              addresses: uniqueAddresses,
            });

            if (response.data && response.data.success) {
              console.log("Balance check and update initiated successfully.");
              lastRunTime = currentTime; // Update last run time on successful execution
            } else {
              console.error("Failed to initiate balance check and update.");
            }
          } catch (error) {
            console.error("Error ensuring minimal PSL balance:", error);
          }
        }

        async function waitForTableLoad(maxWaitTime = 25000, interval = 500) {
          const startTime = new Date().getTime();

          function checkCondition() {
            const table = document.getElementById(
              "creditPackTicketTableBody"
            );
            return table && table.querySelectorAll("tr").length > 0; // Check if the table has at least one row
          }

          return new Promise((resolve, reject) => {
            (function waitForCondition() {
              if (checkCondition()) {
                resolve(true);
              } else if (new Date().getTime() - startTime < maxWaitTime) {
                setTimeout(waitForCondition, interval);
              } else {
                reject(new Error("Timeout waiting for the table to load."));
              }
            })();
          });
        }

        // Event listener for manual refresh
        refreshButton.addEventListener("click", ensureMinimalPSLBalance);

        // Automatically trigger the balance check on initial page load
        ensureMinimalPSLBalance().catch((error) =>
          console.error("Error on initial load:", error)
        );
      });
    </script>
    <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js"></script>
  </div>
</body>

</html>

---
./initial_inference_js_client_setup_script.sh
---
#!/bin/bash

# Determine the user shell
user_shell=$(echo $SHELL)
echo "Detected user shell: $user_shell"

# Set shell path and profile file based on user shell
if [[ $user_shell == *"/zsh"* ]]; then
  profile_file=".zshrc"
else
  profile_file=".bashrc"
fi
echo "Using profile file: ~/$profile_file"

# Update code block with appropriate shell execution
if [ -d ~/pastel_inference_js_client ]; then
  echo "Directory exists. Stashing and pulling latest code..."
  cd ~/pastel_inference_js_client
  git stash
  git pull
else
  echo "Directory does not exist. Cloning repository..."
  git clone https://github.com/pastelnetwork/pastel_inference_js_client.git ~/pastel_inference_js_client
  cd ~/pastel_inference_js_client
fi

# Check if NVM is already installed; if not install it and configure it to use the latest version as the default
if [ ! -d "$HOME/.nvm" ]; then
  echo "Installing NVM..."
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
fi

nvm install --latest-npm
nvm use node
nvm alias default node

npm install

---
./logger.js
---
const winston = require("winston");
const Sequelize = require("sequelize");
const EventEmitter = require("events");

function safeStringify(obj, space = 2) {
  const seen = new WeakSet();

  const replacer = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);

      if (value instanceof Sequelize.Model) {
        return value.get({ plain: true });
      }
      if (value.isJoi) {
        return `Joi Schema for ${value.type}`;
      }
      if (value instanceof Map) {
        return Array.from(value.entries());
      }
      if (value instanceof Set) {
        return Array.from(value);
      }
      if (value instanceof Date) {
        return value.toISOString();
      }
      if (value instanceof Error) {
        const errorDetails = {};
        Object.getOwnPropertyNames(value).forEach((prop) => {
          errorDetails[prop] = value[prop];
        });
        return errorDetails;
      }
      if (value.constructor === Object) {
        const sortedObj = {};
        Object.keys(value)
          .sort()
          .forEach((key) => {
            sortedObj[key] = value[key];
          });
        return sortedObj;
      }
    } else if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };

  return JSON.stringify(obj, replacer, space);
}

const customFormatter = winston.format((info) => {
  const formattedInfo = { ...info };

  Object.keys(formattedInfo).forEach((key) => {
    if (formattedInfo[key] instanceof Date) {
      formattedInfo[key] = formattedInfo[key].toISOString();
    }
  });

  return formattedInfo;
});
let transports = [
  new winston.transports.File({ filename: "error.log", level: "error" }),
  new winston.transports.File({ filename: "combined.log" }),
];
if (process.env.USE_WINSTON_TRANSPORTS_CONSOLE === '1') {
  transports.push(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  )
}
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    customFormatter(),
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports,
});

const logEmitter = new EventEmitter();
const logBuffer = [];
const MAX_LOG_ENTRIES = 100;

logger.on("data", (logEntry) => {
  const logEntryString = safeStringify(logEntry);
  logBuffer.push(logEntryString);
  if (logBuffer.length > MAX_LOG_ENTRIES) {
    logBuffer.shift();
  }
  logEmitter.emit("newLog", logEntryString);
});

// Intercept logs and emit events
const originalLog = logger.log.bind(logger);
logger.log = (level, msg, meta) => {
  originalLog(level, msg, meta);
  const logEntry = { level, msg, meta, timestamp: new Date().toISOString() };
  logEmitter.emit("newLog", safeStringify(logEntry));
};

module.exports = { logger, logEmitter, logBuffer, safeStringify };


---
./package.json
---
{
  "name": "pastel-inference-js-client",
  "version": "1.0.0",
  "description": "A JavaScript client for interacting with the Pastel Network and performing inference tasks.",
  "main": "server.js",
  "scripts": {
    "start": "node update.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "lint": "eslint .",
    "format": "prettier --write ."
  },
  "keywords": [
    "pastel",
    "inference",
    "blockchain",
    "messaging",
    "credit-pack",
    "llm"
  ],
  "author": "Jeff Emanuel <jeff@pastel.network>",
  "license": "MIT",
  "dependencies": {
    "@xterm/xterm": "^5.5.0",
    "axios": "^1.7.7",
    "body-parser": "^1.20.2",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.13.3",
    "multer": "^1.4.5-lts.1",
    "node-persist": "^4.0.3",
    "p-limit": "^6.1.0",
    "ping": "^0.4.4",
    "sequelize": "^6.37.3",
    "sqlite3": "^5.1.7",
    "winston": "^3.14.2",
    "ws": "^8.18.0",
    "zstd-codec": "^0.1.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^8.10.0",
    "globals": "^15.9.0",
    "jest": "^28.1.3",
    "nodemon": "^3.1.4",
    "prettier": "^2.8.8"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pastelnetwork/pastel_inference_js_client.git"
  },
  "bugs": {
    "url": "https://github.com/pastelnetwork/pastel_inference_js_client/issues"
  },
  "homepage": "https://github.com/pastelnetwork/pastel_inference_js_client#readme"
}


---
./pastel_inference_client.js
---
require("dotenv").config();
const axios = require("axios");
const {
  signMessageWithPastelID,
  checkSupernodeList,
  getCurrentPastelBlockHeight,
} = require("./rpc_functions");
const {
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestPreliminaryPriceQuote,
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  CreditPackPurchaseRequestStatus,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  InferenceAPIUsageRequest,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmation,
} = require("./sequelize_data_models");
const {
  userMessageSchema,
  creditPackPurchaseRequestSchema,
  creditPackPurchaseRequestRejectionSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema,
  creditPackPurchaseRequestResponseTerminationSchema,
  creditPackPurchaseRequestResponseSchema,
  creditPackPurchaseRequestConfirmationSchema,
  creditPackPurchaseRequestConfirmationResponseSchema,
  creditPackRequestStatusCheckSchema,
  creditPackPurchaseRequestStatusSchema,
  creditPackStorageRetryRequestSchema,
  creditPackStorageRetryRequestResponseSchema,
  inferenceAPIUsageRequestSchema,
  inferenceAPIUsageResponseSchema,
  inferenceAPIOutputResultSchema,
  inferenceConfirmationSchema,
} = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const {
  filterSupernodes,
  getNClosestSupernodesToPastelIDURLs,
  computeSHA3256HashOfSQLModelResponseFields,
  prepareModelForEndpoint,
  prepareModelForValidation,
  removeSequelizeFields,
  pythonCompatibleStringify,
  estimatedMarketPriceOfInferenceCreditsInPSLTerms,
  logActionWithPayload,
  transformCreditPackPurchaseRequestResponse,
} = require("./utility_functions");
const globals = require("./globals");


const MESSAGING_TIMEOUT_IN_SECONDS = process.env.MESSAGING_TIMEOUT_IN_SECONDS;

function getIsoStringWithMicroseconds() {
  // Get the current time
  const now = new Date();
  // Convert the date to an ISO string and replace 'Z' with '+00:00' to match Python's format
  // Ensure to remove any unwanted spaces directly in this step if they were somehow introduced
  const isoString = now.toISOString().replace("Z", "+00:00").replace(/\s/g, "");
  // Return the correctly formatted ISO string without any spaces
  return isoString;
}

class PastelInferenceClient {
  constructor(pastelID, passphrase) {
    this.pastelID = pastelID;
    this.passphrase = passphrase;
  }

  async requestAndSignChallenge(supernodeURL) {
    try {
      const response = await axios.get(
        `${supernodeURL}/request_challenge/${this.pastelID}`,
        {
          timeout: 12000,
        }
      );
      const { challenge, challenge_id } = response.data;
      const challenge_signature = await signMessageWithPastelID(
        this.pastelID,
        challenge,
        this.passphrase
      );
      return {
        challenge,
        challenge_id,
        challenge_signature,
      };
    } catch (error) {
      logger.error(
        `Error requesting and signing challenge: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async sendUserMessage(supernodeURL, userMessage) {
    try {
      const { error } = userMessageSchema.validate(userMessage);
      if (error) {
        throw new Error(`Invalid user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = userMessage.toJSON();
      const response = await axios.post(
        `${supernodeURL}/send_user_message`,
        {
          user_message: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      const result = response.data;
      const { resultError, value: validatedResult } =
        await userMessageSchema.validate(result);
      if (error) {
        throw new Error(`Invalid user message: ${resultError.message}`);
      }
      const userMessageInstance = await UserMessage.create(validatedResult);
      return userMessageInstance;
    } catch (error) {
      logger.error(`Error sending user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getUserMessages(supernodeURL) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = {
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      const response = await axios.get(`${supernodeURL}/get_user_messages`, {
        params,
        timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
      });
      const result = response.data;
      const validatedResults = await Promise.all(
        result.map((messageData) => userMessageSchema.validate(messageData))
      );
      const userMessageInstances = await UserMessage.bulkCreate(
        validatedResults
      );
      return userMessageInstances;
    } catch (error) {
      logger.error(`Error retrieving user messages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getModelMenu() {
    const minimumNumberOfResponses = 5; // Minimum number of valid responses needed
    const retryLimit = 1; // Number of retries per supernode
    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(
        60,
        this.pastelID,
        validMasternodeListFullDF
      );
      let validResponses = [];

      // Custom promise to collect a specified minimum number of valid responses
      await new Promise((resolve, reject) => {
        let completedRequests = 0;
        closestSupernodes.forEach(({ url }) => {
          this.retryPromise(() => this.getModelMenuFromSupernode(url), retryLimit)
            .then(response => {
              logger.info(`Successful model menu response received from supernode at ${url}`);
              validResponses.push({ response, url });
              // Resolve promise when minimum number of valid responses are collected
              if (validResponses.length >= minimumNumberOfResponses) {
                resolve();
              }
            })
            .catch(error => {
              logger.error(`Error querying supernode at ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
              completedRequests++;
              // Check if it's still possible to get the minimum number of valid responses
              if (completedRequests > closestSupernodes.length - minimumNumberOfResponses + validResponses.length) {
                reject(new Error("Insufficient valid responses received from supernodes"));
              }
            });
        });
      });

      // Determine the largest/longest response
      const largestResponse = validResponses.reduce((prev, current) => {
        return JSON.stringify(current.response).length > JSON.stringify(prev.response).length ? current : prev;
      }).response;

      return largestResponse;
    } catch (error) {
      logger.error(`Error in getModelMenu: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getModelMenuFromSupernode(supernodeURL) {
    try {
      const response = await axios.get(
        `${supernodeURL}/get_inference_model_menu`,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      return response.data;
    } catch (error) {
      // Silently catch the error and return undefined, null, or a default value.
      return null;  // You can return null, undefined, or an empty object depending on your use case.
    }
  }

  async retryPromise(promiseFunc, limit, count = 0) {
    try {
      return await promiseFunc();
    } catch (error) {
      if (count < limit) {
        return this.retryPromise(promiseFunc, limit, count + 1);
      } else {
        throw error;
      }
    }
  }

  async getValidCreditPackTicketsForPastelID(supernodeURL) {
    const useVerbose = false;
    try {
      if (!this.pastelID) {
        return [];
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      if (useVerbose) {
        logActionWithPayload(
          "retrieving",
          "valid credit pack tickets for PastelID",
          payload
        );
      }
      const response = await axios.post(
        `${supernodeURL}/get_valid_credit_pack_tickets_for_pastelid`,
        payload,
        {
          timeout: 6000,
        }
      );
      if (response.status !== 200) {
        if (useVerbose) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return [];
      }
      const validCreditPackTickets = response.data;
      if (useVerbose && validCreditPackTickets.length) {
        logger.info(
          `Received ${validCreditPackTickets.length} valid credit pack tickets for PastelID ${this.pastelID}`
        );
      }

      // Process the new format of returned results
      const processedTickets = validCreditPackTickets.map(ticket => ({
        credit_pack_registration_txid: ticket.credit_pack_registration_txid,
        credit_purchase_request_confirmation_pastel_block_height: ticket.credit_purchase_request_confirmation_pastel_block_height,
        requesting_end_user_pastelid: ticket.requesting_end_user_pastelid,
        ticket_input_data_fully_parsed_sha3_256_hash: ticket.ticket_input_data_fully_parsed_sha3_256_hash,
        txid_of_credit_purchase_burn_transaction: ticket.txid_of_credit_purchase_burn_transaction,
        credit_usage_tracking_psl_address: ticket.credit_usage_tracking_psl_address,
        psl_cost_per_credit: ticket.psl_cost_per_credit,
        requested_initial_credits_in_credit_pack: ticket.requested_initial_credits_in_credit_pack,
        credit_pack_current_credit_balance: ticket.credit_pack_current_credit_balance,
        balance_as_of_datetime: ticket.balance_as_of_datetime,
        number_of_confirmation_transactions: ticket.number_of_confirmation_transactions
      }));

      return processedTickets;
    } catch (error) {
      if (useVerbose) {
        logger.error(
          `Error retrieving valid credit pack tickets for PastelID: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      if (useVerbose) {
        throw error;
      }
      return [];
    }
  }


  async checkCreditPackBalance(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        credit_pack_ticket_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload("checking", "credit pack balance", payload);

      const response = await axios.post(
        `${supernodeURL}/check_credit_pack_balance`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const balanceInfo = response.data;
      logger.info(
        `Received credit pack balance info for txid ${txid}: ${JSON.stringify(
          balanceInfo
        )}`
      );
      return balanceInfo;
    } catch (error) {
      logger.error(
        `Error checking credit pack balance for txid ${txid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async getCreditPackTicketFromTxid(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = {
        txid,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "credit pack ticket from txid",
        params
      );

      const response = await axios.get(
        `${supernodeURL}/get_credit_pack_ticket_from_txid`,
        {
          params,
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const {
        credit_pack_purchase_request_response,
        credit_pack_purchase_request_confirmation,
      } = response.data;

      logActionWithPayload("received", "credit pack ticket from Supernode", {
        credit_pack_purchase_request_response,
        credit_pack_purchase_request_confirmation,
      });

      const { errorRequestResponse, value: validatedRequestResponse } =
        creditPackPurchaseRequestResponseSchema.validate(
          credit_pack_purchase_request_response
        );
      if (errorRequestResponse) {
        throw new Error(
          `Invalid credit pack request response: ${errorRequestResponse.message}`
        );
      }
      const { errorRequestConfirmation, value: validatedRequestConfirmation } =
        creditPackPurchaseRequestConfirmationSchema.validate(
          credit_pack_purchase_request_confirmation
        );
      if (errorRequestConfirmation) {
        throw new Error(
          `Invalid credit pack request confirmation: ${errorRequestConfirmation.message}`
        );
      }
      return {
        creditPackPurchaseRequestResponse:
          new CreditPackPurchaseRequestResponse(validatedRequestResponse),
        creditPackPurchaseRequestConfirmation:
          new CreditPackPurchaseRequestConfirmation(
            validatedRequestConfirmation
          ),
      };
    } catch (error) {
      logger.error(
        `Error retrieving credit pack ticket from txid: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async creditPackTicketInitialPurchaseRequest(
    supernodeURL,
    creditPackRequest
  ) {
    try {
      // Validate the credit pack request using Joi
      const { error, value: validatedCreditPackRequest } =
        creditPackPurchaseRequestSchema.validate(creditPackRequest.toJSON());
      if (error) {
        throw new Error(`Invalid credit pack request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      }
      // Create the credit pack purchase request in the database
      const _creditPackPurchaseRequestInstance =
        await CreditPackPurchaseRequest.create(validatedCreditPackRequest);
      logActionWithPayload(
        "requesting",
        "a new Pastel credit pack ticket",
        validatedCreditPackRequest
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      let preparedCreditPackRequest = await prepareModelForEndpoint(
        creditPackRequest
      );
      const response = await axios.post(
        `${supernodeURL}/credit_purchase_initial_request`,
        {
          challenge,
          challenge_id,
          challenge_signature,
          credit_pack_request: preparedCreditPackRequest,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      const result = response.data;

      if (result.rejection_reason_string) {
        logger.error(
          `Credit pack purchase request rejected: ${result.rejection_reason_string}`
        );
        let rejectionResponse = await prepareModelForValidation(result);
        const { rejectionError, value: validatedRejection } =
          await creditPackPurchaseRequestRejectionSchema.validateAsync(
            rejectionResponse
          );
        if (rejectionError) {
          throw new Error(
            `Invalid credit pack purchase request rejection: ${rejectionError.message}`
          );
        }
        const creditPackPurchaseRequestRejectionInstance =
          await CreditPackPurchaseRequestRejection.create(validatedRejection);
        return creditPackPurchaseRequestRejectionInstance;
      } else {
        logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          result
        );
        let preparedResult = await prepareModelForValidation(result);
        const { priceQuoteError, value: validatedPriceQuote } =
          await creditPackPurchaseRequestPreliminaryPriceQuoteSchema.validate(
            preparedResult
          );
        if (priceQuoteError) {
          throw new Error(
            "Invalid credit pack request: " + priceQuoteError.message
          );
        }
        const creditPackPurchaseRequestPreliminaryPriceQuoteInstance =
          await CreditPackPurchaseRequestPreliminaryPriceQuote.create(
            validatedPriceQuote
          );
        return creditPackPurchaseRequestPreliminaryPriceQuoteInstance;
      }
    } catch (error) {
      logger.error(
        `Error initiating credit pack ticket purchase: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async calculatePriceDifferencePercentage(quotedPrice, estimatedPrice) {
    if (estimatedPrice === 0) {
      throw new Error("Estimated price cannot be zero.");
    }
    const differencePercentage =
      Math.abs(quotedPrice - estimatedPrice) / estimatedPrice;
    return differencePercentage;
  }

  async confirmPreliminaryPriceQuote(
    preliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL,
    maximumPerCreditPriceInPSL
  ) {
    if (!maximumTotalCreditPackPriceInPSL && !maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL =
        process.env.MAXIMUM_PER_CREDIT_PRICE_IN_PSL_FOR_CLIENT;
    }
    const {
      preliminary_quoted_price_per_credit_in_psl: quotedPricePerCredit,
      preliminary_total_cost_of_credit_pack_in_psl: quotedTotalPrice,
      credit_pack_purchase_request_fields_json_b64: requestFieldsB64,
    } = preliminaryPriceQuote;
    let requestFields = JSON.parse(atob(requestFieldsB64)); // Decode base64 string
    const { requested_initial_credits_in_credit_pack: requestedCredits } =
      requestFields;
    if (!maximumTotalCreditPackPriceInPSL) {
      maximumTotalCreditPackPriceInPSL =
        maximumPerCreditPriceInPSL * requestedCredits;
    } else if (!maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL =
        maximumTotalCreditPackPriceInPSL / requestedCredits;
    }
    const estimatedPricePerCredit =
      await estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    const priceDifferencePercentage =
      await this.calculatePriceDifferencePercentage(
        quotedPricePerCredit,
        estimatedPricePerCredit
      );

    const numberFormat = new Intl.NumberFormat("en-US");
    const percentageFormat = (value) => value.toFixed(2);

    if (
      quotedPricePerCredit <= maximumPerCreditPriceInPSL &&
      quotedTotalPrice <= maximumTotalCreditPackPriceInPSL &&
      priceDifferencePercentage <=
      process.env
        .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING
    ) {
      logger.info(
        `Preliminary price quote is within the acceptable range: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, which is within the maximum of ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit and ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which is within the allowed maximum of ${percentageFormat(
          process.env
            .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING *
          100
        )}%. Please be patient while the new credit pack request is initialized.`
      );
      return true;
    } else {
      logger.warn(
        `Preliminary price quote exceeds the maximum acceptable price or the price difference from the estimated fair price is too high! Quoted price: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, maximum price: ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit, ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which exceeds the allowed maximum of ${percentageFormat(
          process.env
            .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING *
          100
        )}%.`
      );
      return false;
    }
  }

  async internalEstimateOfCreditPackTicketCostInPSL(
    desiredNumberOfCredits,
    priceCushionPercentage
  ) {
    const estimatedPricePerCredit =
      await estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    const estimatedTotalCostOfTicket =
      Math.round(
        desiredNumberOfCredits *
        estimatedPricePerCredit *
        (1 + priceCushionPercentage) *
        100
      ) / 100;
    return estimatedTotalCostOfTicket;
  }

  async creditPackTicketPreliminaryPriceQuoteResponse(
    supernodeURL,
    creditPackRequest,
    preliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL,
    maximumPerCreditPriceInPSL
  ) {
    try {
      if (preliminaryPriceQuote instanceof CreditPackPurchaseRequestRejection) {
        logger.error(
          `Credit pack purchase request rejected: ${preliminaryPriceQuote.rejection_reason_string}`
        );
        return preliminaryPriceQuote;
      }

      const agreeWithPriceQuote = await this.confirmPreliminaryPriceQuote(
        preliminaryPriceQuote,
        maximumTotalCreditPackPriceInPSL,
        maximumPerCreditPriceInPSL
      );

      logger.info(`Agree with price quote: ${agreeWithPriceQuote}; responding to preliminary price quote to Supernode at ${supernodeURL}...`);
      const priceQuoteResponse =
        CreditPackPurchaseRequestPreliminaryPriceQuoteResponse.build({
          sha3_256_hash_of_credit_pack_purchase_request_fields:
            creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
          sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
            preliminaryPriceQuote.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields,
          credit_pack_purchase_request_fields_json_b64:
            preliminaryPriceQuote.credit_pack_purchase_request_fields_json_b64,
          agree_with_preliminary_price_quote: agreeWithPriceQuote,
          credit_usage_tracking_psl_address:
            preliminaryPriceQuote.credit_usage_tracking_psl_address,
          preliminary_quoted_price_per_credit_in_psl: parseFloat(
            preliminaryPriceQuote.preliminary_quoted_price_per_credit_in_psl
          ),
          preliminary_price_quote_response_timestamp_utc_iso_string:
            getIsoStringWithMicroseconds(),
          preliminary_price_quote_response_pastel_block_height: parseInt(
            await getCurrentPastelBlockHeight(),
            10
          ),
          preliminary_price_quote_response_message_version_string: "1.0",
          requesting_end_user_pastelid:
            creditPackRequest.requesting_end_user_pastelid,
          sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
            "",
          requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
            "",
        });
      // Compute hashes and signatures
      priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields =
        await computeSHA3256HashOfSQLModelResponseFields(priceQuoteResponse);
      priceQuoteResponse.requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash =
        await signMessageWithPastelID(
          creditPackRequest.requesting_end_user_pastelid,
          priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields,
          this.passphrase
        );
      // Validate the price quote response
      const {
        error: priceQuoteValidationError,
        value: validatedPriceQuoteResponse,
      } =
        await creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema.validate(
          priceQuoteResponse.toJSON()
        );
      if (priceQuoteValidationError) {
        throw new Error(
          `Invalid price quote response: ${priceQuoteValidationError.message}`
        );
      }
      // Prepare model for endpoint before sending
      let preparedPriceQuoteResponse = await prepareModelForEndpoint(
        priceQuoteResponse
      );

      delete preparedPriceQuoteResponse["id"];
      preparedPriceQuoteResponse["agree_with_preliminary_price_quote"] =
        preparedPriceQuoteResponse["agree_with_preliminary_price_quote"]
          ? 1
          : 0;

      // Prepare and send the payload to the supernode
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const completePriceQuoteResponse = {
        challenge,
        challenge_id,
        challenge_signature,
        preliminary_price_quote_response: preparedPriceQuoteResponse,
      };

      const response = await axios.post(
        `${supernodeURL}/credit_purchase_preliminary_price_quote_response`,
        completePriceQuoteResponse,
        { timeout: 3 * MESSAGING_TIMEOUT_IN_SECONDS * 1000 }
      );
      const result = response.data;
      if (result.termination_reason_string) {
        logger.error(
          `Credit pack purchase request response terminated: ${result.termination_reason_string}`
        );
        const terminationResponse = await prepareModelForValidation(result);
        const { error: terminationError, value: validatedTermination } =
          await creditPackPurchaseRequestResponseTerminationSchema.validateAsync(
            terminationResponse
          );
        if (terminationError) {
          throw new Error(
            `Invalid credit pack purchase request response termination: ${terminationError.message}`
          );
        }
        const terminationInstance =
          await CreditPackPurchaseRequestResponseTermination.create(
            validatedTermination
          );
        return terminationInstance;
      } else {
        let transformedResult = transformCreditPackPurchaseRequestResponse(
          await prepareModelForValidation(result)
        );
        logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          transformedResult
        );
        const { error: resultError, value: validatedResponse } =
          await creditPackPurchaseRequestResponseSchema.validate(
            transformedResult
          );
        if (resultError) {
          throw new Error(
            `Invalid credit pack purchase request response: ${resultError.message}`
          );
        }
        const responseInstance = await CreditPackPurchaseRequestResponse.create(
          validatedResponse
        );
        return responseInstance;
      }
    } catch (error) {
      logger.error(
        `Error responding to preliminary price quote: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async confirmCreditPurchaseRequest(
    supernodeURL,
    creditPackPurchaseRequestConfirmation
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = await prepareModelForEndpoint(
        creditPackPurchaseRequestConfirmation
      );
      logActionWithPayload(
        "confirming",
        "credit pack purchase request",
        payload
      );
      const response = await axios.post(
        `${supernodeURL}/confirm_credit_purchase_request`,
        {
          confirmation: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 30 * 1000, // Need to be patient with the timeout here since it requires the transaction to be mined/confirmed
        }
      );
      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to credit pack purchase confirmation",
        result
      );
      const { error: validationError, value: validatedResult } =
        await creditPackPurchaseRequestConfirmationResponseSchema.validate(
          result
        );
      if (validationError) {
        throw new Error(
          `Invalid credit pack purchase request confirmation response: ${validationError.message}`
        );
      }
      const creditPackPurchaseRequestConfirmationResponseInstance =
        await CreditPackPurchaseRequestConfirmationResponse.create(result);
      return creditPackPurchaseRequestConfirmationResponseInstance;
    } catch (error) {
      logger.error(
        `Error confirming credit pack purchase request: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async checkStatusOfCreditPurchaseRequest(
    supernodeURL,
    creditPackPurchaseRequestHash
  ) {
    try {
      // Request challenge from the server
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      // Build and validate the status check model
      const statusCheck = CreditPackRequestStatusCheck.build({
        sha3_256_hash_of_credit_pack_purchase_request_fields:
          creditPackPurchaseRequestHash,
        requesting_end_user_pastelid: this.pastelID,
        requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
          await signMessageWithPastelID(
            this.pastelID,
            creditPackPurchaseRequestHash,
            this.passphrase
          ),
      });
      const { error: validationError, value: validatedStatusCheck } =
        await creditPackRequestStatusCheckSchema.validate(statusCheck.toJSON());
      if (validationError) {
        logger.error(
          `Invalid credit pack request status check: ${validationError.message}`
        );
        throw new Error(
          `Invalid credit pack request status check: ${validationError.message}`
        );
      }
      delete validatedStatusCheck["id"];
      logActionWithPayload(
        "checking",
        "status of credit pack purchase request",
        validatedStatusCheck
      );
      // Send the request to the server
      const response = await axios.post(
        `${supernodeURL}/check_status_of_credit_purchase_request`,
        {
          credit_pack_request_status_check: validatedStatusCheck,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      // Check response status and handle any errors
      if (response.status !== 200) {
        throw new Error(
          `HTTP error ${response.status}: ${response.statusText}`
        );
      }
      logActionWithPayload(
        "receiving",
        "credit pack purchase request response from Supernode",
        response.data
      );
      // Validate the received result
      let transformedResult = await prepareModelForValidation(response.data);
      delete transformedResult["id"];
      const { error: resultError, value: validatedResult } =
        await creditPackPurchaseRequestStatusSchema.validate(transformedResult);
      if (resultError) {
        throw new Error(
          `Invalid credit pack purchase request status: ${resultError.message}`
        );
      }
      // Create and return the status instance from the validated result
      const statusInstance = await CreditPackPurchaseRequestStatus.create(
        validatedResult
      );
      return statusInstance;
    } catch (error) {
      logger.error(
        `Error checking status of credit purchase request: ${safeStringify(
          error.message
        )}`
      );
      throw error; // Rethrow to handle error upstream
    }
  }

  async creditPackPurchaseCompletionAnnouncement(
    supernodeURL,
    creditPackPurchaseRequestConfirmation
  ) {
    try {
      // Validate the incoming data
      const { error, value: validatedConfirmation } =
        await creditPackPurchaseRequestConfirmationSchema.validate(
          creditPackPurchaseRequestConfirmation.toJSON()
        );
      if (error) {
        logger.error(
          `Invalid credit pack purchase request confirmation: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        return; // Return early instead of throwing an error
      }

      // Request challenge from the server
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      // Prepare the model for the endpoint
      let payload = validatedConfirmation;
      delete payload["id"]; // Removing the 'id' key as done in the Python method

      // Send the request to the server with a shortened timeout
      const response = await axios.post(
        `${supernodeURL}/credit_pack_purchase_completion_announcement`,
        {
          confirmation: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: 2 * 1000, // Shortened timeout of 2 seconds
        }
      );

      // Check response status and log any errors
      if (response.status !== 200) {
        logger.error(`HTTP error ${response.status}: ${response.statusText}`);
      } else {
        logger.info(
          `Credit pack purchase completion announcement sent successfully to ${supernodeURL}`
        );
      }
    } catch (error) {
      // Log the error without rethrowing to prevent upstream disruption
      if (error.response) {
        logger.error(
          `HTTP error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.response.status} ${error.response.statusText}`
        );
      } else if (error.code === "ECONNABORTED") {
        logger.error(
          `Timeout error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      } else {
        logger.error(
          `Error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.message || error
          }`
        );
      }
    }
  }

  async creditPackStorageRetryRequest(
    supernodeURL,
    creditPackStorageRetryRequest
  ) {
    try {
      const { error, value: validatedRequest } =
        await creditPackStorageRetryRequestSchema.validate(
          creditPackStorageRetryRequest.toJSON()
        );
      if (error) {
        throw new Error(
          `Invalid credit pack storage retry request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }

      const requestInstance = await CreditPackStorageRetryRequest.create(
        validatedRequest
      );

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(requestInstance);
      logActionWithPayload(
        "sending",
        "credit pack storage retry request",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/credit_pack_storage_retry_request`,
        {
          request: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to credit pack storage retry request",
        result
      );

      let transformedResult = await prepareModelForValidation(result);
      const { error: responseError, value: validatedResponse } =
        await creditPackStorageRetryRequestResponseSchema.validate(
          transformedResult
        );
      if (responseError) {
        throw new Error(
          `Invalid credit pack storage retry request response: ${responseError.message}`
        );
      }

      const responseInstance =
        await CreditPackStorageRetryRequestResponse.create(validatedResponse);
      return responseInstance;
    } catch (error) {
      logger.error(
        `Error sending credit pack storage retry request: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async creditPackStorageRetryCompletionAnnouncement(
    supernodeURL,
    creditPackStorageRetryRequestResponse
  ) {
    try {
      const { error, value: validatedResponse } =
        await creditPackStorageRetryRequestResponseSchema.validate(
          creditPackStorageRetryRequestResponse.toJSON()
        );
      if (error) {
        throw new Error(
          `Invalid credit pack storage retry request response: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }

      const responseInstance =
        await CreditPackStorageRetryRequestResponse.create(validatedResponse);

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(responseInstance);
      logActionWithPayload(
        "sending",
        "storage retry completion announcement message",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/credit_pack_storage_retry_completion_announcement`,
        {
          response: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      response.data; // Access the response data to trigger any potential errors
    } catch (error) {
      logger.error(
        `Error sending credit pack storage retry completion announcement: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async retrieveCreditPackTicketFromPurchaseBurnTxid(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "credit pack ticket from purchase burn txid",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/retrieve_credit_pack_ticket_from_purchase_burn_txid`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const ticketInfo = response.data;
      logger.info(
        `Received credit pack ticket for purchase burn txid ${txid}: ${JSON.stringify(
          ticketInfo
        )}`
      );
      return ticketInfo;
    } catch (error) {
      logger.error(
        `Error retrieving credit pack ticket for purchase burn txid ${txid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async getFinalCreditPackRegistrationTxidFromPurchaseBurnTxid(
    supernodeURL,
    purchaseBurnTxid
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: purchaseBurnTxid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "final credit pack registration txid",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/get_final_credit_pack_registration_txid_from_credit_purchase_burn_txid`,
        payload,
        { timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000 }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const finalTxid = response.data.final_credit_pack_registration_txid;
      logger.info(
        `Received final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${finalTxid}`
      );
      return finalTxid;
    } catch (error) {
      logger.error(
        `Error retrieving final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async makeInferenceAPIUsageRequest(supernodeURL, requestData) {
    try {
      const { error, value: validatedRequest } =
        await inferenceAPIUsageRequestSchema.validate(requestData.toJSON());
      if (error) {
        throw new Error(
          `Invalid inference API usage request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      delete validatedRequest["id"];
      const requestInstance = await InferenceAPIUsageRequest.create(
        validatedRequest
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = await prepareModelForEndpoint(requestInstance);
      logActionWithPayload(
        "making",
        "inference usage request",
        validatedRequest
      );
      const response = await axios.post(
        `${supernodeURL}/make_inference_api_usage_request`,
        {
          inference_api_usage_request: validatedRequest,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 6 * 1000,
        }
      );
      const result = response.data;
      logActionWithPayload(
        "received",
        "response to inference usage request",
        result
      );
      let transformedResult = await prepareModelForValidation(result);
      delete transformedResult["id"];
      const { error: responseError, value: validatedResponse } =
        await inferenceAPIUsageResponseSchema.validate(transformedResult);
      if (responseError) {
        throw new Error(
          `Invalid inference API usage response: ${responseError.message}`
        );
      }
      const responseInstance = await InferenceAPIUsageResponse.create(
        validatedResponse
      );
      return responseInstance;
    } catch (error) {
      logger.error(
        `Error making inference API usage request: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async sendInferenceConfirmation(supernodeURL, confirmationData) {
    try {
      const confirmationDataJSON = confirmationData.toJSON();
      // Remove the 'id' field from the JSON object
      delete confirmationDataJSON["id"];

      const { error, value: validatedConfirmation } =
        await inferenceConfirmationSchema.validate(confirmationDataJSON);
      if (error) {
        throw new Error(
          `Invalid inference confirmation data: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      const confirmationInstance = await InferenceConfirmation.create(
        validatedConfirmation
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(confirmationInstance);
      logActionWithPayload("sending", "inference confirmation", payload);
      const response = await axios.post(
        `${supernodeURL}/confirm_inference_request`,
        {
          inference_confirmation: confirmationDataJSON,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 4 * 1000,
        }
      );
      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to inference confirmation",
        result
      );

      return result;
    } catch (error) {
      logger.error(
        `Error sending inference confirmation: ${safeStringify(error.message)}`
      );
      throw error;
    }
  }
  async checkStatusOfInferenceRequestResults(
    supernodeURL,
    inferenceResponseID
  ) {
    try {
      logger.info(
        `Checking status of inference request results for ID ${inferenceResponseID}`
      );

      const response = await axios.get(
        `${supernodeURL}/check_status_of_inference_request_results/${inferenceResponseID}`,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      const result = response.data;
      logActionWithPayload(
        "receiving",
        `status of inference request results for ID ${inferenceResponseID}`,
        result
      );

      return typeof result === "boolean" ? result : false;
    } catch (error) {
      if (error.response) {
        logger.error(
          `HTTP error checking status of inference request results from Supernode URL: ${supernodeURL}: ${safeStringify(
            error
          )}`
        );
      } else {
        logger.error(
          `Error checking status of inference request results from Supernode URL: ${supernodeURL}: ${safeStringify(
            error
          )}`
        );
      }
      return false;
    }
  }

  async retrieveInferenceOutputResults(
    supernodeURL,
    inferenceRequestID,
    inferenceResponseID
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = new URLSearchParams({
        inference_response_id: inferenceResponseID,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      }).toString();
      logActionWithPayload(
        "attempting",
        `to retrieve inference output results for response ID ${inferenceResponseID}`,
        params
      );
      const response = await axios.post(
        `${supernodeURL}/retrieve_inference_output_results?${params}`,
        {}, // No data object needed since we're sending parameters in the URL
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 4 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      logActionWithPayload("receiving", "inference output results", result);
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIOutputResultSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API output result: ${validationError.message}`
        );
      }
      const resultInstance = await InferenceAPIOutputResult.create(
        validatedResult
      );
      return resultInstance;
    } catch (error) {
      logger.error(
        `Error retrieving inference output results: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResponse(supernodeURL, inferenceResponseID) {
    try {
      const signature = await signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await axios.post(
        `${supernodeURL}/audit_inference_request_response`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 2 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIUsageResponseSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API usage response: ${validationError.message}`
        );
      }
      return validatedResult;
    } catch (error) {
      logger.error(
        `Error calling audit inference request response from Supernode URL: ${supernodeURL}: ${safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResult(supernodeURL, inferenceResponseID) {
    try {
      const signature = await signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await axios.post(
        `${supernodeURL}/audit_inference_request_result`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 2 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIOutputResultSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API output result: ${validationError.message}`
        );
      }
      return validatedResult;
    } catch (error) {
      logger.error(
        `Error calling audit inference request result from Supernode URL: ${supernodeURL}: ${safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async auditInferenceRequestResponseID(
    inferenceResponseID,
    pastelIDOfSupernodeToAudit
  ) {
    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const filteredSupernodes = await filterSupernodes(validMasternodeListFullDF);

      const supernodeURLsAndPastelIDs = filteredSupernodes
        .filter(({ pastelID }) => pastelID !== pastelIDOfSupernodeToAudit)
        .slice(0, 5); // Get the 5 closest supernodes

      const listOfSupernodePastelIDs = supernodeURLsAndPastelIDs.map(({ pastelID }) => pastelID);
      const listOfSupernodeURLs = supernodeURLsAndPastelIDs.map(({ url }) => url);
      const listOfSupernodeIPs = listOfSupernodeURLs.map(
        (url) => url.split("//")[1].split(":")[0]
      );

      logger.info(
        `Now attempting to audit inference request response with ID ${inferenceResponseID} with ${listOfSupernodePastelIDs.length} closest supernodes (with Supernode IPs of ${listOfSupernodeIPs})...`
      );

      const responseAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResponse(url, inferenceResponseID)
      );
      const responseAuditResults = await Promise.all(responseAuditTasks);

      await new Promise((resolve) => setTimeout(resolve, 20000));

      logger.info(
        `Now attempting to audit inference request result for response ID ${inferenceResponseID} by comparing information from other Supernodes to the information reported by the Responding Supernode...`
      );

      const resultAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResult(url, inferenceResponseID)
      );
      const resultAuditResults = await Promise.all(resultAuditTasks);

      const auditResults = [...responseAuditResults, ...resultAuditResults];
      logger.info(
        `Audit results retrieved for inference response ID ${inferenceResponseID}`
      );

      return auditResults;
    } catch (error) {
      logger.error(
        `Error auditing inference request response ID: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async checkIfSupernodeSupportsDesiredModel(
    supernodeURL,
    modelCanonicalString,
    modelInferenceTypeString,
    modelParametersJSON
  ) {
    try {
      const response = await axios.get(
        `${supernodeURL}/get_inference_model_menu`,
        {
          timeout: 8 * 1000,
        }
      );

      const modelMenu = response.data;
      const desiredParameters = JSON.parse(modelParametersJSON);

      for (const model of modelMenu.models) {
        if (
          model.model_name === modelCanonicalString &&
          model.supported_inference_type_strings.includes(
            modelInferenceTypeString
          )
        ) {
          const unsupportedParameters = [];

          for (const [desiredParam, desiredValue] of Object.entries(
            desiredParameters
          )) {
            let paramFound = false;

            for (const param of model.model_parameters) {
              if (
                param.name === desiredParam &&
                param.inference_types_parameter_applies_to.includes(
                  modelInferenceTypeString
                )
              ) {
                if ("type" in param) {
                  if (
                    param.type === "int" &&
                    Number.isInteger(Number(desiredValue))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "float" &&
                    !isNaN(parseFloat(desiredValue))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "string" &&
                    typeof desiredValue === "string"
                  ) {
                    if (
                      "options" in param &&
                      param.options.includes(desiredValue)
                    ) {
                      paramFound = true;
                    } else if (!("options" in param)) {
                      paramFound = true;
                    }
                  }
                } else {
                  paramFound = true;
                }
                break;
              }
            }

            if (!paramFound) {
              unsupportedParameters.push(desiredParam);
            }
          }

          if (unsupportedParameters.length === 0) {
            return true;
          } else {
            const unsupportedParamStr = unsupportedParameters.join(", ");
            logger.error(
              `Unsupported model parameters for ${modelCanonicalString}: ${unsupportedParamStr}`
            );
            return false;
          }
        }
      }
      return false;
    } catch (error) {
      return false;
    }
  }

  async getClosestSupernodeURLsThatSupportsDesiredModel(
    desiredModelCanonicalString,
    desiredModelInferenceTypeString,
    desiredModelParametersJSON,
    N = 12 // Limit to 12 supernodes
  ) {
    const timeoutPeriod = 3000; // Timeout period in milliseconds

    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const filteredSupernodes = await filterSupernodes(validMasternodeListFullDF);

      // Prepare all the promises for checking supernodes concurrently
      const checkSupernodePromises = filteredSupernodes.map((supernode) => {
        const startTime = Date.now(); // Capture the start time for the supernode check

        return Promise.race([
          this.checkIfSupernodeSupportsDesiredModel(
            supernode.url,
            desiredModelCanonicalString,
            desiredModelInferenceTypeString,
            desiredModelParametersJSON
          ).then((result) => ({
            result,
            url: supernode.url,
            responseTime: Date.now() - startTime // Capture the response time
          })),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), timeoutPeriod)
          )
        ]).catch(() => null); // Silently catch and return null for failed requests
      });

      // Wait for all promises to settle
      const results = await Promise.allSettled(checkSupernodePromises);

      // Filter out null or rejected results
      const validResponses = results
        .filter((res) => res.status === 'fulfilled' && res.value !== null)
        .map((res) => res.value);

      // Sort the valid responses by their response times (fastest first)
      const sortedResponses = validResponses.sort((a, b) => a.responseTime - b.responseTime);

      // Return the closest N supernodes, capped at the number available
      return sortedResponses.slice(0, N).map((response) => response.url);
    } catch (error) {
      throw new Error(`Failed to get closest supernodes: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    }
  }


}

module.exports = {
  PastelInferenceClient,
};


---
./rpc_functions.js
---
// rpc_functions.js

require("dotenv").config();
const http = require("http");
const https = require("https");
const fs = require("fs");
const os = require("os");
const path = require("path");
const readline = require("readline");
const { URL } = require("url");
const axios = require("axios");
const Joi = require("joi");
const { SupernodeList } = require("./sequelize_data_models");
const { messageSchema, supernodeListSchema } = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const { execSync, spawn } = require("child_process");
const storage = require("node-persist");
const { setPastelIdAndPassphrase } = require("./storage");
let rpc_connection;
const globals = require("./globals");

// Initialize the storage
storage.init();

async function searchBinaryRecursively(directory, binaryName) {
  try {
    const result = execSync(
      `sudo find ${directory} -type f -name ${binaryName} -size +7M`,
      { encoding: "utf-8" }
    );
    return result.trim().split("\n").filter(Boolean);
  } catch (error) {
    return [];
  }
}

async function getMostRecentBinary(binaries) {
  const stats = await Promise.all(
    binaries.map(async (binary) => {
      const stat = await fs.promises.stat(binary);
      return { binary, mtime: stat.mtime };
    })
  );
  return stats.sort((a, b) => b.mtime - a.mtime)[0]?.binary;
}

async function locatePasteldBinary() {
  await storage.init();
  let pasteldBinaryPath = await storage.getItem("pasteldBinaryPath");
  if (!pasteldBinaryPath || !fs.existsSync(pasteldBinaryPath)) {
    const searchDirectories = ["/home", "/usr/local/bin", "/usr/bin"];
    if (process.platform === "win32") {
      searchDirectories.push(process.env.ProgramFiles);
    } else if (process.platform === "darwin") {
      searchDirectories.push("/Users");
    } else {
      searchDirectories.push("/home", "/etc");
    }
    const foundBinaries = (
      await Promise.all(
        searchDirectories.map((dir) => searchBinaryRecursively(dir, "pasteld"))
      )
    ).flat();
    pasteldBinaryPath = await getMostRecentBinary(foundBinaries);
    if (!pasteldBinaryPath) {
      throw new Error("pasteld binary not found on the system.");
    }
    await storage.setItem("pasteldBinaryPath", pasteldBinaryPath);
  }
  return pasteldBinaryPath;
}

async function startPastelDaemon() {
  try {
    const pasteldPath = await locatePasteldBinary();
    console.log(`Starting pasteld from path: ${pasteldPath}`);

    const pastelDaemon = spawn(pasteldPath, [], { stdio: "inherit" });

    pastelDaemon.on("close", (code) => {
      console.log(`pasteld process exited with code ${code}`);
    });

    pastelDaemon.on("error", (err) => {
      console.error("Error starting pasteld:", err);
    });
  } catch (error) {
    console.error("Failed to start pasteld:", error);
  }
}

async function getMostRecentFile(files) {
  return files
    .map((file) => ({ file, mtime: fs.statSync(file).mtime }))
    .sort((a, b) => b.mtime - a.mtime)[0]?.file;
}

function searchFileRecursively(directory, filename) {
  try {
    const results = [];

    function searchRecursive(currentPath) {
      const files = fs.readdirSync(currentPath);

      for (const file of files) {
        const filePath = path.join(currentPath, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
          searchRecursive(filePath);
        } else if (file === filename) {
          results.push(filePath);
        }
      }
    }

    searchRecursive(directory);
    return results;
  } catch (error) {
    console.error(`Error searching for file: ${error.message}`);
    return [];
  }
}

async function getLocalRPCSettings(
  directoryWithPastelConf = path.join(os.homedir(), ".pastel")
) {
  let newDirectoryWithPastelConf = directoryWithPastelConf;
  if (process.platform === "win32") {
    newDirectoryWithPastelConf = path.join(os.homedir(), "AppData", "Roaming", "Pastel")
  }
  if (process.platform === "darwin") {
    newDirectoryWithPastelConf = path.join(os.homedir(), "Library", "Application Support", "Pastel")
  }
  if (['darwin', 'linux'].indexOf(process.platform) !== -1) {
    newDirectoryWithPastelConf = newDirectoryWithPastelConf.replace(/ /g, '\\ ')
  }
  await storage.init();
  let pastelConfPath =
    (await storage.getItem("pastelConfPath")) ||
    path.join(newDirectoryWithPastelConf, "pastel.conf");
  if (!fs.existsSync(pastelConfPath)) {
    console.log(
      `pastel.conf not found in stored path or default directory, scanning the system...`
    );
    const searchDirectories = ["/home"];
    if (process.platform === "win32") {
      searchDirectories.push(process.env.ProgramData);
    } else if (process.platform === "darwin") {
      searchDirectories.push(path.join(os.homedir(), "Library", "Application Support", "Pastel"));
    } else {
      searchDirectories.push("/home", "/etc");
    }
    const foundFiles = searchDirectories.flatMap((dir) =>
      searchFileRecursively(dir, "pastel.conf")
    );
    pastelConfPath = await getMostRecentFile(foundFiles);
    if (!pastelConfPath) {
      throw new Error("pastel.conf file not found on the system.");
    }
    await storage.setItem("pastelConfPath", pastelConfPath);
  }
  const lines = fs.readFileSync(pastelConfPath, "utf-8").split("\n");
  const otherFlags = {};
  let rpchost = "127.0.0.1";
  let rpcport = "19932";
  let rpcuser = "";
  let rpcpassword = "";
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine || trimmedLine.startsWith("#")) {
      continue; // Ignore blank lines and comments
    }
    if (trimmedLine.includes("=")) {
      const [key, value] = trimmedLine.split("=", 2);
      const trimmedKey = key.trim();
      const trimmedValue = value.trim();

      if (trimmedKey === "rpcport") {
        rpcport = trimmedValue;
      } else if (trimmedKey === "rpcuser") {
        rpcuser = trimmedValue;
      } else if (trimmedKey === "rpcpassword") {
        rpcpassword = trimmedValue;
      } else if (trimmedKey === "rpchost") {
        rpchost = trimmedValue;
      } else {
        otherFlags[trimmedKey] = trimmedValue;
      }
    }
  }
  return { rpchost, rpcport, rpcuser, rpcpassword, otherFlags };
}

class JSONRPCException extends Error {
  constructor(rpcError) {
    super(rpcError.message);
    this.error = rpcError;
    this.code = rpcError.code || null;
    this.message = rpcError.message || null;
  }
  toString() {
    return `${this.code}: ${this.message}`;
  }
}

class Semaphore {
  constructor(maxConcurrent) {
    this.maxConcurrent = maxConcurrent;
    this.counter = maxConcurrent;
    this.waiting = [];
  }
  async acquire() {
    if (this.counter <= 0) {
      await new Promise((resolve) => this.waiting.push(resolve));
    }
    this.counter--;
  }
  release() {
    this.counter++;
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift();
      resolve();
    }
  }
}

class AsyncAuthServiceProxy {
  static maxConcurrentRequests = 5000;
  static semaphore = new Semaphore(AsyncAuthServiceProxy.maxConcurrentRequests);

  constructor(
    serviceUrl,
    serviceName = null,
    reconnectTimeout = 15,
    reconnectAmount = 2,
    requestTimeout = 20
  ) {
    this.serviceUrl = serviceUrl;
    this.serviceName = serviceName;
    this.url = new URL(serviceUrl);
    this.client = axios.create({
      timeout: requestTimeout * 1000,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      httpAgent: new http.Agent({ keepAlive: true, maxSockets: 200 }),
      httpsAgent: new https.Agent({ keepAlive: true, maxSockets: 200 }),
    });
    this.idCount = 0;
    const { username, password } = this.url;
    const authPair = `${username}:${password}`;
    this.authHeader = `Basic ${Buffer.from(authPair).toString("base64")}`;
    this.reconnectTimeout = reconnectTimeout;
    this.reconnectAmount = reconnectAmount;
    this.requestTimeout = requestTimeout;
  }

  async call(methodName, ...args) {
    await AsyncAuthServiceProxy.semaphore.acquire();
    try {
      this.idCount += 1;
      const postData = JSON.stringify({
        jsonrpc: "2.0",
        method: methodName,
        params: args,
        id: this.idCount,
      });
      const headers = {
        Host: this.url.hostname,
        "User-Agent": "AuthServiceProxy/0.1",
        Authorization: this.authHeader,
        "Content-Type": "application/json",
      };

      let response;
      for (let i = 0; i < this.reconnectAmount; i++) {
        try {
          if (i > 0) {
            const sleepTime = this.reconnectTimeout * 2 ** i;
            logger.error(`Reconnect try #${i + 1}`);
            logger.info(`Waiting for ${sleepTime} seconds before retrying.`);
            await new Promise((resolve) =>
              setTimeout(resolve, sleepTime * 1000)
            );
          }
          response = await this.client.post(this.serviceUrl, postData, {
            headers,
          });
          break;
        } catch (error) {
          logger.error(`Error occurred on attempt ${i + 1}: ${error}`);
          if (i === this.reconnectAmount - 1) {
            logger.error("Reconnect tries exceeded.");
            throw error;
          }
        }
      }
      if (!response) {
        throw new Error("No response from server, all retry attempts failed.");
      }
      const responseJson = response.data;
      if (responseJson.error) {
        throw new JSONRPCException(responseJson.error);
      } else if (!("result" in responseJson)) {
        throw new JSONRPCException({
          code: -343,
          message: "Missing JSON-RPC result",
        });
      }
      return responseJson.result;
    } finally {
      AsyncAuthServiceProxy.semaphore.release();
    }
  }

  // Create a proxy to handle method calls dynamically
  static create(serviceUrl) {
    const handler = {
      get: function (target, propKey) {
        if (typeof target[propKey] === "function") {
          return function (...args) {
            return target[propKey](...args);
          };
        } else {
          return function (...args) {
            return target.call(propKey, ...args);
          };
        }
      },
    };
    return new Proxy(new AsyncAuthServiceProxy(serviceUrl), handler);
  }
}

async function initializeRPCConnection() {
  const { rpchost, rpcport, rpcuser, rpcpassword } =
    await getLocalRPCSettings();
  rpc_connection = AsyncAuthServiceProxy.create(
    `http://${rpcuser}:${rpcpassword}@${rpchost}:${rpcport}`
  );
}

async function waitForRPCConnection(maxRetries = 5, interval = 1000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    if (rpc_connection) {
      return true; // Connection is available
    }
    logger.info(
      `Waiting for RPC connection... Attempt ${attempt}/${maxRetries}`
    );
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  logger.error("Failed to establish RPC connection after several attempts.");
  return false; // Connection is not available after retries
}

async function checkMasternodeTop() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const masternodeTopOutput = await rpc_connection.masternode("top");
  return masternodeTopOutput;
}

async function stopPastelDaemon() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const masternodeTopOutput = await rpc_connection.stop();
  return masternodeTopOutput;
}

async function getCurrentPastelBlockHeight() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const bestBlockHash = await rpc_connection.getbestblockhash();
  const bestBlockDetails = await rpc_connection.getblock(bestBlockHash);
  const currentBlockHeight = bestBlockDetails.height;
  return currentBlockHeight;
}

async function getBestBlockHashAndMerkleRoot() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const bestBlockHeight = await getCurrentPastelBlockHeight();
  const bestBlockHash = await rpc_connection.getblockhash(bestBlockHeight);
  const bestBlockDetails = await rpc_connection.getblock(bestBlockHash);
  const bestBlockMerkleRoot = bestBlockDetails.merkleroot;
  return [bestBlockHash, bestBlockMerkleRoot, bestBlockHeight];
}

async function verifyMessageWithPastelID(
  pastelid,
  messageToVerify,
  pastelIDSignatureOnMessage
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const verificationResult = await rpc_connection.pastelid(
    "verify",
    messageToVerify,
    pastelIDSignatureOnMessage,
    pastelid,
    "ed448"
  );
  return verificationResult.verification; // Return the verification result
}

async function sendToAddress(
  address,
  amount,
  comment = "",
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return { success: false, message: "RPC connection is not available" };
  }
  try {
    // Check available balance
    const balance = await getBalance();
    if (balance < amount) {
      const message = `Insufficient balance. Available: ${balance}, Required: ${amount}`;
      logger.error(message);
      return { success: false, message };
    }
    // Proceed with sending the amount
    const result = await rpc_connection.sendtoaddress(
      address,
      amount,
      comment,
    );
    return { success: true, result };
  } catch (error) {
    logger.error(`Error in sendToAddress: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return {
      success: false,
      message: `Error in sendToAddress: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`,
    };
  }
}

async function sendMany(
  amounts,
  minConf = 1,
  comment = "",
  changeAddress = ""
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const fromAccount = "";
    const result = await rpc_connection.sendmany(
      fromAccount,
      amounts,
      minConf,
      comment,
      [""],
      changeAddress
    );
    return result;
  } catch (error) {
    logger.error(`Error in sendMany: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return null;
  }
}

async function checkPSLAddressBalance(addressToCheck) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const balance = await rpc_connection.z_getbalance(addressToCheck);
  return balance;
}

async function checkIfAddressIsAlreadyImportedInLocalWallet(addressToCheck) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const addressAmounts = await rpc_connection.listaddressamounts();
  const addressAmountsArray = Object.entries(addressAmounts).map(
    ([address, amount]) => ({ address, amount })
  );
  const filteredAddressAmounts = addressAmountsArray.filter(
    (entry) => entry.address === addressToCheck
  );
  return filteredAddressAmounts.length > 0;
}

async function getAndDecodeRawTransaction(txid, blockhash = null) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const rawTxData = await rpc_connection.getrawtransaction(
      txid,
      0,
      blockhash
    );
    if (!rawTxData) {
      logger.error(`Failed to retrieve raw transaction data for ${txid}`);
      return {};
    }
    const decodedTxData = await rpc_connection.decoderawtransaction(rawTxData);
    if (!decodedTxData) {
      logger.error(`Failed to decode raw transaction data for ${txid}`);
      return {};
    }
    logger.debug(
      `Decoded transaction details for ${txid}:`,
      safeStringify(decodedTxData)
    );
    return decodedTxData;
  } catch (error) {
    logger.error(
      `Error in getAndDecodeRawTransaction for ${txid}:`,
      safeStringify(error)
    );
    return {};
  }
}

async function getTransactionDetails(txid, includeWatchonly = false) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const transactionDetails = await rpc_connection.gettransaction(
      txid,
      includeWatchonly
    );
    logger.debug(
      `Retrieved transaction details for ${txid}:`,
      safeStringify(transactionDetails)
    );
    return transactionDetails;
  } catch (error) {
    logger.error(
      `Error retrieving transaction details for ${txid}:`,
      safeStringify(error)
    );
    return {};
  }
}

async function sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
  inferenceRequestId,
  creditUsageTrackingPSLAddress,
  creditUsageTrackingAmountInPSL,
  burnAddress
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const amounts = {
      [burnAddress]: creditUsageTrackingAmountInPSL,
    };
    const txid = await sendMany(
      amounts,
      0,
      "Confirmation tracking transaction for inference request with request_id " +
      inferenceRequestId,
      creditUsageTrackingPSLAddress
    );
    if (txid) {
      logger.info(
        `Sent ${creditUsageTrackingAmountInPSL} PSL from ${creditUsageTrackingPSLAddress} to ${burnAddress} to confirm inference request ${inferenceRequestId}. TXID: ${txid}`
      );
      const transactionInfo = await rpc_connection.gettransaction(txid);
      if (transactionInfo) {
        return txid;
      } else {
        logger.error(
          `No transaction info found for TXID: ${txid} to confirm inference request ${inferenceRequestId}`
        );
      }
      return null;
    } else {
      logger.error(
        `Failed to send ${creditUsageTrackingAmountInPSL} PSL from ${creditUsageTrackingPSLAddress} to ${burnAddress} to confirm inference request ${inferenceRequestId}`
      );
      return null;
    }
  } catch (error) {
    logger.error(
      "Error in sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest:",
      error
    );
    throw error;
  }
}

async function importAddress(address, label = "", rescan = false) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    await rpc_connection.importaddress(address, label, rescan);
    logger.info(`Imported address: ${address}`);
  } catch (error) {
    logger.error(
      `Error importing address: ${address}. Error:`,
      safeStringify(error)
    );
  }
}

async function getBlockHash(blockHeight) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const blockHash = await rpc_connection.getblockhash(blockHeight);
    return blockHash;
  } catch (error) {
    logger.error(
      `Error in getBlockHash for block height ${blockHeight}:`,
      error
    );
    return null;
  }
}

async function getBlock(blockHash) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const block = await rpc_connection.getblock(blockHash);
    return block;
  } catch (error) {
    logger.error(
      `Error in getBlock for block hash ${blockHash}:`,
      safeStringify(error)
    );
    return null;
  }
}

async function signMessageWithPastelID(pastelid, messageToSign, passphrase) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const responseObj = await rpc_connection.pastelid(
      "sign",
      messageToSign,
      pastelid,
      passphrase,
      "ed448"
    );
    return responseObj.signature;
  } catch (error) {
    logger.error(`Error in signMessageWithPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return null;
  }
}

async function checkPSLAddressBalanceAlternative(addressToCheck) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const addressAmountsDict = await rpc_connection.listaddressamounts();
    // Convert the object into an array of objects, each representing a row
    const data = Object.entries(addressAmountsDict).map(
      ([address, amount]) => ({ address, amount })
    );
    // Filter the array for the specified address
    const filteredData = data.filter((item) => item.address === addressToCheck);
    // Calculate the sum of the 'amount' column for the filtered array
    const balanceAtAddress = filteredData.reduce(
      (acc, item) => acc + item.amount,
      0
    );
    return balanceAtAddress;
  } catch (error) {
    logger.error(
      `Error in checkPSLAddressBalanceAlternative: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function formatNumberWithCommas(number) {
  return new Intl.NumberFormat("en-US").format(number);
}

async function getMyPslAddressWithLargestBalance() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const addressAmounts = await rpc_connection.listaddressamounts();
    const addressWithLargestBalance = Object.keys(addressAmounts).reduce(
      (maxAddress, currentAddress) => {
        return addressAmounts[currentAddress] >
          (addressAmounts[maxAddress] || 0)
          ? currentAddress
          : maxAddress;
      },
      null
    );
    return addressWithLargestBalance;
  } catch (error) {
    logger.error(
      `Error in getMyPslAddressWithLargestBalance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

async function createAndFundNewPSLCreditTrackingAddress(
  amountOfPSLToFundAddressWith
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const extraCushion = 1.0; // Add an extra PSL to the funding address to ensure it has a minimum balance
  try {
    const newCreditTrackingAddress = await rpc_connection.getnewaddress();
    const sendResult = await sendToAddress(
      newCreditTrackingAddress,
      amountOfPSLToFundAddressWith + extraCushion,
      "Funding new credit tracking address",
    );
    if (!sendResult.success) {
      logger.error(
        `Error funding new credit tracking address ${newCreditTrackingAddress} with ${formatNumberWithCommas(
          amountOfPSLToFundAddressWith
        )} PSL. Reason: ${sendResult.message}`
      );
      return null; // Or handle the error accordingly
    }
    logger.info(
      `Funded new credit tracking address ${newCreditTrackingAddress} with ${formatNumberWithCommas(
        amountOfPSLToFundAddressWith
      )} PSL. TXID: ${sendResult.result}`
    );
    return { newCreditTrackingAddress, txid: sendResult.result };
  } catch (error) {
    logger.error(
      `Error creating and funding new PSL credit tracking address: ${safeStringify(
        error
      )}`
    );
    throw error;
  }
}

async function waitForTableCreation() {
  const maxRetries = 5;
  const retryDelay = 1000; // 1 second
  for (let i = 0; i < maxRetries; i++) {
    try {
      await SupernodeList.findOne();
      return; // Table exists, proceed with data insertion
    } catch (error) {
      if (
        error.name === "SequelizeDatabaseError" &&
        error.original.code === "SQLITE_ERROR" &&
        error.original.errno === 1
      ) {
        // Table doesn't exist, wait and retry
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
      } else {
        throw error; // Rethrow other errors
      }
    }
  }
  throw new Error("Table creation timed out.");
}

async function checkSupernodeList() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const [
      masternodeListFull,
      masternodeListRank,
      masternodeListPubkey,
      masternodeListExtra,
    ] = await Promise.all([
      rpc_connection.masternodelist("full"),
      rpc_connection.masternodelist("rank"),
      rpc_connection.masternodelist("pubkey"),
      rpc_connection.masternodelist("extra"),
    ]);
    const masternodeListFullData = Object.entries(masternodeListFull).map(
      ([txidVout, data]) => {
        const splitData = data?.trim()?.split(/\s+/);
        return {
          txid_vout: txidVout,
          supernode_status: splitData[0],
          protocol_version: Number(splitData[1]),
          supernode_psl_address: splitData[2],
          lastseentime: Number(splitData[3]),
          activeseconds: Number(splitData[4]),
          lastpaidtime: Number(splitData[5]),
          lastpaidblock: Number(splitData[6]),
          ipaddress_port: splitData[7],
        };
      }
    );
    const masternodeListFullDF = masternodeListFullData.map((data) => {
      const rank = masternodeListRank[data.txid_vout];
      const pubkey = masternodeListPubkey[data.txid_vout];
      const extra = masternodeListExtra[data.txid_vout] || {};
      return {
        ...data,
        rank: Number(rank),
        pubkey,
        extAddress: extra.extAddress || "NA",
        extP2P: extra.extP2P || "NA",
        extKey: extra.extKey || "NA", // Fill missing extKey with "NA"
        activedays: data.activeseconds / 86400,
      };
    });
    const validMasternodeListFullDF = masternodeListFullDF.filter(
      (data) =>
        ["ENABLED", "PRE_ENABLED"].includes(data.supernode_status) &&
        data["ipaddress_port"] !== "154.38.164.75:29933" &&
        data.extP2P
    );
    if (validMasternodeListFullDF.length === 0) {
      logger.error("No valid masternodes found.");
      return;
    }
    const validationSchema = Joi.array().items(supernodeListSchema);
    const validation = validationSchema.validate(validMasternodeListFullDF);
    if (validation.error) {
      throw new Error(`Validation error: ${validation.error.message}`);
    }
    // Wait for the table to be created before inserting data
    await waitForTableCreation();

    try {
      const _ = await SupernodeList.bulkCreate(validMasternodeListFullDF, {
        updateOnDuplicate: [
          "supernode_status",
          "protocol_version",
          "supernode_psl_address",
          "lastseentime",
          "activeseconds",
          "lastpaidtime",
          "lastpaidblock",
          "ipaddress_port",
          "rank",
          "pubkey",
          "extAddress",
          "extP2P",
          "extKey",
        ],
      });
    } catch (error) {
      logger.error("Failed to insert data:", error);
    }
    const masternodeListFullDFJSON = JSON.stringify(
      Object.fromEntries(
        validMasternodeListFullDF.map((data) => [data.txid_vout, data])
      )
    );
    return { validMasternodeListFullDF, masternodeListFullDFJSON };
  } catch (error) {
    logger.error(`An error occurred: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
  }
}

async function registerPastelID(pastelid, passphrase, address) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets(
      "register",
      "id",
      pastelid,
      passphrase,
      address
    );
    logger.info(`Registered PastelID: ${pastelid}. TXID: ${result}`);
    return result;
  } catch (error) {
    logger.error(
      `Error registering PastelID: ${pastelid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listPastelIDTickets(filter = "mine", minheight = null) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    if (filter !== "mine") {
      const params = [filter];
      if (minheight !== null) {
        params.push(minheight);
      }
      const result = await rpc_connection.tickets("list", "id", ...params);
      logger.info(`Pastel ID Tickets: ${result}`);
      logger.info(`Listed PastelID tickets with filter: ${filter}`);
      return result;
    }
    // If filter is "mine", combine results from `pastelid list` and `tickets find id <PastelID>`
    const pastelIDs = await rpc_connection.pastelid("list");
    const registeredTickets = [];

    for (const pastelIDObj of pastelIDs) {
      const pastelID = pastelIDObj.PastelID;
      try {
        const ticket = await rpc_connection.tickets("find", "id", pastelID);
        if (ticket && ticket.ticket) {
          if (minheight === null || ticket.height >= minheight) {
            registeredTickets.push(ticket);
          }
        }
      } catch (error) {
        // Handle the case where the PastelID is not registered
        if (error.message.includes("ticket not found")) {
          continue;
        } else {
          throw error;
        }
      }
    }
    logger.info(`Registered Pastel ID Tickets: ${registeredTickets}`);
    logger.info(`Listed registered PastelID tickets with filter: ${filter}`);
    return registeredTickets;
  } catch (error) {
    logger.error(
      `Error listing PastelID tickets with filter: ${filter}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listPastelIDTicketsOld(filter = "mine", minheight = null) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const params = [filter];
    if (minheight !== null) {
      params.push(minheight);
    }
    const result = await rpc_connection.tickets("list", "id", ...params);
    logger.info(`Pastel ID Tickets: ${result}`);
    logger.info(`Listed PastelID tickets with filter: ${filter}`);
    return result;
  } catch (error) {
    logger.error(
      `Error listing PastelID tickets with filter: ${filter}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function findPastelIDTicket(key) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("find", "id", key);
    logger.info(`Found PastelID ticket with key: ${key}`);
    return result;
  } catch (error) {
    logger.error(
      `Error finding PastelID ticket with key: ${key}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function getPastelTicket(txid, decodeProperties = false) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("get", txid, decodeProperties);
    logger.info(`Got Pastel ticket with TXID: ${txid}`);
    return result;
  } catch (error) {
    logger.error(
      `Error getting Pastel ticket with TXID: ${txid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listContractTickets(
  ticketTypeIdentifier,
  startingBlockHeight = 0
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets(
      "list",
      "contract",
      ticketTypeIdentifier,
      startingBlockHeight
    );
    logger.info(
      `Listed contract tickets of type ${ticketTypeIdentifier} starting from block height ${startingBlockHeight}`
    );
    return result;
  } catch (error) {
    logger.error(
      `Error listing contract tickets of type ${ticketTypeIdentifier}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function findContractTicket(key) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("find", "contract", key);
    logger.info(`Found contract ticket with key: ${key}`);
    return result;
  } catch (error) {
    logger.error(
      `Error finding contract ticket with key: ${key}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function getContractTicket(txid, decodeProperties = true) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("get", txid, decodeProperties);
    if (result && result.ticket && result.ticket.contract_ticket) {
      logger.info(`Got contract ticket with TXID: ${txid}`);
      return result.ticket.contract_ticket;
    } else {
      logger.error(`Error getting contract ticket with TXID: ${txid}`);
      return null;
    }
  } catch (error) {
    logger.error(
      `Error getting contract ticket with TXID: ${txid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function importPrivKey(zcashPrivKey, label = "", rescan = true) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.importprivkey(
      zcashPrivKey,
      label,
      rescan
    );
    logger.info(`Imported private key with label: ${label}`);
    return result;
  } catch (error) {
    logger.error(`Error importing private key: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function importWallet(filename) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.importwallet(filename);
    logger.info(`Imported wallet from file: ${filename}`);
    return result;
  } catch (error) {
    logger.error(`Error importing wallet: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function listAddressAmounts(includeEmpty = false, isMineFilter = "all") {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.listaddressamounts(
      includeEmpty,
      isMineFilter
    );
    logger.info(
      `Listed address amounts with includeEmpty: ${includeEmpty} and isMineFilter: ${isMineFilter}`
    );
    return result;
  } catch (error) {
    logger.error(`Error listing address amounts: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getBalance() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getbalance();
    return result;
  } catch (error) {
    logger.error(`Error getting balance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getWalletInfo() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getwalletinfo();
    logger.info("Got wallet info");
    return result;
  } catch (error) {
    logger.error(`Error getting wallet info: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getNewAddress() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getnewaddress();
    logger.info("Got new Pastel address");
    return result;
  } catch (error) {
    logger.error(`Error getting new address: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function checkForRegisteredPastelID() {
  try {
    const { rpchost, rpcport, rpcuser, rpcpassword } = getLocalRPCSettings();
    logger.info(
      `RPC settings: host=${rpchost}, port=${rpcport}, user=${rpcuser}, password=${rpcpassword}`
    );
    const { network, burnAddress } = getNetworkInfo(rpcport);
    logger.info(`Network: ${network}, Burn Address: ${burnAddress}`);
    const pastelIDDir = getPastelIDDirectory(network);
    logger.info(`Pastel ID directory: ${pastelIDDir}`);
    const pastelIDs = await getPastelIDsFromDirectory(pastelIDDir);
    logger.info(`Found Pastel IDs: ${pastelIDs}`);
    for (const pastelID of pastelIDs) {
      const isRegistered = await isPastelIDRegistered(pastelID);
      logger.info(`Pastel ID ${pastelID} is registered: ${isRegistered}`);
      if (isRegistered) {
        logger.info(`Found registered Pastel ID: ${pastelID}`);
        return pastelID;
      }
    }
    logger.info("No registered Pastel ID found.");
    return null;
  } catch (error) {
    logger.error(
      `Error in checkForRegisteredPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function getNetworkInfo(rpcport) {
  let network = "";
  let burnAddress = "";
  if (rpcport === "9932") {
    network = "mainnet";
    burnAddress = "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
  } else if (rpcport === "19932") {
    network = "testnet";
    burnAddress = "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
  } else if (rpcport === "29932") {
    network = "devnet";
    burnAddress = "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
  } else {
    throw new Error(`Unknown RPC port: ${rpcport}`);
  }
  return { network, burnAddress };
}

function getPastelIDDirectory(network) {
  const homeDir = process.env.HOME;
  let pastelIDDir = "";
  if (network === "mainnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "pastelkeys");
  } else if (network === "testnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "testnet3", "pastelkeys");
  } else if (network === "devnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "devnet3", "pastelkeys");
  }
  return pastelIDDir;
}

async function getPastelIDsFromDirectory(directory) {
  const files = await fs.promises.readdir(directory);
  const pastelIDs = files.filter((file) => file.length === 87);
  return pastelIDs;
}

async function isPastelIDRegistered(pastelID) {
  try {
    const ticketFindResult = await rpc_connection.tickets(
      "find",
      "id",
      pastelID
    );
    return !!ticketFindResult?.ticket?.pastelID;
  } catch (error) {
    logger.error(
      `Error checking if Pastel ID is registered: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return false;
  }
}

async function promptUserConfirmation(message) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise((resolve) => {
    rl.question(message + " ", (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

async function createAndRegisterPastelID(burnAddress) {
  try {
    const newPastelIDResult = await rpc_connection.pastelid("newkey");
    const newPastelID = newPastelIDResult.pastelid;
    const passphrase = newPastelIDResult.passphrase;
    const address = await rpc_connection.getnewaddress();
    const registrationResult = await registerPastelID(
      newPastelID,
      passphrase,
      address
    );
    if (registrationResult) {
      return newPastelID;
    } else {
      throw new Error("Failed to register new Pastel ID");
    }
  } catch (error) {
    logger.error(
      `Error creating and registering Pastel ID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

async function createAndRegisterNewPastelID(passphraseForNewPastelID) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return { success: false, message: "RPC connection is not available." };
    }
    let addressAmounts = await rpc_connection.listaddressamounts();
    const registrationFee = 1000;
    const transactionFee = 0.1;
    const requiredBalance = registrationFee + transactionFee;
    let fundingAddress = Object.keys(addressAmounts).find(
      (addr) => addressAmounts[addr] >= requiredBalance
    );
    if (!fundingAddress) {
      const newAddress = await getNewAddress();
      return {
        success: false,
        message: `Error: You do not have enough PSL in your wallet in a single address to register a new PastelID. Get some PSL (either from mining, buying on an exchange, a faucet, etc.) and then send at least 1,001 PSL of it to the following new PSL address which has been created for you: ${newAddress}`,
      };
    }
    const newPastelIDResult = await rpc_connection.pastelid(
      "newkey",
      passphraseForNewPastelID
    );
    const newPastelID = newPastelIDResult.pastelid;
    await setPastelIdAndPassphrase(newPastelID, passphraseForNewPastelID);

    addressAmounts = await rpc_connection.listaddressamounts();
    fundingAddress = Object.keys(addressAmounts).find(
      (addr) => addressAmounts[addr] >= registrationFee
    );
    if (!fundingAddress) {
      return {
        success: false,
        message:
          "Error: No address found with enough PSL to register a new PastelID.",
      };
    }
    const registerResult = await rpc_connection.tickets(
      "register",
      "id",
      newPastelID,
      passphraseForNewPastelID,
      fundingAddress
    );
    return {
      success: true,
      PastelID: newPastelID,
      PastelIDRegistrationTXID: registerResult.txid,
    };
  } catch (error) {
    logger.error(
      `Error in createAndRegisterNewPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return { success: false, message: error.message };
  }
}

async function isCreditPackConfirmed(txid) {
  try {
    const ticket = await getPastelTicket(txid);
    return ticket && ticket.height > 0;
  } catch (error) {
    logger.error(
      `Error checking if credit pack is confirmed: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return false;
  }
}

async function ensureTrackingAddressesHaveMinimalPSLBalance(
  addressesList = null
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    let addresses = addressesList;
    if (!addresses) {
      // If no address list is provided, retrieve all addresses and their balances
      addresses = Object.keys(await rpc_connection.listaddressamounts());
    }

    // Get the address with the largest balance to use for sending PSL if needed
    const fundingAddress = await getMyPslAddressWithLargestBalance();
    if (!fundingAddress) {
      logger.error("No address with sufficient funds to fund other addresses.");
      return; // No address has sufficient funds
    }

    for (const address of addresses) {
      const balance = await checkPSLAddressBalance(address); // Get balance for each address
      if (balance < 1.0) {
        // If balance is less than 1.0 PSL, send the needed amount
        const amountNeeded = Math.round((1.0 - balance) * 10000) / 10000;
        if (amountNeeded > 0.0001) {
          const sendResult = await sendToAddress(
            address,
            amountNeeded,
            "Balancing PSL amount to ensure tracking address has a minimum balance of 1 PSL",
          );
          if (sendResult.success) {
            logger.info(
              `Sent ${amountNeeded} PSL from address ${fundingAddress} to address ${address} to maintain minimum balance. TXID: ${sendResult.result}`
            );
          } else {
            logger.error(
              `Failed to send PSL from address ${fundingAddress} to address ${address}: ${sendResult.message}`
            );
          }
        }
      }
    }
  } catch (error) {
    logger.error(
      `Error in ensureTrackingAddressesHaveMinimalPSLBalance: ${safeStringify(
        error
      )}`
    );
    throw error;
  }
}

module.exports = {
  safeStringify,
  getLocalRPCSettings,
  JSONRPCException,
  AsyncAuthServiceProxy,
  initializeRPCConnection,
  waitForRPCConnection,
  checkMasternodeTop,
  getCurrentPastelBlockHeight,
  getBestBlockHashAndMerkleRoot,
  verifyMessageWithPastelID,
  sendToAddress,
  sendMany,
  checkPSLAddressBalance,
  checkIfAddressIsAlreadyImportedInLocalWallet,
  getAndDecodeRawTransaction,
  getTransactionDetails,
  sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest,
  importAddress,
  getBlockHash,
  getBlock,
  signMessageWithPastelID,
  checkPSLAddressBalanceAlternative,
  createAndFundNewPSLCreditTrackingAddress,
  checkSupernodeList,
  checkForRegisteredPastelID,
  getLocalRPCSettings,
  getNetworkInfo,
  getPastelIDDirectory,
  getPastelIDsFromDirectory,
  isPastelIDRegistered,
  promptUserConfirmation,
  createAndRegisterPastelID,
  createAndRegisterNewPastelID,
  getBalance,
  getWalletInfo,
  getNewAddress,
  listAddressAmounts,
  getPastelTicket,
  listPastelIDTickets,
  findPastelIDTicket,
  getPastelTicket,
  listContractTickets,
  findContractTicket,
  getContractTicket,
  importPrivKey,
  importWallet,
  registerPastelID,
  rpc_connection,
  stopPastelDaemon,
  startPastelDaemon,
  getMyPslAddressWithLargestBalance,
  isCreditPackConfirmed,
  ensureTrackingAddressesHaveMinimalPSLBalance,
};


---
./sequelize_data_models.js
---
require("dotenv").config();
const { Sequelize, DataTypes } = require("sequelize");

// SQLite database in project root directory
const sequelize = new Sequelize({
  dialect: "sqlite",
  storage: "pastel_inference_client.sqlite", // Path to the database file
  logging: false, // Disable logging; default: console.log
});

sequelize
  .authenticate()
  .then(() => console.log("Connection has been established successfully."))
  .catch((err) => console.error("Unable to connect to the database:", err));

const SupernodeList = sequelize.define(
  "SupernodeList",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    supernode_status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    protocol_version: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    supernode_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    lastseentime: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    activeseconds: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    activedays: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    lastpaidtime: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    lastpaidblock: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    ipaddress_port: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rank: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    pubkey: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extAddress: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extP2P: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extKey: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "supernode_lists",
    timestamps: false,
  }
);

const Message = sequelize.define(
  "Message",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sending_sn_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    receiving_sn_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sending_sn_txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    receiving_sn_txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_type: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_body: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    signature: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    timestamp: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal("CURRENT_TIMESTAMP"),
    },
  },
  {
    tableName: "messages",
    timestamps: false,
  }
);

const UserMessage = sequelize.define(
  "UserMessage",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    from_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    to_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_body: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    message_signature: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    timestamp: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal("CURRENT_TIMESTAMP"),
    },
  },
  {
    tableName: "user_messages",
    timestamps: false,
  }
);

const CreditPackPurchaseRequest = sequelize.define(
  "CreditPackPurchaseRequest",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requested_initial_credits_in_credit_pack: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    list_of_authorized_pastelids_allowed_to_use_credit_pack: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    requesting_end_user_pastelid_signature_on_request_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "credit_pack_purchase_requests",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestRejection = sequelize.define(
  "CreditPackPurchaseRequestRejection",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_reason_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_rejection_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_rejection_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_rejection_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_rejections",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestPreliminaryPriceQuote = sequelize.define(
  "CreditPackPurchaseRequestPreliminaryPriceQuote",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_quoted_price_per_credit_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_total_cost_of_credit_pack_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_price_quote_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_price_quote_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    preliminary_price_quote_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    responding_supernode_signature_on_credit_pack_purchase_request_preliminary_price_quote_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_preliminary_price_quotes",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestPreliminaryPriceQuoteResponse = sequelize.define(
  "CreditPackPurchaseRequestPreliminaryPriceQuoteResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    agree_with_preliminary_price_quote: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_quoted_price_per_credit_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_price_quote_response_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_price_quote_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    preliminary_price_quote_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_preliminary_price_quote_responses",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestResponseTermination = sequelize.define(
  "CreditPackPurchaseRequestResponseTermination",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_reason_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_termination_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_termination_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_termination_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_response_terminations",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestResponse = sequelize.define(
  "CreditPackPurchaseRequestResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    psl_cost_per_credit: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    proposed_total_cost_of_credit_pack_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_response_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    best_block_merkle_root: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    best_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    list_of_blacklisted_supernode_pastelids: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_potentially_agreeing_supernodes: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion:
      {
        type: DataTypes.JSON,
        allowNull: false,
      },
    selected_agreeing_supernodes_signatures_dict: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_responses",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestConfirmation = sequelize.define(
  "CreditPackPurchaseRequestConfirmation",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_responses",
        key: "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
      },
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    txid_of_credit_purchase_burn_transaction: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_confirmation_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_confirmations",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestConfirmationResponse = sequelize.define(
  "CreditPackPurchaseRequestConfirmationResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_confirmations",
        key: "sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields",
      },
    },
    credit_pack_confirmation_outcome_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    pastel_api_credit_pack_ticket_registration_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_confirmation_failure_reason_if_applicable: {
      type: DataTypes.STRING,
      allowNull: true,
      defaultValue: "",
    },
    credit_purchase_request_confirmation_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_confirmation_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
      },
    responding_supernode_signature_on_credit_pack_purchase_request_confirmation_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_confirmation_responses",
    timestamps: false,
  }
);

const CreditPackRequestStatusCheck = sequelize.define(
  "CreditPackRequestStatusCheck",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_request_status_checks",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestStatus = sequelize.define(
  "CreditPackPurchaseRequestStatus",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_responses",
        key: "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
      },
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_details: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_update_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_update_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_status_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_status_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_status_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_statuses",
    timestamps: false,
  }
);

const CreditPackStorageRetryRequest = sequelize.define(
  "CreditPackStorageRetryRequest",
  {
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_request_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_pack_storage_retry_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_storage_retry_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_storage_retry_requests",
    timestamps: false,
  }
);

const CreditPackStorageRetryRequestResponse = sequelize.define(
  "CreditPackStorageRetryRequestResponse",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_outcome_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    pastel_api_credit_pack_ticket_registration_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_failure_reason_if_applicable: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_storage_retry_confirmation_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid_signature_on_credit_pack_storage_retry_confirmation_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_storage_retry_request_responses",
    timestamps: false,
  }
);

const InferenceAPIUsageRequest = sequelize.define(
  "InferenceAPIUsageRequest",
  {
    inference_request_id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    requesting_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_ticket_pastel_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requested_model_canonical_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_inference_type_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_parameters_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_input_data_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_pastelid_signature_on_request_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_usage_requests",
    timestamps: false,
  }
);

const InferenceAPIUsageResponse = sequelize.define(
  "InferenceAPIUsageResponse",
  {
    inference_response_id: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_requests",
        key: "inference_request_id",
      },
    },
    proposed_cost_of_request_in_inference_credits: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    remaining_credits_in_pack_after_request_processed: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_confirmation_message_amount_in_patoshis: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    max_block_height_to_include_confirmation_transaction: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_request_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_request_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    supernode_pastelid_and_signature_on_inference_request_response_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_usage_responses",
    timestamps: false,
  }
);

const InferenceAPIOutputResult = sequelize.define(
  "InferenceAPIOutputResult",
  {
    inference_result_id: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_requests",
        key: "inference_request_id",
      },
    },
    inference_response_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_responses",
        key: "inference_response_id",
      },
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_json_base64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_file_type_strings: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_result_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_result_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_inference_result_id: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_output_results",
    timestamps: false,
  }
);

const InferenceConfirmation = sequelize.define(
  "InferenceConfirmation",
  {
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    confirmation_transaction: {
      type: DataTypes.JSON,
      allowNull: false,
    },
  },
  {
    tableName: "inference_confirmations",
    timestamps: false,
  }
);

// Sync all defined models to the DB
sequelize.sync({ force: true }).then(() => {
  console.log("Database & tables created!");
});

module.exports = {
  SupernodeList,
  Message,
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestPreliminaryPriceQuote,
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  CreditPackPurchaseRequestStatus,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  InferenceAPIUsageRequest,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmation,
};


---
./server.js
---
// server.js

const express = require("express");
const multer = require("multer");
const bodyParser = require("body-parser");
const WebSocket = require("ws");
const os = require("os");
const path = require("path");
const fs = require("fs");
const {
  getCurrentPastelIdAndPassphrase,
  setPastelIdAndPassphrase,
} = require("./storage");
const { PastelInferenceClient } = require("./pastel_inference_client");

const {
  checkForNewIncomingMessages,
  sendMessageAndCheckForNewIncomingMessages,
  handleCreditPackTicketEndToEnd,
  getCreditPackTicketInfoEndToEnd,
  getMyValidCreditPackTicketsEndToEnd,
  handleInferenceRequestEndToEnd,
  estimateCreditPackCostEndToEnd,
} = require("./end_to_end_functions");
const {
  getLocalRPCSettings,
  getNetworkInfo,
  initializeRPCConnection,
  createAndFundNewPSLCreditTrackingAddress,
  checkSupernodeList,
  registerPastelID,
  listPastelIDTickets,
  findPastelIDTicket,
  getPastelTicket,
  listContractTickets,
  findContractTicket,
  getContractTicket,
  importPrivKey,
  importWallet,
  listAddressAmounts,
  getBalance,
  getWalletInfo,
  getNewAddress,
  checkForRegisteredPastelID,
  createAndRegisterNewPastelID,
  stopPastelDaemon,
  startPastelDaemon,
  getMyPslAddressWithLargestBalance,
  isPastelIDRegistered,
  isCreditPackConfirmed,
  ensureTrackingAddressesHaveMinimalPSLBalance,
} = require("./rpc_functions");
const { logger, logEmitter, logBuffer, safeStringify } = require("./logger");
const {
  prettyJSON,
  getClosestSupernodeToPastelIDURL,
  getNClosestSupernodesToPastelIDURLs,
} = require("./utility_functions");
const globals = require("./globals");
let MY_LOCAL_PASTELID = "";
let MY_PASTELID_PASSPHRASE = "";

const app = express();
app.use(bodyParser.urlencoded({ extended: true, limit: "50mb" }));
app.use(bodyParser.json({ limit: "50mb" }));
const upload = multer({ dest: "uploads/" });

const port = process.env.CLIENT_PORT || 3100;
const webSocketPort = process.env.CLIENT_WEBSOCKET_PORT || 3101;

const wss = new WebSocket.Server({ port: webSocketPort }, () => {
  console.log(`WebSocket server started on port ${webSocketPort}`);
});

function getServerIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === "IPv4" && !iface.internal) {
        return iface.address;
      }
    }
  }
  return "localhost";
}

app.get("/ws-url", (req, res) => {
  const ipAddress = getServerIpAddress();
  const wsUrl = `ws://${ipAddress}:${webSocketPort}`;
  res.json({ wsUrl });
});

wss.on("connection", (ws) => {
  logger.info(`Client connected: ${ws}`);

  logBuffer.forEach((logEntry) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(logEntry);
    }
  });

  const logListener = (logEntry) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(logEntry);
    }
  };
  logEmitter.on("newLog", logListener);

  ws.on("message", (message) => {
    logger.info(`Received message from client: ${message}`);
  });

  ws.on("close", (code, reason) => {
    logger.info(`Client disconnected; code: ${code}, reason: ${reason}`);
    logEmitter.removeListener("newLog", logListener);
  });

  ws.on("error", (error) => {
    logger.error(`WebSocket error: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    logEmitter.removeListener("newLog", logListener);
  });
});

async function initializeServer() {
  try {
    const { pastelID, passphrase } = await getCurrentPastelIdAndPassphrase();
    if (pastelID && passphrase) {
      // Set global variables
      globals.setPastelIdAndPassphrase(pastelID, passphrase);

      // Set local variables
      MY_LOCAL_PASTELID = pastelID;
      MY_PASTELID_PASSPHRASE = passphrase;

      logger.info(`Successfully set global and local PastelID`);
    } else {
      logger.warn(
        `Failed to set global and local PastelID and passphrase from storage`
      );
    }

    // Rest of your server initialization code...
  } catch (error) {
    logger.error(`Error initializing server: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    process.exit(1);
  }
}

let rpcport;
let network;

(async () => {
  try {
    await initializeRPCConnection();
    await initializeServer();
    const rpcSettings = await getLocalRPCSettings();
    rpcport = rpcSettings.rpcport;
    network = getNetworkInfo(rpcport).network;

    const { pastelID, passphrase } = await getCurrentPastelIdAndPassphrase();
    if (pastelID && passphrase) {
      MY_LOCAL_PASTELID = pastelID;
      MY_PASTELID_PASSPHRASE = passphrase;
      logger.info(`Successfully set global PastelID`);
    } else {
      logger.warn(`Failed to set global PastelID and passphrase from storage`);
    }

    const { validMasternodeListFullDF } = await checkSupernodeList();
    if (!validMasternodeListFullDF) {
      throw new Error(
        "The Pastel Daemon is not fully synced, and thus the Supernode information commands are not returning complete information. Finish fully syncing and try again."
      );
    }

    let supernodeURL;
    if (MY_LOCAL_PASTELID !== "") {
      const result = await getClosestSupernodeToPastelIDURL(
        MY_LOCAL_PASTELID,
        validMasternodeListFullDF
      );
      if (result) {
        supernodeURL = result.url;
      }
    }

    async function configureRPCAndSetBurnAddress() {
      try {
        let burnAddress;
        if (rpcport === "9932") {
          burnAddress = "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
        } else if (rpcport === "19932") {
          burnAddress = "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
        } else if (rpcport === "29932") {
          burnAddress = "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
        } else {
          throw new Error(`Unsupported RPC port: ${rpcport}`);
        }
        return burnAddress;
      } catch (error) {
        console.error("Failed to configure RPC or set burn address:", error);
        throw error;
      }
    }

    app.get("/", (req, res) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });

    app.get("/favicon.ico", (req, res) => {
      res.sendFile(path.join(__dirname, "favicon.ico"));
    });

    app.get("/get-network-info", async (req, res) => {
      try {
        res.json({ network });
      } catch (error) {
        console.error("Error getting network info:", error);
        res
          .status(500)
          .json({ success: false, message: "Failed to get network info" });
      }
    });

    app.get("/get-best-supernode-url", async (req, res) => {
      try {
        const userPastelID = req.query.userPastelID;
        const supernodeListDF = await checkSupernodeList();
        const { url: supernodeURL } = await getClosestSupernodeToPastelIDURL(
          userPastelID,
          supernodeListDF.validMasternodeListFullDF
        );
        if (!supernodeURL) {
          throw new Error("No valid supernode URL found.");
        }
        res.json({ success: true, supernodeURL });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-inference-model-menu", async (req, res) => {
      try {
        if (!MY_LOCAL_PASTELID || !MY_PASTELID_PASSPHRASE) {
          return res.status(400).json({
            success: false,
            message: "Pastel ID and passphrase not set.",
          });
        }
        const pastelInferenceClient = new PastelInferenceClient(
          MY_LOCAL_PASTELID,
          MY_PASTELID_PASSPHRASE
        );
        const modelMenu = await pastelInferenceClient.getModelMenu();
        res.json({ success: true, modelMenu });
      } catch (error) {
        logger.error(`Error in getInferenceModelMenu: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/estimate-credit-pack-cost", async (req, res) => {
      const { desiredNumberOfCredits, creditPriceCushionPercentage } = req.body;
      try {
        const result = await estimateCreditPackCostEndToEnd(
          desiredNumberOfCredits,
          creditPriceCushionPercentage
        );
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/send-message", async (req, res) => {
      const { toPastelID, messageBody } = req.body;
      try {
        const messageDict = await sendMessageAndCheckForNewIncomingMessages(
          toPastelID,
          messageBody
        );
        res.json({ success: true, messageDict });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-received-messages", async (req, res) => {
      try {
        const messageDict = await checkForNewIncomingMessages();
        res.json({ success: true, messageDict });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-credit-pack-ticket", async (req, res) => {
      const burnAddress = await configureRPCAndSetBurnAddress();
      const {
        numCredits,
        creditUsageTrackingPSLAddress,
        maxTotalPrice,
        maxPerCreditPrice,
      } = req.body;
      try {
        const result = await handleCreditPackTicketEndToEnd(
          numCredits,
          creditUsageTrackingPSLAddress,
          burnAddress,
          maxTotalPrice,
          maxPerCreditPrice
        );
        res.json({ success: true, result });
      } catch (error) {
        console.error("Error in create-credit-pack-ticket:", error);
        res.status(500).json({
          success: false,
          error: error.message,
          details: error.details || "No additional details available",
        });
      }
    });

    app.get("/credit-pack-info/:txid", async (req, res) => {
      const { txid } = req.params;
      try {
        const result = await getCreditPackTicketInfoEndToEnd(txid);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-my-valid-credit-packs", async (req, res) => {
      try {
        const result = await getMyValidCreditPackTicketsEndToEnd();
        res.json({ success: true, result: result || [] });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-my-psl-address-with-largest-balance", async (req, res) => {
      try {
        const result = await getMyPslAddressWithLargestBalance();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-inference-request", async (req, res) => {
      const {
        model_inference_type_string: modelInferenceTypeString,
        model_parameters_json_b64,
        model_input_data_json_b64,
        selectedCreditPackTicketId: creditPackTicketPastelTxid,
        maxCost: maximumInferenceCostInCredits,
        model_canonical_name: requestedModelCanonicalString,
      } = req.body;
      try {
        const burnAddress = await configureRPCAndSetBurnAddress();
        const modelParameters = JSON.parse(
          Buffer.from(model_parameters_json_b64, "base64").toString()
        );
        const modelInputData = JSON.parse(
          Buffer.from(model_input_data_json_b64, "base64").toString()
        );
        console.log(`Model Inference Type: ${modelInferenceTypeString}`);
        const result = await handleInferenceRequestEndToEnd(
          creditPackTicketPastelTxid,
          modelInputData,
          requestedModelCanonicalString,
          modelInferenceTypeString,
          modelParameters,
          maximumInferenceCostInCredits,
          burnAddress
        );
        res.json({ success: true, result });
      } catch (error) {
        console.error("Error in create-inference-request:", error);
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/check-supernode-list", async (req, res) => {
      try {
        const { validMasternodeListFullDF } = await checkSupernodeList();
        res.json({ success: true, result: { validMasternodeListFullDF } });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/register-pastel-id", async (req, res) => {
      const { pastelid, passphrase, address } = req.body;
      try {
        const result = await registerPastelID(pastelid, passphrase, address);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-pastel-id-tickets", async (req, res) => {
      const { filter, minheight } = req.query;
      try {
        const result = await listPastelIDTickets(filter, minheight);
        console.log("Pastel ID Tickets:", result);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/find-pastel-id-ticket/:key", async (req, res) => {
      const { key } = req.params;
      try {
        const result = await findPastelIDTicket(key);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-pastel-ticket/:txid", async (req, res) => {
      const { txid } = req.params;
      const { decodeProperties } = req.query;
      try {
        const result = await getPastelTicket(txid, decodeProperties);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-contract-tickets", async (req, res) => {
      const { ticketTypeIdentifier, startingBlockHeight } = req.query;
      try {
        const result = await listContractTickets(
          ticketTypeIdentifier,
          startingBlockHeight
        );
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/find-contract-ticket/:key", async (req, res) => {
      const { key } = req.params;
      try {
        const result = await findContractTicket(key);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-contract-ticket/:txid", async (req, res) => {
      const { txid } = req.params;
      const { decodeProperties } = req.query;
      try {
        const result = await getContractTicket(txid, decodeProperties);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/import-priv-key", async (req, res) => {
      const { zcashPrivKey, label, rescan } = req.body;
      try {
        const result = await importPrivKey(zcashPrivKey, label, rescan);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/import-wallet", async (req, res) => {
      const { filename } = req.body;
      try {
        const result = await importWallet(filename);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-address-amounts", async (req, res) => {
      const { includeEmpty, isMineFilter } = req.query;
      try {
        const result = await listAddressAmounts(includeEmpty, isMineFilter);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-balance", async (req, res) => {
      try {
        const result = await getBalance();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-wallet-info", async (req, res) => {
      try {
        const result = await getWalletInfo();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-and-fund-new-address", async (req, res) => {
      try {
        const { amount } = req.body;
        const result = await createAndFundNewPSLCreditTrackingAddress(amount);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/check-for-pastel-id", async (req, res) => {
      const { autoRegister } = req.body;
      try {
        const result = await checkForRegisteredPastelID(autoRegister);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post(
      "/import-pastel-id",
      upload.single("pastelIDFile"),
      async (req, res) => {
        try {
          const destFolder = getNetworkSpecificDestFolder(network);
          fs.mkdirSync(destFolder, { recursive: true });
          const sourceFilePath = req.file.path;
          const destFilePath = path.join(destFolder, req.file.originalname);
          fs.renameSync(sourceFilePath, destFilePath);

          await stopPastelDaemon();
          await startPastelDaemon();

          res.json({
            success: true,
            message: "PastelID imported successfully!",
          });
        } catch (error) {
          console.error("Error importing PastelID:", error);
          res
            .status(500)
            .json({ success: false, message: "Failed to import PastelID." });
        }
      }
    );

    app.get("/credit-pack-status/:txid", async (req, res) => {
      try {
        const txid = req.params.txid;
        const confirmed = await isCreditPackConfirmed(txid);
        res.json({ confirmed });
      } catch (error) {
        console.error("Error checking credit pack status:", error);
        res.status(500).json({ error: "Failed to check credit pack status" });
      }
    });

    app.post("/create-and-register-pastel-id", async (req, res) => {
      const { passphraseForNewPastelID } = req.body;
      try {
        const result = await createAndRegisterNewPastelID(
          passphraseForNewPastelID
        );
        if (result.success) {
          res.json({
            success: true,
            PastelID: result.PastelID,
            PastelIDRegistrationTXID: result.PastelIDRegistrationTXID,
          });
        } else {
          res.json({ success: false, message: result.message });
        }
      } catch (error) {
        logger.error(
          `Error in create-and-register-pastel-id: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        res.status(500).json({ success: false, message: error.message });
      }
    });

    app.get("/check-pastel-id-status/:pastelID", async (req, res) => {
      try {
        const pastelID = req.params.pastelID;
        const isRegistered = await isPastelIDRegistered(pastelID);
        res.json({ registered: isRegistered });
      } catch (error) {
        console.error("Error checking PastelID status:", error);
        res.status(500).json({ error: "Failed to check PastelID status" });
      }
    });

    app.post("/set-pastel-id-passphrase", async (req, res) => {
      const { pastelID, passphrase } = req.body;
      try {
        // Check if the PastelID is valid
        const isValid = await isPastelIDRegistered(pastelID);

        if (!isValid) {
          // If not valid, send a response indicating that the PastelID is invalid
          return res.json({ success: false, message: "Invalid PastelID" });
        }

        // If valid, proceed with updating storage and global variables
        await setPastelIdAndPassphrase(pastelID, passphrase);
        globals.setPastelIdAndPassphrase(pastelID, passphrase);
        MY_LOCAL_PASTELID = pastelID;
        MY_PASTELID_PASSPHRASE = passphrase;

        res.json({ success: true });
        app.emit("pastelIDAndPassphraseSet");
      } catch (error) {
        console.error("Error setting PastelID and passphrase:", error);
        res.status(500).json({
          success: false,
          message: "Failed to set PastelID and passphrase",
        });
      }
    });

    app.post("/ensure-minimal-psl-balance", async (req, res) => {
      try {
        const { addresses } = req.body; // Expects a JSON body with an "addresses" array
        await ensureTrackingAddressesHaveMinimalPSLBalance(addresses);
        res.json({
          success: true,
          message: "Balance check and update process initiated.",
        });
      } catch (error) {
        logger.error(
          `Error in ensuring minimal PSL balance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/ensure-minimal-psl-balance", async (req, res) => {
      try {
        await ensureTrackingAddressesHaveMinimalPSLBalance();
        res.json({
          success: true,
          message:
            "Balance check and update process initiated for all addresses.",
        });
      } catch (error) {
        logger.error(
          `Error in ensuring minimal PSL balance for all addresses: ${safeStringify(
            error
          )}`
        );
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post('/check-pastel-id-validity', async (req, res) => {
      try {
        const { pastelID } = req.body;
        const isValid = await isPastelIDRegistered(pastelID);
        res.json({ isValid });
      } catch (error) {
        console.error("Error checking PastelID validity:", error);
        res.status(500).json({ error: "Failed to check PastelID validity" });
      }
    });

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
  } catch (error) {
    console.error("Error initializing server:", error);
    process.exit(1);
  }
})();

function getNetworkSpecificDestFolder(network) {
  if (network === "mainnet") {
    return path.join(process.env.HOME, ".pastel/pastelkeys");
  } else if (network === "testnet") {
    return path.join(process.env.HOME, ".pastel/testnet/pastelkeys");
  } else if (network === "devnet") {
    return path.join(process.env.HOME, ".pastel/devnet/pastelkeys");
  } else {
    throw new Error(`Unknown network: ${network}`);
  }
}


---
./set_node_memory_limit.sh
---
#!/bin/bash

# Memory limit to set (in MB)
MEMORY_LIMIT=4096

# The alias command to set the Node.js memory limit
ALIAS_COMMAND="alias node=\"node --max-old-space-size=${MEMORY_LIMIT}\""

# Check if the alias is already in the .zshrc file
if grep -q "alias node=" ~/.zshrc; then
    echo "Updating existing Node.js memory limit alias in .zshrc"
    sed -i.bak "s/alias node=.*/$ALIAS_COMMAND/" ~/.zshrc
else
    echo "Adding Node.js memory limit alias to .zshrc"
    echo "$ALIAS_COMMAND" >> ~/.zshrc
fi

echo "Node.js memory limit set to ${MEMORY_LIMIT} MB globally for zsh."
echo "Please run 'source ~/.zshrc' in your zsh session to apply the changes."


---
./single_file_pastel_inference_client.txt
---
./end_to_end_functions.js
---
require("dotenv").config();
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const {
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackStorageRetryRequest,
  InferenceAPIUsageRequest,
  InferenceConfirmation,
} = require("./sequelize_data_models");
const {
  userMessageSchema,
  creditPackPurchaseRequestResponseSchema,
  creditPackPurchaseRequestConfirmationSchema,
  creditPackPurchaseRequestConfirmationResponseSchema,
  creditPackPurchaseRequestStatusSchema,
  creditPackStorageRetryRequestSchema,
  creditPackStorageRetryRequestResponseSchema,
  inferenceAPIUsageRequestSchema,
  inferenceAPIUsageResponseSchema,
  inferenceAPIOutputResultSchema,
  inferenceConfirmationSchema,
} = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const {
  signMessageWithPastelID,
  checkSupernodeList,
  getCurrentPastelBlockHeight,
  sendToAddress,
  sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest,
  checkPSLAddressBalanceAlternative,
} = require("./rpc_functions");
const { PastelInferenceClient } = require("./pastel_inference_client");
const {
  prettyJSON,
  filterSupernodes,
  getNClosestSupernodesToPastelIDURLs,
  validateCreditPackTicketMessageData,
  validateInferenceData,
  computeSHA3256HashOfSQLModelResponseFields,
  checkIfPastelIDIsValid,
  getSupernodeUrlFromPastelID,
  getClosestSupernodePastelIDFromList,
  getClosestSupernodeToPastelIDURL,
} = require("./utility_functions");
const globals = require("./globals");

async function checkForNewIncomingMessages() {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);

    if (!pastelID || !passphrase) {
      logger.error("PastelID or passphrase is not set");
      return [];
    }
    const { validMasternodeListFullDF } = await checkSupernodeList();

    logger.info("Retrieving incoming user messages...");
    logger.info(`My local pastelid: ${inferenceClient.pastelID}`);

    const closestSupernodesToLocal = await getNClosestSupernodesToPastelIDURLs(
      3,
      inferenceClient.pastelID,
      validMasternodeListFullDF
    );
    logger.info(
      `Closest Supernodes to local pastelid: ${closestSupernodesToLocal
        .map((sn) => `PastelID: ${sn.pastelID}, URL: ${sn.url}`)
        .join(", ")}`
    );

    const messageRetrievalTasks = closestSupernodesToLocal.map(({ url }) =>
      inferenceClient.getUserMessages(url).catch((error) => {
        logger.warn(
          `Failed to retrieve messages from supernode ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        return []; // Return an empty array on error
      })
    );
    const messageLists = await Promise.all(messageRetrievalTasks);

    const uniqueMessages = [];
    const messageIDs = new Set();
    for (const messageList of messageLists) {
      for (const message of messageList) {
        if (!messageIDs.has(message.id)) {
          uniqueMessages.push(message);
          messageIDs.add(message.id);
        }
      }
    }

    logger.info(
      `Retrieved unique user messages: ${safeStringify(uniqueMessages)}`
    );

    return uniqueMessages;
  } catch (error) {
    logger.error(`Error in checkForNewIncomingMessages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function sendMessageAndCheckForNewIncomingMessages(
  toPastelID,
  messageBody
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();

    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    logger.info("Sending user message...");
    logger.info(`Recipient pastelid: ${toPastelID}`);

    const closestSupernodesToRecipient =
      await getNClosestSupernodesToPastelIDURLs(
        3,
        toPastelID,
        validMasternodeListFullDF
      );
    logger.info(
      `Closest Supernodes to recipient pastelid: ${closestSupernodesToRecipient.map(
        (sn) => sn.pastelID
      )}`
    );

    const userMessage = UserMessage.build({
      from_pastelid: pastelID,
      to_pastelid: toPastelID,
      message_body: safeStringify(messageBody),
      message_signature: await signMessageWithPastelID(
        pastelID,
        messageBody,
        passphrase
      ),
    });

    const { error } = userMessageSchema.validate(userMessage.toJSON());
    if (error) {
      throw new Error(`Invalid user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    }

    const sendTasks = closestSupernodesToRecipient.map(({ url }) =>
      inferenceClient.sendUserMessage(url, userMessage)
    );
    const sendResults = await Promise.all(sendTasks);
    logger.info(`Sent user messages: ${safeStringify(sendResults)}`);

    const receivedMessages = await checkForNewIncomingMessages();

    const messageDict = {
      sent_messages: sendResults,
      received_messages: receivedMessages,
    };

    return messageDict;
  } catch (error) {
    logger.error(
      `Error in sendMessageAndCheckForNewIncomingMessages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function getIsoStringWithMicroseconds() {
  const now = new Date();
  const isoString = now.toISOString().replace("Z", "+00:00").replace(/\s/g, "");
  return isoString;
}

async function handleCreditPackTicketEndToEnd(
  numberOfCredits,
  creditUsageTrackingPSLAddress,
  burnAddress,
  maximumTotalCreditPackPriceInPSL,
  maximumPerCreditPriceInPSL
) {
  const pastelID = globals.getPastelId();
  const passphrase = globals.getPassphrase();
  if (!pastelID || !passphrase) {
    throw new Error("PastelID or passphrase is not set");
  }

  const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
  const { validMasternodeListFullDF } = await checkSupernodeList();
  const requestTimestamp = getIsoStringWithMicroseconds();

  const creditPackRequest = CreditPackPurchaseRequest.build({
    requesting_end_user_pastelid: pastelID,
    requested_initial_credits_in_credit_pack: parseInt(numberOfCredits, 10),
    list_of_authorized_pastelids_allowed_to_use_credit_pack: JSON.stringify([pastelID]),
    credit_usage_tracking_psl_address: creditUsageTrackingPSLAddress,
    request_timestamp_utc_iso_string: requestTimestamp,
    request_pastel_block_height: parseInt(await getCurrentPastelBlockHeight(), 10),
    credit_purchase_request_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_purchase_request_fields: "",
    requesting_end_user_pastelid_signature_on_request_hash: "",
  });

  creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields =
    await computeSHA3256HashOfSQLModelResponseFields(creditPackRequest);
  creditPackRequest.requesting_end_user_pastelid_signature_on_request_hash =
    await signMessageWithPastelID(
      pastelID,
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
      passphrase
    );

  const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(12, pastelID, validMasternodeListFullDF);
  if (closestSupernodes.length === 0) {
    throw new Error("No responsive supernodes found.");
  }

  const randomIndex = Math.floor(Math.random() * closestSupernodes.length);
  const selectedSupernode = closestSupernodes[randomIndex];
  const highestRankedSupernodeURL = selectedSupernode.url;

  logger.info(`Selected supernode URL for credit pack request: ${highestRankedSupernodeURL}`);

  try {
    const preliminaryPriceQuote = await inferenceClient.creditPackTicketInitialPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackRequest
    );

    const signedCreditPackTicketOrRejection = await inferenceClient.creditPackTicketPreliminaryPriceQuoteResponse(
      highestRankedSupernodeURL,
      creditPackRequest,
      preliminaryPriceQuote,
      maximumTotalCreditPackPriceInPSL,
      maximumPerCreditPriceInPSL
    );

    if (signedCreditPackTicketOrRejection instanceof CreditPackPurchaseRequestResponseTermination) {
      logger.info(`Credit pack purchase request terminated: ${signedCreditPackTicketOrRejection.termination_reason_string}`);
      return null;
    }

    const signedCreditPackTicket = signedCreditPackTicketOrRejection;

    const burnTransactionResponse = await sendToAddress(
      burnAddress,
      Math.round(signedCreditPackTicket.proposed_total_cost_of_credit_pack_in_psl * 100000) / 100000,
      "Burn transaction for credit pack ticket"
    );

    if (!burnTransactionResponse.success) {
      throw new Error(`Error sending PSL to burn address: ${burnTransactionResponse.message}`);
    }

    const burnTransactionTxid = burnTransactionResponse.result;

    const creditPackPurchaseRequestConfirmation = await buildCreditPackPurchaseRequestConfirmation(
      creditPackRequest,
      signedCreditPackTicket,
      burnTransactionTxid,
      pastelID,
      passphrase
    );

    await CreditPackPurchaseRequestConfirmation.create(creditPackPurchaseRequestConfirmation.toJSON());

    const creditPackPurchaseRequestConfirmationResponse = await inferenceClient.confirmCreditPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackPurchaseRequestConfirmation
    );

    if (!creditPackPurchaseRequestConfirmationResponse) {
      throw new Error("Credit pack ticket storage failed");
    }

    let creditPackPurchaseRequestStatus = await checkCreditPackPurchaseRequestStatus(
      inferenceClient,
      highestRankedSupernodeURL,
      creditPackRequest,
      closestSupernodes
    );

    if (creditPackPurchaseRequestStatus.status !== "completed") {
      const creditPackStorageRetryRequestResponse = await initiateStorageRetry(
        inferenceClient,
        creditPackRequest,
        signedCreditPackTicket,
        validMasternodeListFullDF,
        pastelID,
        passphrase
      );

      return creditPackStorageRetryRequestResponse;
    } else {
      return creditPackPurchaseRequestConfirmationResponse;
    }
  } catch (error) {
    logger.error(`Error in handleCreditPackTicketEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw new Error("An unexpected error occurred while processing your credit pack purchase. Please try again later.");
  }
}

async function buildCreditPackPurchaseRequestConfirmation(creditPackRequest, signedCreditPackTicket, burnTransactionTxid, pastelID, passphrase) {
  const confirmation = CreditPackPurchaseRequestConfirmation.build({
    sha3_256_hash_of_credit_pack_purchase_request_fields:
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    txid_of_credit_purchase_burn_transaction: burnTransactionTxid,
    credit_purchase_request_confirmation_utc_iso_string: new Date().toISOString(),
    credit_purchase_request_confirmation_pastel_block_height: await getCurrentPastelBlockHeight(),
    credit_purchase_request_confirmation_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: "",
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: "",
  });

  confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await computeSHA3256HashOfSQLModelResponseFields(confirmation);
  confirmation.requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields =
    await signMessageWithPastelID(
      pastelID,
      confirmation.sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields,
      passphrase
    );

  const { error: confirmationValidationError } = creditPackPurchaseRequestConfirmationSchema.validate(confirmation.toJSON());
  if (confirmationValidationError) {
    throw new Error(`Invalid credit pack purchase request confirmation: ${confirmationValidationError.message}`);
  }

  return confirmation;
}

async function checkCreditPackPurchaseRequestStatus(inferenceClient, highestRankedSupernodeURL, creditPackRequest, closestSupernodes) {
  try {
    const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
      highestRankedSupernodeURL,
      creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
    );
    logger.info(`Credit pack purchase request status from the original supernode: ${JSON.stringify(status)}`);
    return status;
  } catch (error) {
    logger.debug(`Error checking status with original supernode: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}. Trying other supernodes.`);
    for (const supernode of closestSupernodes) {
      try {
        const status = await inferenceClient.checkStatusOfCreditPurchaseRequest(
          supernode.url,
          creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields
        );
        logger.info(`Credit pack purchase request status: ${JSON.stringify(status)}`);
        return status;
      } catch (retryError) {
        logger.debug(`Error checking status with supernode ${supernode.url}: ${retryError.message}`);
      }
    }
    throw new Error("Failed to check status of credit purchase request with all Supernodes");
  }
}

async function initiateStorageRetry(inferenceClient, creditPackRequest, signedCreditPackTicket, validMasternodeListFullDF, pastelID, passphrase) {
  const closestAgreeingSupernodePastelID = await getClosestSupernodePastelIDFromList(
    pastelID,
    signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms
  );

  const creditPackStorageRetryRequest = await buildCreditPackStorageRetryRequest(
    creditPackRequest,
    signedCreditPackTicket,
    closestAgreeingSupernodePastelID,
    pastelID,
    passphrase
  );

  await CreditPackStorageRetryRequest.create(creditPackStorageRetryRequest.toJSON());

  const closestAgreeingSupernodeURL = await getSupernodeUrlFromPastelID(
    closestAgreeingSupernodePastelID,
    validMasternodeListFullDF
  );

  const creditPackStorageRetryRequestResponse = await inferenceClient.creditPackStorageRetryRequest(
    closestAgreeingSupernodeURL,
    creditPackStorageRetryRequest
  );

  const { error: storageRetryResponseValidationError } = creditPackStorageRetryRequestResponseSchema.validate(
    creditPackStorageRetryRequestResponse.toJSON()
  );

  if (storageRetryResponseValidationError) {
    throw new Error(`Invalid credit pack storage retry request response: ${storageRetryResponseValidationError.message}`);
  }

  // Silently attempt to announce completion to all agreeing supernodes
  const announcementPromises = signedCreditPackTicket.list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms.map(
    async (supernodePastelID) => {
      if (checkIfPastelIDIsValid(supernodePastelID)) {
        try {
          const supernodeURL = await getSupernodeUrlFromPastelID(supernodePastelID, validMasternodeListFullDF);
          await inferenceClient.creditPackPurchaseCompletionAnnouncement(
            supernodeURL,
            creditPackStorageRetryRequestResponse
          );
        } catch (error) {
          // Silently ignore errors in completion announcements
        }
      }
    }
  );

  await Promise.allSettled(announcementPromises);

  return creditPackStorageRetryRequestResponse;
}

async function buildCreditPackStorageRetryRequest(creditPackRequest, signedCreditPackTicket, closestAgreeingSupernodePastelID, pastelID, passphrase) {
  const storageRetryRequest = CreditPackStorageRetryRequest.build({
    sha3_256_hash_of_credit_pack_purchase_request_response_fields:
      signedCreditPackTicket.sha3_256_hash_of_credit_pack_purchase_request_response_fields,
    credit_pack_purchase_request_fields_json_b64:
      signedCreditPackTicket.credit_pack_purchase_request_fields_json_b64,
    requesting_end_user_pastelid: pastelID,
    closest_agreeing_supernode_to_retry_storage_pastelid: closestAgreeingSupernodePastelID,
    credit_pack_storage_retry_request_timestamp_utc_iso_string: new Date().toISOString(),
    credit_pack_storage_retry_request_pastel_block_height: await getCurrentPastelBlockHeight(),
    credit_pack_storage_retry_request_message_version_string: "1.0",
    sha3_256_hash_of_credit_pack_storage_retry_request_fields: "",
    requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash: "",
  });

  storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields =
    await computeSHA3256HashOfSQLModelResponseFields(storageRetryRequest);
  storageRetryRequest.requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash =
    await signMessageWithPastelID(
      pastelID,
      storageRetryRequest.sha3_256_hash_of_credit_pack_storage_retry_request_fields,
      passphrase
    );

  const { error: storageRetryRequestValidationError } = creditPackStorageRetryRequestSchema.validate(storageRetryRequest.toJSON());
  if (storageRetryRequestValidationError) {
    throw new Error(`Invalid credit pack storage retry request: ${storageRetryRequestValidationError.message}`);
  }

  return storageRetryRequest;
}

async function getCreditPackTicketInfoEndToEnd(creditPackTicketPastelTxid) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();
    const { url: supernodeURL } = await getClosestSupernodeToPastelIDURL(
      pastelID,
      validMasternodeListFullDF
    );
    if (!supernodeURL) {
      throw new Error("Supernode URL is undefined");
    }
    logger.info(
      `Getting credit pack ticket data from Supernode URL: ${supernodeURL}...`
    );

    const {
      creditPackPurchaseRequestResponse,
      creditPackPurchaseRequestConfirmation,
    } = await inferenceClient.getCreditPackTicketFromTxid(
      supernodeURL,
      creditPackTicketPastelTxid
    );

    const balanceInfo = await inferenceClient.checkCreditPackBalance(
      supernodeURL,
      creditPackTicketPastelTxid
    );

    return {
      requestResponse: creditPackPurchaseRequestResponse,
      requestConfirmation: creditPackPurchaseRequestConfirmation,
      balanceInfo,
    };
  } catch (error) {
    logger.error(`Error in getCreditPackTicketInfoEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getMyValidCreditPackTicketsEndToEnd() {
  const initialMinimumNonEmptyResponses = 5;
  const maxTotalResponsesIfAllEmpty = 20;
  const retryLimit = 1;

  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }

    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const { validMasternodeListFullDF } = await checkSupernodeList();

    const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(
      120,
      pastelID,
      validMasternodeListFullDF
    );

    let allResponses = [];
    let nonEmptyResponses = [];
    let isResolved = false;

    await new Promise((resolve, reject) => {
      let completedRequests = 0;

      const handleResponse = () => {
        if (isResolved) return;

        if (nonEmptyResponses.length >= initialMinimumNonEmptyResponses) {
          logger.info(
            `Received ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        } else if (allResponses.length >= maxTotalResponsesIfAllEmpty) {
          logger.info(
            `Reached maximum total responses (${maxTotalResponsesIfAllEmpty}) with ${nonEmptyResponses.length} non-empty responses`
          );
          isResolved = true;
          resolve();
        } else if (completedRequests >= closestSupernodes.length) {
          logger.warn(
            `Queried all available supernodes. Got ${nonEmptyResponses.length} non-empty responses out of ${allResponses.length} total responses`
          );
          isResolved = true;
          resolve();
        }
      };

      closestSupernodes.forEach(({ url }) => {
        if (isResolved) return;

        retryPromise(
          () => inferenceClient.getValidCreditPackTicketsForPastelID(url),
          retryLimit
        )
          .then((response) => {
            if (isResolved) return;

            logger.info(
              `Response received from supernode at ${url}; response length: ${response.length}`
            );
            allResponses.push({ response, url });
            if (response.length > 0) {
              nonEmptyResponses.push({ response, url });
            }
            completedRequests++;
            handleResponse();
          })
          .catch((error) => {
            if (isResolved) return;

            logger.error(
              `Error querying supernode at ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
            );
            completedRequests++;
            handleResponse();
          });
      });
    });

    if (nonEmptyResponses.length > 0) {
      // Return the longest non-empty response
      const longestResponse = nonEmptyResponses.reduce((prev, current) => {
        return current.response.length > prev.response.length ? current : prev;
      }).response;
      logger.info(
        `Returning longest non-empty response with length: ${longestResponse.length}`
      );
      return longestResponse;
    } else {
      logger.info("All responses were empty. Returning empty list.");
      return [];
    }
  } catch (error) {
    logger.error(
      `Error in getMyValidCreditPackTicketsEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return [];
  }
}

async function retryPromise(promiseFunc, limit, count = 0) {
  try {
    return await promiseFunc();
  } catch (error) {
    if (count < limit) {
      return retryPromise(promiseFunc, limit, count + 1);
    } else {
      throw error;
    }
  }
}

async function estimateCreditPackCostEndToEnd(
  desiredNumberOfCredits,
  creditPriceCushionPercentage
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const estimatedTotalCostOfTicket =
      await inferenceClient.internalEstimateOfCreditPackTicketCostInPSL(
        desiredNumberOfCredits,
        creditPriceCushionPercentage
      );
    return estimatedTotalCostOfTicket;
  } catch (error) {
    logger.error(`Error in estimateCreditPackCostEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function handleInferenceRequestEndToEnd(
  creditPackTicketPastelTxid,
  modelInputData,
  requestedModelCanonicalString,
  modelInferenceTypeString,
  modelParameters,
  maximumInferenceCostInCredits,
  burnAddress
) {
  try {
    const pastelID = globals.getPastelId();
    const passphrase = globals.getPassphrase();
    if (!pastelID || !passphrase) {
      throw new Error("PastelID or passphrase is not set");
    }
    const inferenceClient = new PastelInferenceClient(pastelID, passphrase);
    const modelParametersJSON = safeStringify(modelParameters);

    // Get the closest N supernode URLs that support the desired model, ordered by response time
    const supernodeURLs = await inferenceClient.getClosestSupernodeURLsThatSupportsDesiredModel(
      requestedModelCanonicalString,
      modelInferenceTypeString,
      modelParametersJSON,
      12 // Limit to the closest 12 supernodes
    );

    if (!supernodeURLs || supernodeURLs.length === 0) {
      logger.error(
        `No supporting supernode found with adequate performance for the desired model: ${requestedModelCanonicalString} with inference type: ${modelInferenceTypeString}`
      );
      return null;
    }

    let inferenceResultDict = null;
    let auditResults = null;
    let validationResults = null;
    let error = null;

    // Limit to trying the 5 fastest supernodes (based on response times)
    const maxTries = Math.min(5, supernodeURLs.length);

    for (let i = 0; i < maxTries; i++) {
      const supernodeURL = supernodeURLs[i];
      logger.info(`Attempting inference request to Supernode URL: ${supernodeURL}`);

      try {
        const modelInputDataJSONBase64Encoded = Buffer.from(
          JSON.stringify(modelInputData)
        ).toString("base64");

        const modelParametersJSONBase64Encoded =
          Buffer.from(modelParametersJSON).toString("base64");

        const currentBlockHeight = await getCurrentPastelBlockHeight();

        const inferenceRequestData = InferenceAPIUsageRequest.build({
          requesting_pastelid: pastelID,
          credit_pack_ticket_pastel_txid: creditPackTicketPastelTxid,
          requested_model_canonical_string: requestedModelCanonicalString,
          model_inference_type_string: modelInferenceTypeString,
          model_parameters_json_b64: modelParametersJSONBase64Encoded,
          model_input_data_json_b64: modelInputDataJSONBase64Encoded,
          inference_request_utc_iso_string: new Date().toISOString(),
          inference_request_pastel_block_height: currentBlockHeight,
          status: "initiating",
          inference_request_message_version_string: "1.0",
          sha3_256_hash_of_inference_request_fields: "",
          requesting_pastelid_signature_on_request_hash: "",
        });

        const sha3256HashOfInferenceRequestFields =
          await computeSHA3256HashOfSQLModelResponseFields(inferenceRequestData);
        inferenceRequestData.sha3_256_hash_of_inference_request_fields =
          sha3256HashOfInferenceRequestFields;
        const requestingPastelIDSignatureOnRequestHash =
          await signMessageWithPastelID(
            pastelID,
            sha3256HashOfInferenceRequestFields,
            passphrase
          );
        inferenceRequestData.requesting_pastelid_signature_on_request_hash =
          requestingPastelIDSignatureOnRequestHash;

        const usageRequestResponse =
          await inferenceClient.makeInferenceAPIUsageRequest(
            supernodeURL,
            inferenceRequestData
          );

        const validationErrors = await validateCreditPackTicketMessageData(
          usageRequestResponse
        );
        if (validationErrors && validationErrors.length > 0) {
          throw new Error(
            `Invalid inference request response from Supernode URL ${supernodeURL}: ${validationErrors.join(
              ", "
            )}`
          );
        }

        const usageRequestResponseDict = usageRequestResponse.toJSON();
        const inferenceRequestID = usageRequestResponseDict.inference_request_id;
        const inferenceResponseID = usageRequestResponseDict.inference_response_id;
        const proposedCostInCredits = parseFloat(
          usageRequestResponseDict.proposed_cost_of_request_in_inference_credits
        );
        const creditUsageTrackingPSLAddress =
          usageRequestResponseDict.credit_usage_tracking_psl_address;
        const creditUsageTrackingAmountInPSL =
          parseFloat(
            usageRequestResponseDict.request_confirmation_message_amount_in_patoshis
          ) / 100000;
        const trackingAddressBalance = await checkPSLAddressBalanceAlternative(
          creditUsageTrackingPSLAddress
        );

        if (trackingAddressBalance < creditUsageTrackingAmountInPSL) {
          logger.error(
            `Insufficient balance in tracking address: ${creditUsageTrackingPSLAddress}; amount needed: ${creditUsageTrackingAmountInPSL}; current balance: ${trackingAddressBalance}; shortfall: ${creditUsageTrackingAmountInPSL - trackingAddressBalance
            }`
          );
          return null;
        }

        if (proposedCostInCredits <= maximumInferenceCostInCredits) {
          const trackingTransactionTxid =
            await sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
              inferenceRequestID,
              creditUsageTrackingPSLAddress,
              creditUsageTrackingAmountInPSL,
              burnAddress
            );

          const txidLooksValid = /^[0-9a-fA-F]{64}$/.test(trackingTransactionTxid);

          if (txidLooksValid) {
            const confirmationData = InferenceConfirmation.build({
              inference_request_id: inferenceRequestID,
              requesting_pastelid: pastelID,
              confirmation_transaction: { txid: trackingTransactionTxid },
            });

            const confirmationResult =
              await inferenceClient.sendInferenceConfirmation(
                supernodeURL,
                confirmationData
              );

            logger.info(
              `Sent inference confirmation: ${prettyJSON(confirmationResult)}`
            );

            const maxTriesToGetConfirmation = 60;
            let initialWaitTimeInSeconds = 3;
            let waitTimeInSeconds = initialWaitTimeInSeconds;

            for (let cnt = 0; cnt < maxTriesToGetConfirmation; cnt++) {
              waitTimeInSeconds = waitTimeInSeconds * 1.04 ** cnt;
              logger.info(
                `Waiting for the inference results for ${Math.round(
                  waitTimeInSeconds
                )} seconds... (Attempt ${cnt + 1
                }/${maxTriesToGetConfirmation}); Checking with Supernode URL: ${supernodeURL}`
              );

              await new Promise((resolve) =>
                setTimeout(resolve, waitTimeInSeconds * 1000)
              );

              if (
                inferenceRequestID.length === 0 ||
                inferenceResponseID.length === 0
              ) {
                throw new Error("Inference request ID or response ID is empty");
              }

              const resultsAvailable =
                await inferenceClient.checkStatusOfInferenceRequestResults(
                  supernodeURL,
                  inferenceResponseID
                );

              if (resultsAvailable) {
                const outputResults =
                  await inferenceClient.retrieveInferenceOutputResults(
                    supernodeURL,
                    inferenceRequestID,
                    inferenceResponseID
                  );

                const outputResultsDict = outputResults.toJSON();
                const outputResultsSize =
                  outputResults.inference_result_json_base64.length;
                const maxResponseSizeToLog = 20000;

                inferenceResultDict = {
                  supernode_url: supernodeURL,
                  request_data: inferenceRequestData.toJSON(),
                  usage_request_response: usageRequestResponseDict,
                  model_input_data_json: modelInputData,
                  output_results: outputResultsDict,
                };

                if (modelInferenceTypeString === "text_to_image") {
                  let jsonString = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString("utf-8");
                  let jsonObject = JSON.parse(jsonString);
                  let imageBase64 = jsonObject.image;
                  inferenceResultDict.generated_image_decoded = Buffer.from(
                    imageBase64,
                    "base64"
                  );
                } else if (modelInferenceTypeString === "embedding_document") {
                  const inferenceResultDecoded = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString("utf-8");
                  let zipBinary = Buffer.from(inferenceResultDecoded, "base64");
                  inferenceResultDict.zip_file_data = zipBinary;
                } else {
                  const inferenceResultDecoded = Buffer.from(
                    outputResults.inference_result_json_base64,
                    "base64"
                  ).toString();
                  logger.info(`Decoded response:\n${inferenceResultDecoded}`);
                  inferenceResultDict.inference_result_decoded =
                    inferenceResultDecoded;
                }

                const useAuditFeature = false;

                if (useAuditFeature) {
                  logger.info(
                    "Waiting 3 seconds for audit results to be available..."
                  );
                  await new Promise((resolve) => setTimeout(resolve, 3000));

                  auditResults =
                    await inferenceClient.auditInferenceRequestResponseID(
                      inferenceResponseID,
                      supernodeURL
                    );
                  validationResults = validateInferenceData(
                    inferenceResultDict,
                    auditResults
                  );
                  logger.info(
                    `Validation results: ${prettyJSON(validationResults)}`
                  );
                  if (!auditResults) {
                    logger.warn("Audit results are null");
                  }
                  if (!validationResults) {
                    logger.warn("Validation results are null");
                  }
                } else {
                  auditResults = null;
                  validationResults = null;
                }

                if (!inferenceResultDict) {
                  logger.error("Inference result is null");
                  return {
                    inferenceResultDict: null,
                    auditResults: null,
                    validationResults: null,
                  };
                }
                return { inferenceResultDict, auditResults, validationResults };
              } else {
                logger.info("Inference results not available yet; retrying...");
              }
            }
          }
        } else {
          logger.info(
            `Quoted price of ${proposedCostInCredits} credits exceeds the maximum allowed cost of ${maximumInferenceCostInCredits} credits. Inference request not confirmed.`
          );
          return {
            inferenceResultDict: null,
            auditResults: null,
            validationResults: null,
          };
        }
      } catch (err) {
        error = err;
        logger.warn(`Failed inference request to Supernode URL ${supernodeURL}. Moving on to the next one.`);
      }
    }

    // If no inference request succeeded after all retries
    if (!inferenceResultDict) {
      throw new Error(
        `Failed to make inference request after ${maxTries} tries. Last error: ${error ? error.message : 'Unknown error'}`
      );
    }
  } catch (error) {
    logger.error(`Error in handleInferenceRequestEndToEnd: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

module.exports = {
  checkForNewIncomingMessages,
  sendMessageAndCheckForNewIncomingMessages,
  handleCreditPackTicketEndToEnd,
  getCreditPackTicketInfoEndToEnd,
  getMyValidCreditPackTicketsEndToEnd,
  handleInferenceRequestEndToEnd,
  estimateCreditPackCostEndToEnd,
};


---
./eslint.config.mjs
---
import globals from "globals";
import pluginJs from "@eslint/js";

export default [
  // Configuration for JavaScript files
  {
    files: ["**/*.js"], // Applies to all JavaScript files
    parserOptions: {
      // Correct from `languageOptions` to `parserOptions`
      sourceType: "commonjs", // Specifies CommonJS modules
    },
    env: {
      node: true, // Ensure Node.js environment is enabled
    },
    globals: { ...globals.node }, // Adds Node.js globals
    rules: {
      // Customize the `no-unused-vars` rule
      "no-unused-vars": [
        "warn",
        { argsIgnorePattern: "^_", varsIgnorePattern: "^_" },
      ],
    },
  },
  // Configuration for handling global variables in a browser context
  {
    parserOptions: {
      sourceType: "module",
    },
    env: {
      browser: true, // Explicitly set browser environment if needed
    },
    globals: globals.browser,
  },
  pluginJs.configs.recommended,
  // Your custom rule modifications can also go here
  {
    rules: {
      // ... other rules
    },
  },
];


---
./globals.js
---
let MY_LOCAL_PASTELID = null;
let MY_PASTELID_PASSPHRASE = null;

const MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE = 1000;

function setPastelIdAndPassphrase(pastelId, passphrase) {
    MY_LOCAL_PASTELID = pastelId;
    MY_PASTELID_PASSPHRASE = passphrase;
}

function getPastelIdAndPassphrase() {
    return { pastelID: MY_LOCAL_PASTELID, passphrase: MY_PASTELID_PASSPHRASE };
}

function getPastelId() {
    return MY_LOCAL_PASTELID;
}

function getPassphrase() {
    return MY_PASTELID_PASSPHRASE;
}

module.exports = {
    setPastelIdAndPassphrase,
    getPastelIdAndPassphrase,
    getPastelId,
    getPassphrase,
    MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE
};


---
./index.html
---
<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pastel Inference Client UI</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sira-ui/tailwind/dist/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/json.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.9.3/sha3.min.js"></script>
  <style>
    .ground-glass {
      background-color: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
    }

    body {
      font-family: Montserrat, sans-serif;
    }

    .btn.success.outline {
      border-color: #4caf50;
      color: #4caf50;
    }

    .btn.success.outline:hover {
      background-color: #4caf50;
      color: #ffffff;
    }

    .btn.success.outline:active {
      background-color: #388e3c;
      border-color: #388e3c;
      color: #ffffff;
    }

    .icon-large {
      font-size: 1.5rem;
      /* Adjust this size as needed */
    }

    .xterm {
      width: 100% !important;
      border-radius: 0.5rem;
      /* Adds rounded corners */
    }

    .table-container {
      overflow-x: auto;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .table th,
    .table td {
      padding: 0.5rem;
      border: 1px solid #ccc;
    }

    .table th:last-child,
    .table td:last-child {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 170px;
    }

    .table td:last-child:hover {
      white-space: normal;
    }

    [data-theme="dark"] {
      background-color: #121212;
      color: #ffffff;
    }

    [data-theme="dark"] .bg-white {
      background-color: #333333;
    }

    [data-theme="dark"] .text-bw-50 {
      color: #cccccc;
    }

    [data-theme="dark"] .text-bw-600 {
      color: #ffffff;
    }

    [data-theme="dark"] .text-bw-700 {
      color: #eeeeee;
    }

    [data-theme="dark"] .text-bw-800 {
      color: #ffffff;
    }

    [data-theme="dark"] .bg-bw-50 {
      background-color: #333333;
    }

    [data-theme="dark"] .btn.outline.bw {
      border-color: #ffffff;
      color: #ffffff;
    }

    [data-theme="dark"] .btn.outline.bw:hover {
      background-color: #ffffff;
      color: #000000;
    }

    [data-theme="dark"] .table .bg-gray-200 {
      background-color: #333333;
      color: #ffffff;
      /* This needs to be adjusted */
    }

    [data-theme="dark"] .table .bg-gray-200.selected-row {
      color: #000000;
      /* Adjust this color to be dark for legibility */
    }

    [data-theme="dark"] #previousRequestsList {
      background-color: #333333;
      color: #ffffff;
    }

    [data-theme="dark"] .input,
    [data-theme="dark"] .select {
      border-color: #cccccc;
    }

    [data-theme="dark"] .input::placeholder {
      color: #cccccc;
      opacity: 1;
      /* Firefox */
    }

    [data-theme="dark"] .input::-ms-input-placeholder {
      /* Edge 12-18 */
      color: #cccccc;
    }

    [data-theme="dark"] .select option {
      color: #333333;
    }

    [data-theme="dark"] .delete-btn {
      color: #ffffff;
      border-color: #ffffff;
    }

    [data-theme="dark"] .bg-bw-800 {
      background-color: #111827;
    }

    .table-responsive {
      overflow-x: auto;
    }

    .table.bordered tbody tr:last-child td:first-child {
      border-bottom-left-radius: 12px;
    }

    .table.bordered tbody tr:last-child td:last-child {
      border-bottom-right-radius: 12px;
    }

    .truncate {
      max-width: 150px;
      /* Adjust as needed */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .prompt.success.xs {
      display: inline-block;
      flex-grow: 1;
      /* Allow it to take up the remaining space */
      max-width: calc(100% - 2rem);
      /* Leave some padding for better readability */
      word-wrap: break-word;
      /* Ensure the text wraps correctly */
      height: 333px;
      /* Set a fixed height */
      overflow-y: auto;
      /* Add a scrollbar if the content exceeds the height */
      padding: 0.5rem;
      /* Add padding for better readability */
      border: 1px solid #ccc;
      /* Optional: Add a border for better visibility */
      border-radius: 0.5rem;
      /* Optional: Add rounded corners */
    }

    .prompt.success.xs .content {
      overflow-wrap: break-word;
    }

    .flex {
      display: flex;
    }

    .items-center {
      align-items: center;
    }

    .gap-4 {
      gap: 1rem;
      /* Adjust gap as needed */
    }

    .hidden {
      display: none;
    }

    #previousRequestsList {
      background-color: #f9f9f9;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1rem;
      max-height: 1200px;
      overflow-y: auto;
    }

    #requestPreview {
      background-color: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1.5rem;
    }

    [data-theme="dark"] #requestPreview {
      background-color: #0f291e;
    }

    .delete-btn {
      background: none;
      border: none;
      font-size: 1.25rem;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      transition: box-shadow 0.3s;
    }

    .delete-btn:hover {
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    #exportRequestsButton {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: auto;
    }

    .align-middle {
      vertical-align: middle;
    }

    .credit-pack-details-container {
      width: 100%;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .new-ticket-table th {
      width: 25%;
      /* As we have 4 columns, each gets 25% width */
    }

    .tooltip-icon {
      margin-left: 5px;
      font-size: 14px;
      color: #6b7280;
    }

    .select-column {
      width: 6%;
    }

    .initial-credits-column {
      width: 16%;
    }

    .current-credit-balance-column {
      width: 16.5%;
    }

    .tracking-address-column {
      width: 25%;
    }

    .table {
      width: 100%;
      table-layout: fixed;
    }

    .new-ticket-table {
      width: 100%;
      table-layout: auto;
    }

    .new-ticket-table th,
    .new-ticket-table td {
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
    }

    .registration-txid-column {
      width: 25%;
    }

    .sha3256-hash-of-credit-pack-column {
      width: 30%;
    }

    .responding-supernode-pastelid-column {
      width: 30%;
    }

    .outcome-column {
      width: 15%;
    }

    .btn.is-loading:before {
      display: inline-block;
      vertical-align: middle;
    }

    * {
      scroll-margin-top: 72px;
    }
  </style>
</head>

<body class="flex flex-col gap-6 transition-all duration-300 bg-bw-50">
  <div class="max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8">
    <div class="flex gap-6 items-center sticky top-0 p-4 bg-bw-50 z-10 ground-glass shadow-md" id="title">
      <h1 class="text-4xl font-bold text-bw-600">
        Pastel Inference Client
        <span id="networkName" class="text-xl font-normal align-middle"></span>
      </h1>
      <input id="theme-toggle" class="switch success lg" data-content="☀" type="checkbox" onchange="toggleDarkMode()" />
    </div>
    <div class="grid grid-cols-5 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl col-span-full text-bw-800">User Information</h2>
      <div class="col-span-full">
        <div id="noPastelIDContainer" class="hidden">
          <p class="text-bw-700">
            No PastelID found. Would you like to create a new one for 1,000
            PSL?
          </p>
          <form id="createPastelIDForm" class="mt-4">
            <label class="block text-bw-700 font-bold mb-2" for="newPastelIDPassphrase">
              Enter Passphrase (min 6 characters):
            </label>
            <input id="newPastelIDPassphrase" class="input w-full" type="password" placeholder="Enter passphrase"
              minlength="6" required />
            <div class="flex items-center gap-3">
              <button type="submit" class="btn success outline mt-4">
                Create PastelID
              </button>
              <div id="createPastelIDLoading"></div>
            </div>
            <div id="createPastelIDMessageContainer" class="my-4"></div>
            <!-- Container for messages -->
          </form>
          <p class="mt-4">
            Already have an existing PastelID? Import the file here:
          </p>
          <input id="importPastelIDFile" class="input w-full" type="file" />
          <div class="flex items-center gap-2 m-2 ml-0">
            <button id="importPastelIDButton" class="btn outline success">
              Import PastelID
            </button>
            <div class="hidden" id="importPastelIDBLoading"></div>
          </div>
        </div>

        <button id="changePastelIDButton" class="btn outline success" onclick="togglePastelIDDropdown()">
          Switch to a Different PastelID
        </button>
        <div id="pastelIDDropdownContainer" class="mt-4 hidden">
          <label class="block text-bw-700 font-bold mb-2">Select Existing PastelID to Use:</label>
          <select id="pastelIDDropdown" class="select w-full">
            <!-- Options will be dynamically populated -->
          </select>
        </div>
        <div class="mt-4 hidden" id="passphraseContainer">
          <label class="block text-bw-700 font-bold mb-2" for="pastelIDPassphrase">Enter Passphrase:</label>
          <input id="pastelIDPassphrase" class="input w-full" type="password" placeholder="Enter passphrase"
            minlength="6" required />
          <div class="mt-2">
            <input type="checkbox" id="rememberPassphrase" />
            <label for="rememberPassphrase" class="text-bw-700">Remember password?</label>
          </div>
          <button id="submitPassphraseButton" class="btn success outline mt-4">
            Submit
          </button>
          <div id="messageContainer" class="my-4"></div>
          <!-- Container for messages -->
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2">Your Currently Selected PastelID:</label>
          <span id="userPastelID" class="text-bw-700">Loading...</span>
        </div>
        <div class="mt-4">
          <label class="block text-bw-700 font-bold mb-2">Wallet Balance (PSL):</label>
          <span id="walletBalance" class="text-bw-700">
            Loading...
            <script>
              document.addEventListener("DOMContentLoaded", async () => {
                try {
                  const walletInfoResponse = await axios.get(
                    "/get-wallet-info"
                  );
                  const walletInfo = walletInfoResponse.data.result;
                  const formattedWalletBalance =
                    walletInfo.balance.toLocaleString(undefined, {
                      minimumFractionDigits: 1,
                      maximumFractionDigits: 1,
                    });
                  document.getElementById(
                    "walletBalance"
                  ).textContent = `${formattedWalletBalance} PSL`;
                } catch (error) {
                  console.error("Error retrieving wallet info:", error);
                  document.getElementById("walletBalance").textContent =
                    "Failed to load balance";
                }
              });
            </script>
          </span>
        </div>

        <div class="mt-4 flex items-center">
          <label class="block text-bw-700 font-bold mb-2">My PSL Address:</label>
          <span id="myPslAddress" class="text-bw-700 ml-2"></span>
          <button id="copyAddressButton" class="ml-2 tooltip" data-tooltip="Copy address to clipboard">
            📋
          </button>
        </div>

        <button id="createPastelIDButton" class="btn success outline m-4 hidden">
          Create a PastelID so you can make inference requests? (Costs 1,000
          PSL)
        </button>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Create New Credit Pack Ticket</h2>
      <form id="createTicketForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="numCredits">Number of Credits</label>
          <input class="input w-full" id="numCredits" type="text" placeholder="Enter number of credits" value="1500"
            data-raw-value="1500" required />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxTotalPrice">Maximum Total Price (PSL)</label>
          <input class="input w-full" id="maxTotalPrice" type="text" placeholder="Enter maximum total price"
            value="150000" data-raw-value="150000" required />
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="maxPerCreditPrice">Maximum Per Credit Price (PSL)</label>
          <input class="input w-full" id="maxPerCreditPrice" type="text" placeholder="Enter maximum per credit price"
            value="100.0" data-raw-value="100.0" required />
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <button class="btn success outline" type="submit" id="createCreditPackButton">
              Create Credit Pack
            </button>
            <div id="loaderContainer"></div>
            <!-- Add this div for the loader -->
            <div class="prompt success xs" id="createTicketStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="createTicketStatus">Current Status:</label>
              <div class="content p-2" id="createTicketStatus"></div>
            </div>
          </div>
        </div>
      </form>
      <div class="credit-pack-details-container" id="newCreditPackTicketDetailsContainer" style="display: none">
        <h3 class="text-xl text-bw-800">New Credit Pack Ticket Details</h3>
        <div class="table-responsive">
          <table class="table bordered bw new-ticket-table">
            <thead>
              <tr>
                <th>Registration TXID</th>
                <th>
                  SHA3-256 Hash of Credit Pack Purchase Request Fields
                </th>
                <th>Responding Supernode PastelID</th>
                <th>Outcome</th>
              </tr>
            </thead>
            <tbody id="newCreditPackTicketDetails">
              <!-- New ticket details will be dynamically populated here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Select Existing Credit Pack Ticket</h2>
      <div class="relative text-bw-700 table-responsive">
        <table class="table bordered bw">
          <thead>
            <tr>
              <th class="select-column">Select</th>
              <th class="initial-credits-column">Initial Credits in Pack</th>
              <th class="current-credit-balance-column">
                Current Credit Balance
              </th>
              <th class="tracking-address-column">Tracking Address</th>
              <th>Blockheight Registered</th>
              <th>Credit Pack Registration TXID</th>
            </tr>
          </thead>
          <tbody id="creditPackTicketTableBody">
            <!-- Rows will be dynamically populated here -->
          </tbody>
        </table>
        <div class="flex items-center gap-4 mt-4">
          <button id="refreshButton" class="btn success outline p-4 relative">
            Manually Refresh Credit Pack Tickets
            <span class="loader hidden absolute inset-0 flex items-center justify-center">
              <div class="is-loading"></div>
            </span>
          </button>
          <div class="btn is-loading hidden" id="loadingMessage">
            Loading...
          </div>
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl bg-white shadow-md">
      <h2 class="text-2xl text-bw-800">Create New Inference Request</h2>
      <form id="inferenceRequestForm" class="grid grid-cols-2 gap-4">
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="inferenceType">Inference Type</label>
          <div class="relative text-bw-700">
            <select id="inferenceType" class="select w-full">
              <option value="">Select an inference type</option>
              <option value="text_completion">Text Completion</option>
              <option value="ask_question_about_an_image">
                Ask a Question About an Image
              </option>
              <option value="text_to_image">Image Generation</option>
              <option value="embedding_document">Embedding Document</option>
              <option value="embedding_audio">
                Audio Transcript and Embedding
              </option>
            </select>
          </div>
        </div>
        <div>
          <label class="block text-bw-700 font-bold mb-2" for="model">Model/Service</label>
          <div class="relative text-bw-700">
            <select id="model" class="select w-full">
              <option value="">Select a model/service</option>
              <option value="groq-llama3-70b-8192" selected></option>
              <option value="claude3-opus">Claude3-Opus</option>
            </select>
          </div>
        </div>

        <div id="textCompletionSettings" class="col-span-full">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="prompt">Prompt</label>
            <textarea class="input w-full" id="prompt" rows="5" placeholder="Enter your prompt">
Write me a Shakespeare-style sonnet about Pastel Network and how it's really decentralized and powerful. </textarea>
          </div>
        </div>
        <div class="hidden col-span-full" id="modelAdvancedSettingsSection">
          <div>
            <button type="button" class="btn success outline" id="advancedSettingsButton">Show advanced
              settings</button>
          </div>
          <div id="modelAdvancedSettingsContent" class="hidden mt-4">
            <div id="modelParametersContainer" class="col-span-full"></div>
          </div>
        </div>

        <div id="imageGenerationSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imagePrompt">Image Prompt</label>
            <textarea class="input w-full" id="imagePrompt" rows="5" placeholder="Enter your image prompt">
A picture of a clown holding a sign that says PASTEL</textarea>
          </div>
        </div>

        <div id="embeddingDocumentSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="embeddingDocumentFile">Document to Embed</label>
            <input type="file" class="input w-full" id="embeddingDocumentFile" accept=".pdf,.doc,.docx,.txt" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="document_semantic_query_string">Semantic Query String
              (Optional):</label>
            <input class="input w-full" id="document_semantic_query_string" type="text"
              placeholder="Enter your query" />
          </div>
        </div>

        <div id="embeddingAudioSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="embeddingAudioFile">Audio File to Transcribe and
              Embed</label>
            <input type="file" class="input w-full" id="embeddingAudioFile" accept="audio/*" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="audio_semantic_query_string">Semantic Query String
              (Optional):</label>
            <input class="input w-full" id="audio_semantic_query_string" type="text" placeholder="Enter your query" />
          </div>
        </div>

        <div id="askQuestionAboutImageSettings" class="col-span-full" style="display: none">
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="imageFile">Image File</label>
            <input type="file" class="input w-full" id="imageFile" accept="image/*" />
          </div>
          <div class="mb-4">
            <label class="block text-bw-700 font-bold mb-2" for="question">Question</label>
            <input class="input w-full" id="question" type="text" placeholder="Enter your question" />
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-bw-700 font-bold mb-2" for="maxCost">Maximum Cost (Credits)</label>
          <input class="input w-full" id="maxCost" type="text" placeholder="Enter maximum cost" value="200"
            data-raw-value="200" />
          <span id="maxCostFormatted" class="text-bw-700"></span>
        </div>

        <div class="col-span-full flex justify-between">
          <div class="flex gap-4 items-center" style="width: 100%">
            <div class="flex items-center gap-2">
              <button class="btn success outline" type="submit" style="width: 180px">
                Create Inference Request
              </button>
            </div>
            <div class="prompt success xs" id="currentStatusContainer">
              <label class="text-bw-800 font-bold mb-4" for="currentStatus">Current Status:</label>
              <div class="content p-2" id="currentStatus"></div>
            </div>
          </div>
        </div>

        <div id="inferenceRequestResult"></div>
      </form>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 p-4 has-border rounded-xl bg-white shadow-md"
      style="height: 1000px; overflow-y: auto">
      <div class="lg:col-span-1 flex flex-col">
        <h2 class="text-2xl mb-4 text-bw-800">
          View Previous Inference Requests
        </h2>
        <div id="previousRequestsList" class="bg-gray-100 p-4 rounded-lg overflow-y-auto flex-grow"
          style="max-height: 1200px">
          <!-- List of previous inference requests will be dynamically populated here -->
        </div>
        <button id="exportRequestsButton" class="btn success outline mt-4 flex items-center self-start">
          💾 Export all Saved Inference Requests
        </button>
      </div>
      <div id="requestPreview" class="lg:col-span-2 bg-gray-50 p-4 rounded-lg">
        <!-- Preview of selected inference request will be shown here -->
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 p-4 has-border rounded-xl bg-white shadow-md">
      <div>
        <h2 class="text-2xl mb-4 text-bw-800">
          Send and Receive Messages using PastelIDs
        </h2>
        <form id="sendMessageForm" class="grid grid-cols-1 gap-4">
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="toPastelID">Recipient Pastel ID</label>
            <input class="input w-full" id="toPastelID" type="text" placeholder="Enter recipient Pastel ID"
              value="jXXiVgtFzLto4eYziePHjjb1hj3c6eXdABej5ndnQ62B8ouv1GYveJaD5QUMfainQM3b4MTieQuzFEmJexw8Cr" required />
          </div>
          <div>
            <label class="block text-bw-700 font-bold mb-2" for="messageBody">Message Body</label>
            <textarea class="input w-full" id="messageBody" rows="5" placeholder="Enter your message" required>
Hello, this is a brand 🍉 NEW test message from a regular user!</textarea>
          </div>
          <div class="flex justify-between">
            <button class="btn success outline" type="submit">
              Send Message
            </button>
          </div>
        </form>
      </div>
      <div>
        <h2 class="text-2xl mb-4">Received Messages</h2>
        <div id="receivedMessages" class="bg-bw-50 p-4 rounded-xl">
          <!-- Received messages will be dynamically populated here -->
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 gap-4 p-4 has-border rounded-xl">
      <h2 class="text-2xl">Manage Wallet</h2>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importPrivKey">
          Import Private Key
          <span class="tooltip" data-tooltip="Import a private key into your wallet.">&#9432;</span>
        </label>
        <input id="importPrivKey" class="input w-full" type="text" placeholder="Enter private key" />
        <div class="flex items-center gap-2 mt-2">
          <button id="importPrivKeyButton" class="btn success outline">
            Import Private Key
          </button>
          <div class="hidden" id="importPrivKeyLoading"></div>
        </div>
      </div>
      <div class="mb-4">
        <label class="block text-bw-700 font-bold mb-2" for="importWallet">
          Import Wallet
          <span class="tooltip" data-tooltip="Import a wallet file into your wallet.">&#9432;</span>
        </label>
        <input id="importWallet" class="input w-full" type="file" accept=".dat" />
        <div class="flex items-center gap-2 mt-2">
          <button id="importWalletButton" class="btn success outline mt-2">
            Import Wallet
          </button>
          <div class="hidden" id="importWalletLoading"></div>
        </div>
      </div>
      <label class="block text-bw-700 font-bold mb-2" for="listAddressAmountsButton">
        Misc Functions:
      </label>

      <div class="mb-4">
        <div class="flex items-center gap-2">
          <button id="listAddressAmountsButton" class="btn success outline">
            List Address Amounts
            <span class="tooltip" data-tooltip="List the amounts associated with each address in your wallet.">
              &#9432;
            </span>
          </button>
          <div class="hidden" id="listAddressAmountsLoading"></div>
        </div>

        <div id="addressAmountsContainer" class="mt-4" style="display: none; position: relative">
          <h2 class="text-2xl text-bw-800">Address Amounts:</h2>
          <button id="copyAddressAmountsButton" class="btn success outline" style="
                position: absolute;
                top: -1.5rem;
                right: 0.5rem;
                display: none;
              ">
            📋
          </button>
          <div class="table-responsive">
            <table id="addressAmountsTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <div class="flex items-center gap-2">
          <button id="getWalletInfoButton" class="btn success outline">
            Get Wallet Info
            <span class="tooltip" data-tooltip="Retrieve information about your wallet.">
              &#9432;
            </span>
          </button>
          <div class="hidden" id="getWalletInfoLoading"></div>
        </div>

        <div id="walletInfoContainer" class="mt-4" style="display: none; position: relative">
          <h2 class="text-2xl text-bw-800">Wallet Info:</h2>
          <button id="copyWalletInfoButton" class="btn success outline" style="
                position: absolute;
                top: -1.5rem;
                right: 0.5rem;
                display: none;
              ">
            📋
          </button>
          <div class="table-responsive">
            <table id="walletInfoTable" class="table bordered bw"></table>
          </div>
        </div>
      </div>

      <div class="mb-4">
        <button id="clearLocalStorageButton" class="btn success outline">
          Clear Inference Client Local Storage
          <span class="tooltip" data-tooltip="Clear all local storage data for this page.">
            &#9432;
          </span>
        </button>
      </div>
    </div>
    <button onclick="toggleTerminal()" class="btn success outline mt-4">
      Toggle Terminal
    </button>

    <h2 class="text-2xl mt-5">Terminal</h2>

    <div id="terminal" class="bg-gray-900 text-white p-4 rounded-xl"></div>
    <div class="flex justify-between items-center mb-4">
      <button id="exportTerminalButton" class="btn success outline">
        Export Terminal Session Text
      </button>
    </div>

    <div class="bg-bw-800 text-bw-50 py-6">
      <div class="container mx-auto px-4">
        <p class="text-center">
          &copy; 2024 Pastel Inference Client UI. All rights reserved.
        </p>
      </div>
    </div>

    <script>
      const MESSAGING_TIMEOUT_IN_SECONDS = 60;
      const LOADING_MESSAGE = "Wait while data is loaded...";
      const STORAGE_KEY = "validCreditPackTickets";
      const STORAGE_TIMESTAMP_KEY = "creditPackTicketsTimestamp";
      const REFRESH_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      function formatNumberWithCommas(number) {
        return number.toLocaleString();
      }

      function parseAndFormatNumber(value) {
        const number = parseFloat(value.replace(/,/g, ""));
        return isNaN(number) ? value : formatNumberWithCommas(number);
      }

      function handleInputChange(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const rawValue = inputElement.value.replace(/,/g, "");
        inputElement.setAttribute("data-raw-value", rawValue);

        if (["numCredits", "maxPerCreditPrice"].includes(inputElement.id)) {
          const numCredits = Number(
            document.getElementById("numCredits").value.replace(/,/g, "")
          );
          const maxPerCreditPrice = Number(
            document
              .getElementById("maxPerCreditPrice")
              .value.replace(/,/g, "")
          );
          let maxTotalPrice = numCredits * maxPerCreditPrice;
          maxTotalPrice = isNaN(maxTotalPrice)
            ? 0
            : formatNumberWithCommas(maxTotalPrice);
          const elMaxTotalPrice = document.getElementById("maxTotalPrice");
          elMaxTotalPrice.value = maxTotalPrice;
          elMaxTotalPrice.setAttribute(
            "data-raw-value",
            maxTotalPrice.replace(/,/g, "")
          );
        }
      }

      function handleInputBlur(event) {
        const inputElement = event.target;
        if (inputElement.type === "file") {
          return;
        }
        const formattedValue = parseAndFormatNumber(inputElement.value);
        inputElement.value = formattedValue;
      }

      async function fetchImageSize(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob.size;
      }

      async function getMyPslAddressWithLargestBalance() {
        try {
          const response = await axios.get(
            "/get-my-psl-address-with-largest-balance"
          );
          return response.data.result;
        } catch (error) {
          console.error(
            "Error retrieving PSL address with largest balance:",
            error
          );
          return "";
        }
      }

      function parseAndFormat(value) {
        try {
          if (typeof value === "string") {
            // Check if the JSON string is already formatted
            if (value.includes("\n")) {
              return value;
            }
            // Parse JSON string to handle it properly
            const parsedValue = JSON.parse(value);
            return JSON.stringify(parsedValue, null, 4); // Indent JSON string
          }
          return JSON.stringify(value, null, 4); // Format other values
        } catch (error) {
          return value; // Return original value if parsing fails
        }
      }

      function prettyJSON(data) {
        if (data instanceof Map) {
          data = Object.fromEntries(data); // Convert Map to object
        }
        if (
          Array.isArray(data) ||
          (typeof data === "object" && data !== null)
        ) {
          const formattedData = {};
          for (const [key, value] of Object.entries(data)) {
            if (typeof value === "string" && key.endsWith("_json")) {
              formattedData[key] = parseAndFormat(value);
            } else if (typeof value === "object" && value !== null) {
              formattedData[key] = prettyJSON(value); // Recurse for nested objects
            } else {
              formattedData[key] = value; // Handle other types
            }
          }
          return JSON.stringify(formattedData, null, 4); // Pretty print the object
        } else if (typeof data === "string") {
          return parseAndFormat(data); // Handle strings separately
        }
        return data; // Return data as is for other types
      }

      function sanitizeJSON(jsonString) {
        return jsonString.replace(/[^\x20-\x7E]+/g, ""); // Remove non-printable ASCII characters
      }

      function fallbackParseResult(result) {
        // If the result starts with {"text": ", strip it and the ending }
        if (result.startsWith(' {"text": "')) {
          result = result.slice(10); // Remove the prefix {"text": "
          const endIndex = result.indexOf('"}');
          if (endIndex !== -1) {
            result = result.slice(0, endIndex); // Remove the closing }
          }
        }

        // Remove anything including and after "} {"prompt":" from the end of the string
        const promptPattern = /"} {"prompt":".*$/;
        result = result.replace(promptPattern, "");

        return result;
      }

      async function fetchValidPastelIDs() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result.map((ticket) => ticket.ticket.pastelID);
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      function formatAndHighlightMessage(message) {
        const parts = message.split(/(\{[\s\S]*?\})/);
        return parts
          .map((part) => {
            try {
              if (part.startsWith("{") && part.endsWith("}")) {
                const parsed = JSON.parse(part);
                const formatted = prettyJSON(parsed);
                return `<pre><code class="json">${hljs.highlight(formatted, {
                  language: "json",
                  ignoreIllegals: true,
                }).value
                  }</code></pre>`;
              }
            } catch (e) {
              // If parsing fails, fall through to return the part as plain text
            }
            return `<span>${part}</span>`;
          })
          .join("");
      }

      function logCreateTicketStatusMessage(message, container) {
        if (message.includes("ECONNREFUSED")) return;
        container.innerHTML = ""; // Clear previous log messages
        const logElement = document.createElement("div");
        logElement.style.fontFamily = "Montserrat, sans-serif";
        logElement.innerHTML = formatAndHighlightMessage(message);
        container.appendChild(logElement);
        container.scrollTop = container.scrollHeight; // Scroll to bottom
      }

      function logStatusMessage(message) {
        if (message.includes("ECONNREFUSED")) return;
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.style.fontFamily = "Montserrat, sans-serif";
        currentStatus.style.whiteSpace = "pre-wrap"; // Ensure wrapping
        currentStatus.innerHTML = formatAndHighlightMessage(message);
      }

      function abbreviateJSON(jsonString, maxLength) {
        if (jsonString.length <= maxLength) return jsonString;
        const abbreviated = jsonString.slice(0, maxLength) + "...";
        const openBraces =
          (jsonString.match(/{/g) || []).length -
          (abbreviated.match(/{/g) || []).length;
        const openBrackets =
          (jsonString.match(/\[/g) || []).length -
          (abbreviated.match(/\[/g) || []).length;
        return (
          abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets)
        );
      }

      function logActionWithPayload(action, payloadName, jsonPayload) {
        const maxPayloadLength = 10000;
        let formattedPayload = prettyJSON(jsonPayload);

        // Truncate file contents in the payload
        if (typeof formattedPayload === 'string') {
          const fileContentRegex = /"(document|audio|image)":\s*"([^"]+)"/g;
          formattedPayload = formattedPayload.replace(fileContentRegex, (match, key, value) => {
            if (value.length > 100) {
              return `"${key}": "${value.substring(0, 100)}..."`;
            }
            return match;
          });
        }

        if (formattedPayload.length > maxPayloadLength) {
          formattedPayload = abbreviateJSON(formattedPayload, maxPayloadLength);
        }
        logger.info(`Now ${action} ${payloadName} with payload:\n${formattedPayload}`);
      }

      async function setSelectedPastelIDAndPassphrase(selectedPastelID) {
        let storedPassphrase = localStorage.getItem(selectedPastelID);

        try {
          const response = await axios.post("/check-pastel-id-validity", { pastelID: selectedPastelID });
          const isValid = response.data.isValid;

          if (!isValid) {
            console.log(`PastelID ${selectedPastelID} is not valid. Removing from localStorage.`);
            localStorage.removeItem(selectedPastelID);
            updatePastelIDUI();
            return;
          }

          if (!storedPassphrase) {
            const dialogHtml = `
        <div style="background-color: rgba(0, 0, 0, 0.5); position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center;">
          <div style="background-color: white; padding: 20px; border-radius: 5px; text-align: center;">
            <h2 style="margin-bottom: 10px;">Enter passphrase for PastelID:</h2>
            <p style="font-weight: bold; margin-bottom: 10px;">${selectedPastelID}</p>
            <input type="password" id="passphraseInput" class="input w-full" style="margin-bottom: 10px;" placeholder="Enter password">
            <div>
              <button id="submitPassphrase" style="padding: 5px 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">Submit</button>
            </div>
          </div>
        </div>
      `;

            const dialog = document.createElement("div");
            dialog.innerHTML = dialogHtml;
            document.body.appendChild(dialog);

            return new Promise((resolve) => {
              const submitButton = dialog.querySelector("#submitPassphrase");
              const passphraseInput = dialog.querySelector("#passphraseInput");

              submitButton.addEventListener("click", async () => {
                const inputPassphrase = passphraseInput.value;
                if (inputPassphrase) {
                  try {
                    localStorage.setItem(
                      selectedPastelID,
                      btoa(inputPassphrase)
                    );
                    storedPassphrase = btoa(inputPassphrase);
                    dialog.remove();
                    await postPassphrase(selectedPastelID, storedPassphrase);
                    resolve();
                  } catch (error) {
                    console.error("Error handling passphrase:", error);
                  }
                } else {
                  console.error("No passphrase entered");
                }
              });
            });
          } else {
            await postPassphrase(selectedPastelID, storedPassphrase);
          }
        } catch (error) {
          console.error("Error checking PastelID validity:", error);
        }
      }


      function updatePastelIDUI() {
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const userPastelID = document.getElementById("userPastelID");

        // Remove the invalid PastelID from the dropdown
        Array.from(pastelIDDropdown.options).forEach(option => {
          if (!localStorage.getItem(option.value)) {
            pastelIDDropdown.remove(option.index);
          }
        });

        // Update the displayed PastelID
        if (pastelIDDropdown.options.length > 0) {
          userPastelID.textContent = pastelIDDropdown.value;
        } else {
          userPastelID.textContent = "No valid PastelID available";
        }
      }


      async function postPassphrase(pastelID, encodedPassphrase) {
        try {
          await axios.post("/set-pastel-id-passphrase", {
            pastelID: pastelID,
            passphrase: atob(encodedPassphrase),
          });

          // Fetch the model menu after setting the PastelID and passphrase
          await fetchModelMenu();

          // Fetch received messages after setting the PastelID and passphrase
          await fetchReceivedMessages();
        } catch (error) {
          console.error("Error setting PastelID and passphrase:", error);
        }
      }

      function togglePastelIDDropdown() {
        const dropdown = document.getElementById("pastelIDDropdown");
        dropdown.classList.toggle("hidden");
        document
          .getElementById("pastelIDDropdownContainer")
          .classList.toggle("hidden");
      }

      function updatePastelIDSelection() {
        const selectedID = document.getElementById("pastelIDDropdown").value;
        document.getElementById("userPastelID").textContent =
          selectedID || "No PastelID selected";
      }

      async function checkCreditPackTicketInfo(txid) {
        try {
          const response = await axios.get(`/credit-pack-info/${txid}`);
          const { requestResponse, requestConfirmation, balanceInfo } =
            response.data;
          document.getElementById("requestResponse").textContent =
            JSON.stringify(requestResponse, null, 2);
          document.getElementById("requestConfirmation").textContent =
            JSON.stringify(requestConfirmation, null, 2);
          document.getElementById("currentCreditBalance").textContent =
            balanceInfo.current_credit_balance;
          document.getElementById("numberOfTransactions").textContent =
            balanceInfo.number_of_confirmation_transactions;
        } catch (error) {
          console.error("Error checking credit pack ticket info:", error);
          document.getElementById("requestResponse").textContent =
            "Failed to load credit pack info";
          document.getElementById("requestConfirmation").textContent = "";
          document.getElementById("currentCreditBalance").textContent = "";
          document.getElementById("numberOfTransactions").textContent = "";
        }
      }

      function getAddressURL(address) {
        let baseURL = "https://explorer.pastel.network/address/";
        if (address.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/address/";
        } else if (address.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/address/";
        }
        return `${baseURL}${address}`;
      }

      function getTxidURL(trackingAddress, txid) {
        let baseURL = "https://explorer.pastel.network/tx/";
        if (trackingAddress.startsWith("44")) {
          baseURL = "https://explorer-devnet.pastel.network/tx/";
        } else if (trackingAddress.startsWith("tP")) {
          baseURL = "https://explorer-testnet.pastel.network/tx/";
        }
        return `${baseURL}${txid}`;
      }

      async function listPastelIDTickets() {
        try {
          const response = await axios.get("/list-pastel-id-tickets", {
            params: { filter: "mine" },
          });
          return response.data.result;
        } catch (error) {
          console.error("Error retrieving Pastel ID tickets:", error);
          return [];
        }
      }

      async function checkTrackingAddresses() {
        try {
          const response = await fetch("/list-address-amounts");
          if (!response.ok) {
            throw new Error("Failed to fetch address amounts");
          }
          const data = await response.json();
          const walletAddresses = Object.keys(data.result);

          const trackingAddresses =
            document.querySelectorAll(".tracking-address");
          trackingAddresses.forEach((element) => {
            const address = element.textContent.trim();
            if (walletAddresses.includes(address)) {
              element.classList.add("valid-address");
              element.classList.remove("invalid-address");
            } else {
              element.classList.add("invalid-address");
              element.classList.remove("valid-address");
            }
          });
        } catch (error) {
          console.error("Error checking tracking addresses:", error.message);
        }
      }

      async function getMyValidCreditPacks(forceRefresh = false) {
        console.log(
          "getMyValidCreditPacks function called with forceRefresh:",
          forceRefresh
        );
        const loadingMessage = document.getElementById("loadingMessage");
        const tableBody = document.getElementById(
          "creditPackTicketTableBody"
        );
        loadingMessage.style.display = "block";

        let tooltip = document.getElementById("credit-pack-tooltip");
        if (!tooltip) {
          tooltip = document.createElement("div");
          tooltip.id = "credit-pack-tooltip";
          tooltip.className =
            "hidden fixed z-50 p-3 bg-white text-black rounded-lg shadow-lg border border-gray-300 transition-opacity duration-300 opacity-0 max-w-5xl text-xs";
          tooltip.style.pointerEvents = "none";
          document.body.appendChild(tooltip);
        }

        try {
          let validCreditPackTickets = [];
          const now = new Date().getTime();

          if (!forceRefresh) {
            const savedData = localStorage.getItem("validCreditPackTickets");
            const savedTimestamp = localStorage.getItem(
              "validCreditPackTicketsTimestamp"
            );

            if (
              savedData &&
              savedTimestamp &&
              now - savedTimestamp < 300000
            ) {
              validCreditPackTickets = JSON.parse(savedData);
            } else {
              const response = await axios.get("/get-my-valid-credit-packs");
              validCreditPackTickets = response.data.success
                ? response.data.result
                : [];
              localStorage.setItem(
                "validCreditPackTickets",
                JSON.stringify(validCreditPackTickets)
              );
              localStorage.setItem("validCreditPackTicketsTimestamp", now);
            }
          } else {
            const response = await axios.get("/get-my-valid-credit-packs");
            validCreditPackTickets = response.data.success
              ? response.data.result
              : [];
            localStorage.setItem(
              "validCreditPackTickets",
              JSON.stringify(validCreditPackTickets)
            );
            localStorage.setItem("validCreditPackTicketsTimestamp", now);
          }

          validCreditPackTickets = validCreditPackTickets.filter(
            (ticket) =>
              typeof ticket.credit_pack_current_credit_balance === "number" &&
              ticket.credit_pack_current_credit_balance > 0
          );

          let highestBalanceTicket = validCreditPackTickets.reduce(
            (max, ticket) =>
              ticket.credit_pack_current_credit_balance >
                (max?.credit_pack_current_credit_balance || 0)
                ? ticket
                : max,
            null
          );

          tableBody.innerHTML = "";

          const displayedColumns = [
            "credit_pack_registration_txid",
            "requested_initial_credits_in_credit_pack",
            "credit_pack_current_credit_balance",
            "credit_usage_tracking_psl_address",
            "credit_purchase_request_confirmation_pastel_block_height",
          ];

          for (const ticket of validCreditPackTickets) {
            const row = document.createElement("tr");
            row.className =
              "hover:bg-gray-100 transition-colors duration-200 cursor-pointer";

            const tooltipContent = Object.entries(ticket)
              .filter(([key]) => !displayedColumns.includes(key))
              .map(
                ([key, value]) => `
          <div class="flex justify-between py-1">
            <span class="font-semibold text-gray-800 mr-2 whitespace-nowrap">${key.replace(
                  /_/g,
                  " "
                )}:</span>
            <span class="text-gray-700">${value}</span>
          </div>
        `
              )
              .join("");

            let hoverTimeout;

            row.addEventListener("mouseenter", (e) => {
              hoverTimeout = setTimeout(() => {
                tooltip.innerHTML = tooltipContent;

                // Calculate position to keep tooltip within viewport and closer to the cursor
                const tooltipRect = tooltip.getBoundingClientRect();
                const xPos = Math.min(
                  e.clientX + 15,
                  window.innerWidth - tooltipRect.width - 10
                );
                const yPos = Math.min(
                  e.clientY + 15,
                  window.innerHeight - tooltipRect.height - 10
                );

                tooltip.style.left = `${xPos}px`;
                tooltip.style.top = `${yPos}px`;
                tooltip.classList.remove("hidden");
                setTimeout(() => {
                  tooltip.style.opacity = 1;
                }, 50);
              }, 300);
            });

            row.addEventListener("mousemove", (e) => {
              const tooltipRect = tooltip.getBoundingClientRect();
              const xPos = Math.min(
                e.clientX + 15,
                window.innerWidth - tooltipRect.width - 10
              );
              const yPos = Math.min(
                e.clientY + 15,
                window.innerHeight - tooltipRect.height - 10
              );

              tooltip.style.left = `${xPos}px`;
              tooltip.style.top = `${yPos}px`;
            });

            row.addEventListener("mouseleave", () => {
              clearTimeout(hoverTimeout);
              tooltip.style.opacity = 0;
              setTimeout(() => {
                tooltip.classList.add("hidden");
              }, 300);
            });

            const radioCell = document.createElement("td");
            const radioInput = document.createElement("input");
            radioInput.type = "radio";
            radioInput.name = "creditPackTicket";
            radioInput.value = ticket.requesting_end_user_pastelid;
            radioInput.dataset.txid = ticket.credit_pack_registration_txid;
            radioCell.appendChild(radioInput);
            row.appendChild(radioCell);

            const initialCreditsCell = document.createElement("td");
            initialCreditsCell.classList.add("truncate");
            initialCreditsCell.textContent = formatNumberWithCommas(
              ticket.requested_initial_credits_in_credit_pack
            );
            row.appendChild(initialCreditsCell);

            const currentCreditsCell = document.createElement("td");
            currentCreditsCell.classList.add("truncate");
            currentCreditsCell.textContent = formatNumberWithCommas(
              ticket.credit_pack_current_credit_balance
            );
            row.appendChild(currentCreditsCell);

            const trackingAddressCell = document.createElement("td");
            trackingAddressCell.classList.add("truncate", "tracking-address");
            const addressLink = document.createElement("a");
            addressLink.href = `https://explorer.pastel.network/address/${ticket.credit_usage_tracking_psl_address}`;
            addressLink.target = "_blank";
            addressLink.textContent =
              ticket.credit_usage_tracking_psl_address;
            trackingAddressCell.appendChild(addressLink);
            row.appendChild(trackingAddressCell);

            const blockheightCell = document.createElement("td");
            blockheightCell.classList.add("truncate");
            blockheightCell.textContent = formatNumberWithCommas(
              ticket.credit_purchase_request_confirmation_pastel_block_height
            );
            row.appendChild(blockheightCell);

            const creditPackRegistrationTxidCell =
              document.createElement("td");
            creditPackRegistrationTxidCell.classList.add("truncate");
            const txLink = document.createElement("a");
            txLink.href = `https://explorer.pastel.network/tx/${ticket.credit_pack_registration_txid}`;
            txLink.target = "_blank";
            txLink.textContent = ticket.credit_pack_registration_txid;
            creditPackRegistrationTxidCell.appendChild(txLink);
            row.appendChild(creditPackRegistrationTxidCell);

            tableBody.appendChild(row);

            if (ticket === highestBalanceTicket) {
              radioInput.checked = true;
              row.classList.add("bg-gray-200", "selected-row");
            }
          }

          handleCreditPackSelection();
        } catch (error) {
          console.error("Error retrieving valid credit pack tickets:", error);
        } finally {
          loadingMessage.style.display = "none";
        }
      }

      function showLoading(id) {
        if (!id) {
          return;
        }
        const loaderContainer = document.getElementById(id);
        if (!loaderContainer) {
          return;
        }
        loaderContainer.innerHTML = "";
        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader);
        loaderContainer.classList.remove("hidden");
      }

      function hideLoading(id) {
        if (!id) {
          return;
        }
        const loaderContainer = document.getElementById(id);
        if (!loaderContainer) {
          return;
        }
        loaderContainer.classList.add("hidden");
      }

      async function createNewCreditPackTicket(
        numCredits,
        maxTotalPrice,
        maxPerCreditPrice
      ) {
        const statusContainer = document.getElementById(
          "createTicketStatusContainer"
        );
        const statusContent = document.getElementById("createTicketStatus");
        const loaderContainer = document.getElementById("loaderContainer");

        if (!statusContainer || !statusContent || !loaderContainer) {
          console.error(
            "Status container, status content, or loader container element not found."
          );
          return;
        }

        statusContent.innerHTML = "";
        loaderContainer.innerHTML = "";

        let creditPackLoader = document.createElement("div");
        creditPackLoader.className = "btn is-loading";
        creditPackLoader.innerText = "Loading...";
        loaderContainer.appendChild(creditPackLoader);

        const newTicketDetailsContainer = document.getElementById(
          "newCreditPackTicketDetailsContainer"
        );
        const newTicketDetails = document.getElementById(
          "newCreditPackTicketDetails"
        );

        if (!newTicketDetailsContainer || !newTicketDetails) {
          console.error(
            "New ticket details container or new ticket details element not found."
          );
          return;
        }

        displayCreateTicketLoggerMessages = true;

        try {
          logCreateTicketStatusMessage(
            "Starting the creation of a new credit pack ticket...",
            statusContent
          );

          const desiredNumberOfCredits = numCredits;
          const amountOfPSLForTrackingTransactions = 10.0;
          const creditPriceCushionPercentage = 0.15;

          const estimatedTotalCostInPSLForCreditPackResponse =
            await axios.post("/estimate-credit-pack-cost", {
              desiredNumberOfCredits,
              creditPriceCushionPercentage,
            });

          const estimatedTotalCostInPSLForCreditPack =
            estimatedTotalCostInPSLForCreditPackResponse.data.result;

          if (estimatedTotalCostInPSLForCreditPack === undefined) {
            throw new Error(
              "Failed to estimate total cost for the credit pack"
            );
          }

          const amountToFundCreditTrackingAddress = Math.round(
            amountOfPSLForTrackingTransactions +
            estimatedTotalCostInPSLForCreditPack
          );

          const walletBalance = parseFloat(
            document
              .getElementById("walletBalance")
              .textContent.replace(/,/g, "")
          );
          if (amountToFundCreditTrackingAddress > walletBalance) {
            const insufficientFundsMessage = `The purchase of this credit pack would require ${amountToFundCreditTrackingAddress.toLocaleString()} PSL, but you only have ${walletBalance.toLocaleString()} PSL in your wallet. Please send at least ${(
              amountToFundCreditTrackingAddress - walletBalance
            ).toLocaleString()} more PSL to your wallet and try again. Alternatively, you can reduce the number of credits in the credit pack you are trying to purchase to ${Math.floor(
              walletBalance /
              (estimatedTotalCostInPSLForCreditPack / numCredits)
            ).toLocaleString()} credits instead of ${numCredits.toLocaleString()} credits.`;

            const errorMessageElement = document.createElement("div");
            errorMessageElement.classList.add(
              "text-red-800",
              "font-bold",
              "mt-4"
            );
            errorMessageElement.textContent = insufficientFundsMessage;
            statusContent.appendChild(errorMessageElement);

            console.error(insufficientFundsMessage);
            throw new Error(insufficientFundsMessage);
          }

          const response = await axios.post("/create-and-fund-new-address", {
            amount: amountToFundCreditTrackingAddress,
          });

          if (!response.data.success) {
            throw new Error(
              "Failed to create and fund new credit tracking address"
            );
          }

          const creditUsageTrackingPSLAddress =
            response.data.result.newCreditTrackingAddress;

          logCreateTicketStatusMessage(
            "Credit tracking address created and funded successfully.",
            statusContent
          );

          const ticketResponse = await axios.post(
            "/create-credit-pack-ticket",
            {
              numCredits,
              creditUsageTrackingPSLAddress,
              maxTotalPrice,
              maxPerCreditPrice,
            }
          );

          if (ticketResponse.data.success) {
            logCreateTicketStatusMessage(
              "Credit pack ticket created successfully.",
              statusContent
            );
            const result = ticketResponse.data.result;
            const formattedResult = prettyJSON(result);
            logCreateTicketStatusMessage(
              `Result: ${formattedResult}`,
              statusContent
            );

            newTicketDetails.innerHTML = `
        <tr>
          <td class="truncate">
            <a href="${getTxidURL(
              creditUsageTrackingPSLAddress,
              result.pastel_api_credit_pack_ticket_registration_txid
            )}" target="_blank">
              ${result.pastel_api_credit_pack_ticket_registration_txid}
            </a>
          </td>
          <td class="truncate">${result.sha3_256_hash_of_credit_pack_purchase_request_fields
              }</td>
          <td class="truncate">${result.responding_supernode_pastelid}</td>
          <td class="truncate">${result.credit_pack_confirmation_outcome_string
              }</td>
        </tr>
      `;

            newTicketDetailsContainer.style.display = "block";

            logCreateTicketStatusMessage(
              "Credit pack ticket created. Waiting for blockchain confirmation...",
              statusContent
            );

            pollCreditPackStatus(
              result.pastel_api_credit_pack_ticket_registration_txid
            );

            return result;
          } else {
            throw new Error("Failed to create new credit pack ticket");
          }
        } catch (error) {
          console.error(
            `Error creating new credit pack ticket: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
          );
          logCreateTicketStatusMessage(
            "Failed to create credit pack ticket. Please try again.",
            statusContent
          );
          throw error;
        } finally {
          creditPackLoader.remove();
          displayCreateTicketLoggerMessages = false;
        }
      }

      function pollCreditPackStatus(txid) {
        const pollInterval = 30000; // 30 seconds
        const maxAttempts = 20; // 10 minutes total
        let attempts = 0;

        const checkStatus = async () => {
          try {
            const response = await axios.get(`/credit-pack-status/${txid}`);
            if (response.data.confirmed) {
              logCreateTicketStatusMessage(
                "Credit pack ticket has been confirmed. Refreshing the table...",
                document.getElementById("createTicketStatus")
              );
              await getMyValidCreditPacks(true);
              logCreateTicketStatusMessage(
                "Credit pack ticket is now available for use.",
                document.getElementById("createTicketStatus")
              );
            } else {
              attempts++;
              if (attempts < maxAttempts) {
                logCreateTicketStatusMessage(
                  `Waiting for credit pack ticket confirmation... (Attempt ${attempts}/${maxAttempts})`,
                  document.getElementById("createTicketStatus")
                );
                setTimeout(checkStatus, pollInterval);
              } else {
                logCreateTicketStatusMessage(
                  "Credit pack ticket confirmation is taking longer than expected. It should appear soon. You can manually refresh the table to check.",
                  document.getElementById("createTicketStatus")
                );
              }
            }
          } catch (error) {
            console.error("Error checking credit pack status:", error);
            logCreateTicketStatusMessage(
              "An error occurred while checking the credit pack status. Please try refreshing the table manually.",
              document.getElementById("createTicketStatus")
            );
          }
        };

        checkStatus();
      }

      // Handle inference request stuff:
      let modelMenu = null;

      async function fetchModelMenu() {
        try {
          const response = await axios.get("/get-inference-model-menu");
          modelMenu = response.data.modelMenu;
          console.log("Model Menu:", modelMenu); // Debugging line, consider removing for production
          populateModelDropdown();
        } catch (error) {
          console.error("Error fetching model menu:", error);
          //displayError("Failed to load model menu. Please try again later.");
        }
      }

      function handleModelChange() {
        const selectedModelName = document.getElementById("model").value;
        const selectedModel = modelMenu.models.find(
          (model) => model.model_name === selectedModelName
        );

        if (selectedModel) {
          generateModelParameterFields(selectedModel);
        }
      }

      function generateModelParameterFields(selectedModel) {
        const modelAdvancedSettingsSection = document.getElementById("modelAdvancedSettingsSection");
        const modelParametersContainer = document.getElementById("modelParametersContainer");
        modelParametersContainer.innerHTML = "";
        const selectedInferenceType = document.getElementById("inferenceType").value;

        // Filter parameters based on the selected inference type
        const applicableParameters = selectedModel.model_parameters.filter(param => {
          const inferenceTypes = param.inference_types_parameter_applies_to;
          if (Array.isArray(inferenceTypes)) {
            return inferenceTypes.includes(selectedInferenceType);
          } else if (typeof inferenceTypes === 'string') {
            try {
              // Try parsing as JSON-like string (replacing single quotes with double quotes)
              const parsedTypes = JSON.parse(inferenceTypes.replace(/'/g, '"'));
              return Array.isArray(parsedTypes) && parsedTypes.includes(selectedInferenceType);
            } catch (e) {
              // If parsing fails, treat it as a comma-separated string
              return inferenceTypes.split(',').map(type => type.trim()).includes(selectedInferenceType);
            }
          }
          return false;
        });
        applicableParameters.forEach((param) => {
          const fieldContainer = document.createElement("div");
          fieldContainer.className = "mb-4";

          const labelText = param.description.split("[Optional]")[0].trim();
          const tooltipText = param.description.split("[Optional]")[1]?.trim().replace(/^\(|\)$/g, "") || "";

          const label = document.createElement("label");
          label.className = "block font-bold mb-2" + (param.description.includes("[Optional]") ? " text-bw-800" : "");
          label.htmlFor = param.name;
          label.textContent = labelText;
          fieldContainer.appendChild(label);

          if (tooltipText) {
            const tooltipSpan = document.createElement("span");
            tooltipSpan.className = "tooltip bw top";
            tooltipSpan.dataset.tooltip = tooltipText;
            const tooltipButton = document.createElement("button");
            tooltipButton.className = "tooltip-icon";
            tooltipButton.textContent = "ⓘ";
            tooltipSpan.appendChild(tooltipButton);
            label.appendChild(tooltipSpan);
          }

          const input = document.createElement("input");
          input.className = "input w-full";
          input.id = param.name;
          input.name = param.name;
          input.type = param.type === "float" || param.type === "int" ? "number" : "text";
          input.placeholder = `Enter ${param.description.toLowerCase()}`;
          input.value = param.default;

          if (param.name === "number_of_tokens_to_generate") {
            input.min = "1";
            input.max = "5000";
            input.step = "1";
          } else if (param.name === "temperature") {
            input.min = "0";
            input.max = "1";
            input.step = "0.01";
          } else if (param.name === "number_of_completions_to_generate") {
            input.min = "1";
            input.max = "10";
            input.step = "1";
          } else if (param.name === "grammar_file_string" || param.name === "query_string" || param.name === "corpus_identifier_string") {
            input.type = "text"; // Ensure it's a text input
          }

          fieldContainer.appendChild(input);
          modelParametersContainer.appendChild(fieldContainer);
        });

        if (applicableParameters.length) {
          modelAdvancedSettingsSection.classList.remove("hidden");
        } else {
          modelAdvancedSettingsSection.classList.add("hidden");
        }
      }

      function populateModelDropdown() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const modelSelect = document.getElementById("model");
        modelSelect.innerHTML =
          '<option value="">Select a model/service</option>';

        if (modelMenu) {
          if (selectedInferenceType === "ask_question_about_an_image") {
            const relevantModels = modelMenu.models.filter((model) =>
              model.supported_inference_type_strings.includes(
                selectedInferenceType
              )
            );

            relevantModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (relevantModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(relevantModels[0]);
            }
          } else {
            const filteredModels = modelMenu.models.filter(
              (model) =>
                model.supported_inference_type_strings &&
                model.supported_inference_type_strings.includes(
                  selectedInferenceType
                )
            );

            filteredModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.model_name;
              option.textContent = model.model_name;
              modelSelect.appendChild(option);
            });

            if (filteredModels.length > 0) {
              modelSelect.options[1].selected = true;
              generateModelParameterFields(filteredModels[0]);
            }
          }
        }
      }

      function displayError(message) {
        // Implement user-friendly error handling/display mechanism
        alert(message); // Simplistic example, consider more sophisticated modal or notification systems
      }

      // Load inference request settings from localStorage
      function loadInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const storedSettings = localStorage.getItem(
          `inferenceRequestSettings_${selectedInferenceType}`
        );
        if (storedSettings) {
          const settings = JSON.parse(storedSettings);
          document.getElementById("model").value = settings.model || "";
          document.getElementById("prompt").value = settings.prompt || "";
          document.getElementById("maxCost").value = settings.maxCost || "";
          document.getElementById("imagePrompt").value =
            settings.imagePrompt || "";
        }
      }

      // Save inference request settings to localStorage
      function saveInferenceRequestSettings() {
        const selectedInferenceType = inferenceTypeSelect.value;
        const settings = {
          model: document.getElementById("model").value,
          prompt: document.getElementById("prompt").value,
          maxCost: document.querySelector("#maxCost").dataset.rawValue,
          imagePrompt: document.getElementById("imagePrompt").value,
        };
        localStorage.setItem(
          `inferenceRequestSettings_${selectedInferenceType}`,
          JSON.stringify(settings)
        );
      }

      async function pollWalletAndPastelIDStatus(pastelID) {
        const pollInterval = 30000; // 30 seconds
        const maxAttempts = 20; // 10 minutes total
        let attempts = 0;

        const checkStatus = async () => {
          try {
            const response = await axios.get(
              `/check-pastel-id-status/${pastelID}`
            );
            const walletResponse = await axios.get("/get-wallet-info");
            const walletBalance = walletResponse.data.result.balance;
            if (response.data.registered && walletBalance > 0) {
              displayMessage(
                "Your PastelID has been registered and your wallet has been funded. The page will refresh shortly.",
                false,
                "createPastelIDMessageContainer"
              );
              setTimeout(() => location.reload(), 5000);
            } else {
              attempts++;
              if (attempts < maxAttempts) {
                let message =
                  "PastelID registration and wallet funding in progress...";
                if (response.data.registered) {
                  message =
                    "PastelID registered. Waiting for wallet to be funded...";
                } else if (walletBalance > 0) {
                  message =
                    "Wallet funded. Waiting for PastelID registration...";
                }
                displayMessage(
                  `${message} (Attempt ${attempts}/${maxAttempts})`,
                  false,
                  "createPastelIDMessageContainer"
                );
                setTimeout(checkStatus, pollInterval);
              } else {
                displayMessage(
                  "The process is taking longer than expected. Please refresh the page in a few minutes.",
                  false,
                  "createPastelIDMessageContainer"
                );
              }
            }
          } catch (error) {
            console.error(
              "Error checking PastelID and wallet status:",
              error
            );
            displayMessage(
              "An error occurred while checking your PastelID and wallet status. Please refresh the page in a few minutes.",
              false,
              "createPastelIDMessageContainer"
            );
          }
        };

        checkStatus();
      }
      createPastelIDForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const passphrase = document.getElementById(
          "newPastelIDPassphrase"
        ).value;
        if (passphrase.length < 6) {
          displayMessage(
            "Passphrase must be at least 6 characters long.",
            false,
            "createPastelIDMessageContainer"
          );
          return;
        }
        try {
          displayLoading(true, "createPastelIDLoading");
          const response = await axios.post(
            "/create-and-register-pastel-id",
            {
              passphraseForNewPastelID: passphrase,
            }
          );
          displayLoading(false, "createPastelIDLoading");
          if (response.data.success) {
            displayMessage(
              `PastelID creation initiated. Your new PastelID is ${response.data.PastelID}. Please wait while it's being registered on the blockchain...`,
              true,
              "createPastelIDMessageContainer"
            );
            localStorage.setItem(response.data.PastelID, btoa(passphrase));
            pollWalletAndPastelIDStatus(response.data.PastelID);
          } else {
            displayMessage(
              response.data.message,
              false,
              "createPastelIDMessageContainer"
            );
          }
        } catch (error) {
          displayLoading(false, "createPastelIDLoading");
          console.error("Error creating PastelID:", error);
          displayMessage(
            "Failed to create PastelID. Please try again.",
            false,
            "createPastelIDMessageContainer"
          );
        }
      });

      importPastelIDButton.addEventListener("click", async () => {
        const pastelIDFile =
          document.getElementById("importPastelIDFile").files[0];
        if (!pastelIDFile) {
          displayMessage("Please select a PastelID file to import.", false);
          return;
        }
        showLoading("importPastelIDBLoading");
        const formData = new FormData();
        formData.append("pastelIDFile", pastelIDFile);
        try {
          const { network } = await getNetworkInfo();
          const response = await axios.post(
            `/import-pastel-id?network=${network}`,
            formData
          );
          if (response.data.success) {
            displayMessage("PastelID imported successfully!", true);
            location.reload(); // Refresh the page to update the UI
          } else {
            displayMessage(response.data.message, false);
          }
        } catch (error) {
          console.error("Error importing PastelID:", error);
          displayMessage(
            "Failed to import PastelID. Please try again.",
            false
          );
        }
        hideLoading("importPastelIDBLoading");
      });

      function displayLoading(show, id = null) {
        const loader = document.getElementById(id || "loaderContainer");
        if (show) {
          loader.innerHTML = '<div class="btn is-loading">Loading...</div>';
        } else {
          loader.innerHTML = "";
        }
      }

      (async function () {
        try {
          const myPslAddress = await getMyPslAddressWithLargestBalance();
          document.getElementById("myPslAddress").textContent = myPslAddress;
        } catch (error) {
          console.error(
            "Error displaying PSL address with largest balance:",
            error
          );
        }
      })();

      function displayMessage(message, isSuccess, id = null) {
        const messageContainer = document.getElementById(
          id || "messageContainer"
        );
        messageContainer.innerHTML = `<p class="${isSuccess ? "text-green-600" : "text-red-600"
          } font-bold text-lg">${message}</p>`;
        messageContainer.scrollIntoView({ behavior: "smooth" });
      }

      async function getNetworkInfo() {
        const response = await axios.get("/get-network-info");
        return response.data;
      }

      (async function () {
        try {
          // Check if there are any PastelIDs on initial load
          const pastelIDTickets = await listPastelIDTickets();
          if (pastelIDTickets.length === 0) {
            document
              .getElementById("pastelIDDropdownContainer")
              .classList.add("hidden");
            document
              .getElementById("changePastelIDButton")
              .classList.add("hidden");
            noPastelIDContainer.classList.remove("hidden");
          } else {
            const validPastelIDs = await fetchValidPastelIDs();
            const storedPastelIDs = Object.keys(localStorage);
            let hasPastelID = false;
            storedPastelIDs.forEach((pastelID) => {
              if (validPastelIDs.includes(pastelID)) {
                hasPastelID = true;
              }
            });
            if (!hasPastelID) {
              await setSelectedPastelIDAndPassphrase(
                pastelIDTickets[0].ticket.pastelID
              );
              location.reload();
            }
            noPastelIDContainer.classList.add("hidden");
            document
              .getElementById("pastelIDDropdownContainer")
              .classList.remove("hidden");
            document
              .getElementById("changePastelIDButton")
              .classList.remove("hidden");
          }
        } catch (error) {
          console.error("Error checking PastelIDs:", error);
        }
      })();

      document.addEventListener("DOMContentLoaded", async () => {
        const pastelIDDropdown = document.getElementById("pastelIDDropdown");
        const passphraseContainer = document.getElementById(
          "passphraseContainer"
        );
        const pastelIDPassphrase =
          document.getElementById("pastelIDPassphrase");
        const rememberPassphrase =
          document.getElementById("rememberPassphrase");
        const submitPassphraseButton = document.getElementById(
          "submitPassphraseButton"
        );
        const refreshButton = document.getElementById("refreshButton");

        async function fetchValidPastelIDs() {
          try {
            const response = await axios.get("/list-pastel-id-tickets", {
              params: { filter: "mine" },
            });
            return response.data.result.map(
              (ticket) => ticket.ticket.pastelID
            );
          } catch (error) {
            console.error("Error retrieving Pastel ID tickets:", error);
            return [];
          }
        }

        const validPastelIDs = await fetchValidPastelIDs();
        const storedPastelIDs = Object.keys(localStorage);

        storedPastelIDs.forEach((pastelID) => {
          if (validPastelIDs.includes(pastelID)) {
            const option = document.createElement("option");
            option.value = pastelID;
            option.textContent = pastelID;
            pastelIDDropdown.appendChild(option);
          }
        });

        pastelIDDropdown.addEventListener("change", async () => {
          const selectedPastelID = pastelIDDropdown.value;
          document.getElementById("userPastelID").textContent =
            selectedPastelID || "No PastelID selected";
          if (selectedPastelID) {
            const storedPassphrase = localStorage.getItem(selectedPastelID);
            if (storedPassphrase) {
              pastelIDPassphrase.value = atob(storedPassphrase);
              passphraseContainer.classList.add("hidden");
            } else {
              passphraseContainer.classList.remove("hidden");
            }
            await setSelectedPastelIDAndPassphrase(selectedPastelID);
          } else {
            passphraseContainer.classList.add("hidden");
          }
          refreshCreditPackTickets();
        });

        submitPassphraseButton.addEventListener("click", async () => {
          const selectedPastelID = pastelIDDropdown.value;
          const passphrase = pastelIDPassphrase.value;

          if (rememberPassphrase.checked) {
            const encryptedPassphrase = btoa(passphrase); // Simple base64 encoding
            localStorage.setItem(selectedPastelID, encryptedPassphrase);
          }

          try {
            const response = await axios.post("/set-pastel-id-passphrase", {
              pastelID: selectedPastelID,
              passphrase: passphrase,
            });

            if (response.data.success) {
              document.getElementById("messageContainer").innerText =
                "Successfully set PastelID and passphrase!";
            } else {
              document.getElementById("messageContainer").innerText =
                "Failed to set PastelID and passphrase.";
            }
          } catch (error) {
            console.error("Error setting PastelID and passphrase:", error);
            document.getElementById("messageContainer").innerText =
              "Failed to set PastelID and passphrase.";
          }
        });

        if (validPastelIDs.length === 0) {
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.add("hidden");
          document
            .getElementById("changePastelIDButton")
            .classList.add("hidden");
          noPastelIDContainer.classList.remove("hidden");
        } else {
          noPastelIDContainer.classList.add("hidden");
          document
            .getElementById("pastelIDDropdownContainer")
            .classList.remove("hidden");
          document
            .getElementById("changePastelIDButton")
            .classList.remove("hidden");
        }

        // Call setSelectedPastelIDAndPassphrase based on the number of PastelIDs
        if (validPastelIDs.length === 1) {
          const pastelID = validPastelIDs[0];
          document.getElementById("userPastelID").textContent = pastelID;
          pastelIDDropdown.value = pastelID; // Set the selected value of the dropdown
          await setSelectedPastelIDAndPassphrase(pastelID);
        } else {
          const selectedPastelID = pastelIDDropdown.value;
          document.getElementById("userPastelID").textContent =
            selectedPastelID || "No PastelID selected";
          if (selectedPastelID) {
            await setSelectedPastelIDAndPassphrase(selectedPastelID);
          }
        }
      });

      async function refreshCreditPackTickets() {
        const refreshButton = document.getElementById("refreshButton");
        const loader = refreshButton.querySelector(".loader");
        const loadingMessage = document.getElementById("loadingMessage");

        loader.classList.remove("hidden");
        loadingMessage.classList.remove("hidden");

        await getMyValidCreditPacks(true);

        loader.classList.add("hidden");
        loadingMessage.classList.add("hidden");
      }

      // Add event listener for the refresh button
      document
        .getElementById("refreshButton")
        .addEventListener("click", refreshCreditPackTickets);

      // Handle inference type change
      const inferenceTypeSelect = document.getElementById("inferenceType");
      const textCompletionSettings = document.getElementById(
        "textCompletionSettings"
      );
      const imageGenerationSettings = document.getElementById(
        "imageGenerationSettings"
      );

      inferenceTypeSelect.addEventListener("change", () => {
        const selectedInferenceType =
          document.getElementById("inferenceType").value;
        const textCompletionSettings = document.getElementById(
          "textCompletionSettings"
        );
        const imageGenerationSettings = document.getElementById(
          "imageGenerationSettings"
        );
        const embeddingDocumentSettings = document.getElementById(
          "embeddingDocumentSettings"
        );
        const embeddingAudioSettings = document.getElementById(
          "embeddingAudioSettings"
        );
        const askQuestionAboutImageSettings = document.getElementById(
          "askQuestionAboutImageSettings"
        );

        textCompletionSettings.style.display = "none";
        imageGenerationSettings.style.display = "none";
        embeddingDocumentSettings.style.display = "none";
        embeddingAudioSettings.style.display = "none";
        askQuestionAboutImageSettings.style.display = "none";

        if (selectedInferenceType === "text_completion") {
          textCompletionSettings.style.display = "block";
        } else if (selectedInferenceType === "text_to_image") {
          imageGenerationSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_document") {
          embeddingDocumentSettings.style.display = "block";
        } else if (selectedInferenceType === "embedding_audio") {
          embeddingAudioSettings.style.display = "block";
        } else if (selectedInferenceType === "ask_question_about_an_image") {
          askQuestionAboutImageSettings.style.display = "block";
        }
        // Update the model dropdown and parameter fields
        populateModelDropdown();
        loadInferenceRequestSettings();
      });

      document
        .getElementById("model")
        .addEventListener("change", handleModelChange);

      document
        .getElementById("advancedSettingsButton")
        .addEventListener("click", handleAdvancedSettingsButtonChange);

      function handleAdvancedSettingsButtonChange() {
        const advancedSettingsButton = document.getElementById("advancedSettingsButton");
        const modelAdvancedSettingsContent = document.getElementById("modelAdvancedSettingsContent");
        if (modelAdvancedSettingsContent.classList.contains('hidden')) {
          advancedSettingsButton.innerHTML = 'Hide advanced settings';
        } else {
          advancedSettingsButton.innerHTML = 'Show advanced settings';
        }
        modelAdvancedSettingsContent.classList.toggle("hidden");
      }

      function handleCreditPackSelection() {
        const radioButtons = document.querySelectorAll(
          'input[name="creditPackTicket"]'
        );
        radioButtons.forEach((button) => {
          button.addEventListener("change", () => {
            document
              .querySelectorAll("#creditPackTicketTableBody tr")
              .forEach((row) => {
                row.classList.remove("bg-gray-200", "selected-row");
              });
            button.parentElement.parentElement.classList.add(
              "bg-gray-200",
              "selected-row"
            );
          });
        });
      }

      document
        .getElementById("copyAddressButton")
        .addEventListener("click", () => {
          const addressElement = document.getElementById("myPslAddress");
          const address = addressElement.textContent;

          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(address).then(() => {
              const tooltip = document.getElementById("copyAddressButton");
              tooltip.setAttribute(
                "data-tooltip",
                "Copied address to clipboard!"
              );

              setTimeout(() => {
                tooltip.setAttribute(
                  "data-tooltip",
                  "Copy address to clipboard"
                );
              }, 2000);
            });
          } else {
            const tempInput = document.createElement("input");
            tempInput.value = address;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand("copy");
            document.body.removeChild(tempInput);

            const tooltip = document.getElementById("copyAddressButton");
            tooltip.setAttribute(
              "data-tooltip",
              "Copied address to clipboard!"
            );

            setTimeout(() => {
              tooltip.setAttribute(
                "data-tooltip",
                "Copy address to clipboard"
              );
            }, 2000);
          }
        });

      document.addEventListener("DOMContentLoaded", () => {
        handleCreditPackSelection();
      });

      let displayInferenceRequestLoggerMessages = false;
      let displayCreateTicketLoggerMessages = false;

      async function saveInferenceRequestToLocalStorage(requestData) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        if (
          requestData.selectedInferenceType === "ask_question_about_an_image"
        ) {
          try {
            const imageFile = document.getElementById("imageFile").files[0];
            const compressedImage = await compressImage(imageFile);
            requestData.inputFields.image = compressedImage;
          } catch (error) {
            console.error("Error compressing image:", error);
          }
        } else if (
          requestData.selectedInferenceType === "embedding_document"
        ) {
          const fileInput = document.getElementById("embeddingDocumentFile");
          const originalFileName = fileInput.files[0].name;
          const fileHash = sha3_256(requestData.inputFields.document);
          requestData.inputFields.document_details = `
            <div>
              <p>Original File Name: ${originalFileName}</p>
              <p>File Hash: ${fileHash}</p>
            </div>
          `;
          delete requestData.inputFields.document;
        } else if (requestData.selectedInferenceType === "embedding_audio") {
          const fileHash = sha3_256(requestData.inputFields.audio);
          requestData.inputFields.fileHash = fileHash;
          delete requestData.inputFields.audio;
        } else if (requestData.selectedInferenceType === "text_to_image") {
          const generatedImage = document.getElementById("generated-image");
          const compressedImage = await compressGeneratedImage(
            generatedImage
          );
          requestData.inferenceResultsDecoded = compressedImage;
        }
        if (requestData.selectedInferenceType === "embedding_document") {
          const embeddingDocumentFileInput = document.getElementById(
            "embeddingDocumentFile"
          );
          if (
            embeddingDocumentFileInput &&
            embeddingDocumentFileInput.files.length > 0
          ) {
            requestData.inputFields.document_file_name =
              embeddingDocumentFileInput.files[0].name;
          }
        } else if (requestData.selectedInferenceType === "embedding_audio") {
          const embeddingAudioFileInput =
            document.getElementById("embeddingAudioFile");
          if (
            embeddingAudioFileInput &&
            embeddingAudioFileInput.files.length > 0
          ) {
            requestData.inputFields.audio_file_name =
              embeddingAudioFileInput.files[0].name;
          }
        }
        requests.push(requestData);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      async function compressGeneratedImage(imgElement) {
        try {
          const options = {
            maxSizeMB: 0.05,
            maxWidthOrHeight: 600,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          };
          const response = await fetch(imgElement.src);
          const blob = await response.blob();
          const compressedFile = await imageCompression(blob, options);
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = (error) => {
              console.error("Reader error:", error);
              reject(error);
            };
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          console.error("Compression error:", error);
          throw error;
        }
      }
      async function compressImage(imageBlob) {
        try {
          const compressedFile = await imageCompression(imageBlob, {
            maxSizeMB: 0.03,
            maxWidthOrHeight: 500,
            useWebWorker: true,
            initialQuality: 0.6,
            fileType: "image/webp",
          });
          const reader = new FileReader();
          return new Promise((resolve, reject) => {
            reader.onloadend = () => {
              resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(compressedFile);
          });
        } catch (error) {
          throw error;
        }
      }
      function updatePreviousRequestsList() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const listContainer = document.getElementById("previousRequestsList");
        listContainer.innerHTML = "";

        if (requests.length === 0) {
          const noRequestsMessage = document.createElement("p");
          noRequestsMessage.className = "text-gray-500";
          noRequestsMessage.textContent =
            "No saved inference requests to display. Create new ones and they will display here when they finish successfully.";
          listContainer.appendChild(noRequestsMessage);
        } else {
          requests.forEach((request, index) => {
            let inferenceTypeIcon;
            let promptPreview;
            if (request.selectedInferenceType === "text_completion") {
              inferenceTypeIcon = "🖹";
              promptPreview = request.prompt;
            } else if (request.selectedInferenceType === "text_to_image") {
              inferenceTypeIcon = "🖼️";
              promptPreview = request.inputFields.imagePrompt;
            } else if (
              request.selectedInferenceType === "ask_question_about_an_image"
            ) {
              inferenceTypeIcon = "🖺";
              promptPreview = request.inputFields.question;
            } else if (
              request.selectedInferenceType === "embedding_document"
            ) {
              inferenceTypeIcon = "🔢";
              promptPreview = request.inputFields.document_file_name || "";
            } else if (request.selectedInferenceType === "embedding_audio") {
              inferenceTypeIcon = "🕪";
              promptPreview = request.inputFields.audio_file_name || "";
            } else {
              inferenceTypeIcon = "❔";
              promptPreview = request.prompt;
            }
            if (
              request.selectedInferenceType !== "embedding_document" &&
              request.selectedInferenceType !== "embedding_audio"
            ) {
              const previewText =
                request.selectedInferenceType ===
                  "ask_question_about_an_image"
                  ? request.inputFields.question
                  : request.prompt;
              promptPreview =
                request.selectedInferenceType === "text_to_image"
                  ? request.inputFields.imagePrompt.substring(0, 40)
                  : previewText
                    ? previewText.substring(0, 40)
                    : "No prompt available";
            }

            const listItem = document.createElement("div");
            listItem.className =
              "mb-2 p-2 bg-white rounded-lg flex justify-between items-center cursor-pointer";
            listItem.innerHTML = `<span><span class="icon-large">${inferenceTypeIcon}</span> ${promptPreview}...</span>
              <button class="delete-btn" style="font-size: 0.75rem;" title="Delete entry?" onclick="deleteRequest(${index})">❌</button>`;
            listItem.addEventListener("click", () =>
              displayRequestPreview(index)
            );
            listContainer.appendChild(listItem);
          });
        }
      }

      function deleteRequest(index) {
        let requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        requests.splice(index, 1);
        localStorage.setItem("inferenceRequests", JSON.stringify(requests));
        updatePreviousRequestsList();
      }

      function exportRequests() {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        if (requests.length === 0) {
          alert("No saved inference requests to export.");
          return;
        }

        let markdownContent = "# Saved Inference Requests\n\n";
        requests.forEach((request, index) => {
          markdownContent += `## Inference Request ${index + 1}\n`;
          markdownContent += `**Prompt**: ${request.selectedInferenceType === "ask_question_about_an_image"
            ? request.inputFields.question
            : request.prompt
            }\n\n`;
          markdownContent += `**Inference Results**:\n\n`;

          if (request.selectedInferenceType === "text_to_image") {
            markdownContent += `![Generated Image](${request.compressedImage})\n\n`;
          } else {
            request.inferenceResultsDecoded.forEach((result, i) => {
              markdownContent += `### Completion ${i + 1}\n`;
              markdownContent += `\`\`\`\n${result}\n\`\`\`\n\n`;
            });
          }
          markdownContent += `**Model**: ${request.selectedModelCanonicalName}\n`;
          markdownContent += `**Actual Cost (Credits)**: ${request.actualCreditsUsed}\n`;
          markdownContent += `**Remaining Credits**: ${request.remainingCredits}\n`;
          markdownContent += `**Misc. Inference Parameters and Statistics**:\n`;
          markdownContent += `| Parameter | Value |\n`;
          markdownContent += `| --- | --- |\n`;
          markdownContent += `| Input Prompt to LLM | ${request.selectedInferenceType === "ask_question_about_an_image"
            ? request.inputFields.question
            : request.prompt
            } |\n`;
          markdownContent += `| Actual Cost (Credits) | ${request.actualCreditsUsed} |\n`;
          markdownContent += `| Remaining Credits | ${request.remainingCredits} |\n`;
          markdownContent += `| Model | ${request.selectedModelCanonicalName} |\n`;
          markdownContent += `| Request Timestamp | ${request.requestTimestamp} |\n`;
          markdownContent += `| Total Time (Seconds) | ${request.elapsedTimeInSeconds} |\n`;
          markdownContent += `\n\n`;
        });

        const blob = new Blob([markdownContent], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "inference_requests.md";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      document
        .getElementById("exportRequestsButton")
        .addEventListener("click", exportRequests);

      updatePreviousRequestsList();

      function displayRequestPreview(index) {
        const requests =
          JSON.parse(localStorage.getItem("inferenceRequests")) || [];
        const request = requests[index];
        const previewContainer = document.getElementById("requestPreview");
        let combinedResults = "";
        if (request.selectedInferenceType === "text_completion") {
          const results = Array.isArray(
            JSON.parse(request.inferenceResultsDecoded)
          )
            ? JSON.parse(request.inferenceResultsDecoded)
            : [JSON.parse(request.inferenceResultsDecoded)];
          results.forEach((result, i) => {
            let parsedResult = result;
            try {
              const sanitizedResult = sanitizeJSON(result);
              const parsedJSON = JSON.parse(sanitizedResult);
              if (parsedJSON.text) {
                parsedResult = parsedJSON.text;
              }
            } catch (e) {
              parsedResult = fallbackParseResult(result);
            }
            combinedResults += `<h4>Completion ${i + 1} of ${results.length
              }</h4>`;
            combinedResults += `<github-md>${parsedResult}</github-md>`;
            if (i < results.length - 1) {
              combinedResults += "<hr>";
            }
          });
        } else if (
          request.selectedInferenceType === "ask_question_about_an_image"
        ) {
          combinedResults = `
            <img src="${request.inputFields.image
            }" alt="Input Image" style="max-width: 100%; max-height: 400px;">
            <p>Question: ${request.inputFields.question}</p>
            <p>Answer:</p>
            <github-md>${JSON.parse(request.inferenceResultsDecoded)[0]
            }</github-md>
          `;
        } else if (request.selectedInferenceType === "embedding_document") {
          combinedResults = `
                    <p>Semantic Query String: ${request.inputFields.question}</p>
                    `;
        } else if (request.selectedInferenceType === "embedding_audio") {
          const inferenceResultDecoded = request.inferenceResultsDecoded;
          const formattedResult = prettyJSON(inferenceResultDecoded);
          const coloredResult = formattedResult
            .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
            .replace(
              /"([^"]+)"(?=:)/g,
              '<span style="color: #2196F3;">$1</span>'
            ) // Pale blue for keys
            .replace(
              /: ("[^"]+")/g,
              ': <span style="color: #FFC107;">$1</span>'
            ) // Pale yellow for string values
            .replace(/: (\d+)/g, ': <span style="color: #FFC107;">$1</span>') // Pale yellow for numeric values
            .replace(
              /: (true|false|null)/g,
              ': <span style="color: #FFC107;">$1</span>'
            ); // Pale yellow for boolean and null values
          combinedResults = `
            <p>Original File Name: ${request.inputFields.audio_file_name}</p>
            <p>File SHA3-256 Hash: ${request.inputFields.fileHash}</p>
            <p>Semantic Query String: ${request.inputFields.question}</p>
            <div style="max-height: 1000px; overflow-y: auto;">
              <pre>${coloredResult}</pre>
            </div>
          `;
        } else if (request.selectedInferenceType === "text_to_image") {
          combinedResults = `
          <img src="${request.inferenceResultsDecoded}" alt="Generated Image" style="max-width: 100%; max-height: 400px;">
          <p class="text-sm italic m-2">(Please note that this is a compressed version of the original generated image.)</p>
        `;
        }
        previewContainer.innerHTML = `
        <div class="mb-4">
          <h3 class="font-bold">Inference Result:</h3>
          ${combinedResults}
        </div>
        <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
        <div class="table-responsive">
          <table class="table">
            <tr>
              <th>
                ${request.selectedInferenceType ===
            "ask_question_about_an_image"
            ? "Question"
            : request.selectedInferenceType === "embedding_document"
              ? "Input Document Name"
              : request.selectedInferenceType === "text_to_image"
                ? "Image Generation Prompt"
                : "Input Prompt to LLM"
          }
              </th>
              <td>
                ${request.selectedInferenceType ===
            "ask_question_about_an_image"
            ? request.inputFields.question
            : request.selectedInferenceType === "embedding_document"
              ? request.inputFields.document_file_name
              : request.selectedInferenceType === "text_to_image"
                ? request.inputFields.imagePrompt
                : request.prompt
          }
              </td>
            </tr>
            <tr><th>Actual Cost (Credits)</th><td>${request.actualCreditsUsed
          }</td></tr>
            <tr><th>Remaining Credits</th><td>${request.remainingCredits
          }</td></tr>
            <tr><th>Request Timestamp</th><td>${request.requestTimestamp
          }</td></tr>
            <tr><th>Model</th><td>${request.selectedModelCanonicalName
          }</td></tr>
            <tr><th>Total Time in Seconds to Process Request</th><td>${request.elapsedTimeInSeconds
          }</td></tr>
          </table>
        </div>`;

        renderMarkdown();
      }

      function downloadZip(zipUrl) {
        const link = document.createElement("a");
        link.href = zipUrl;
        link.download = "inference_result.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Call updatePreviousRequestsList on page load
      document.addEventListener(
        "DOMContentLoaded",
        updatePreviousRequestsList
      );

      async function createNewInferenceRequest(
        selectedCreditPackTicketId,
        selectedInferenceType,
        selectedModelCanonicalName,
        maxCost,
        modelParametersJSONBase64Encoded,
        modelInputDataJSONBase64Encoded
      ) {
        const resultContainer = document.getElementById(
          "inferenceRequestResult"
        );
        resultContainer.innerHTML = "";
        const loader = document.createElement("div");
        loader.className = "btn is-loading";
        loader.innerText = "Loading...";
        resultContainer.appendChild(loader);

        displayInferenceRequestLoggerMessages = true;
        const startTime = new Date();

        try {
          logStatusMessage("Creating new inference request...");

          if (!modelInputDataJSONBase64Encoded) {
            throw new Error("Model input data is required and cannot be empty.");
          }

          const requestPayload = {
            model_inference_type_string: selectedInferenceType,
            model_parameters_json_b64: modelParametersJSONBase64Encoded,
            model_input_data_json_b64: modelInputDataJSONBase64Encoded, // Use the original, untruncated data
            selectedCreditPackTicketId,
            maxCost,
            model_canonical_name: selectedModelCanonicalName,
          };

          // Create a truncated version only for logging
          const truncatedPayload = { ...requestPayload };
          if (typeof truncatedPayload.model_input_data_json_b64 === 'string' && truncatedPayload.model_input_data_json_b64.length > 100) {
            truncatedPayload.model_input_data_json_b64 = truncatedPayload.model_input_data_json_b64.substring(0, 100) + '...';
          }

          console.log('Creating inference request with payload:', JSON.stringify(truncatedPayload, null, 2));

          const response = await axios.post("/create-inference-request", requestPayload);

          if (response.data.success) {
            logStatusMessage("Inference request created successfully.");
            const contentType = response.headers["content-type"];

            const inferenceResultDict =
              response.data.result.inferenceResultDict;

            let combinedResults = "";
            const modelInputDataJSON =
              inferenceResultDict.model_input_data_json;
            const {
              proposed_cost_of_request_in_inference_credits,
              remaining_credits_in_pack_after_request_processed,
            } = inferenceResultDict.usage_request_response;

            const endTime = new Date();
            const elapsedTimeInSeconds = Math.floor(
              (endTime - startTime) / 1000
            );
            let compressedImage;
            if (selectedInferenceType === "text_to_image") {
              const imageBinaryData =
                inferenceResultDict.generated_image_decoded.data;
              if (imageBinaryData) {
                // Convert the binary data to a Blob
                const outputFormat =
                  document
                    .getElementById("output_format")
                    .value.replace("jpeg", "jpg") || "jpg";
                const imageBlob = new Blob(
                  [new Uint8Array(imageBinaryData)],
                  {
                    type: `image/${outputFormat}`,
                  }
                );
                // Create an object URL for the image
                const imageUrl = URL.createObjectURL(imageBlob);
                // Generate the image name
                const imageName = modelInputDataJSON.imagePrompt
                  .replace(/[^\w]/g, "_")
                  .replace(/_+/g, "_")
                  .substring(0, 100);
                // Create the combined results HTML
                const imageSizeBytes = await fetchImageSize(imageUrl);
                const imageSizeMB = (imageSizeBytes / (1024 * 1024)).toFixed(
                  2
                );
                combinedResults = `
                  <div class="m-8">
                    <img id="generated-image" src="${imageUrl}" alt="Generated Image" class="max-w-full max-h-96 mx-auto mb-4">
                    <p class="text-center">
                      <a href="${imageUrl}" download="${imageName}.${outputFormat}" class="btn success outline m-4">Download Image</a>
                    </p>
                    <p class="text-center text-gray-500">File size: ${imageSizeMB} MB</p>
                  </div>
                `;
              } else {
                combinedResults = "Failed to generate image.";
              }
            } else if (selectedInferenceType === "embedding_audio") {
              const embeddingAudioFileInput =
                document.getElementById("embeddingAudioFile");
              const originalFileName = embeddingAudioFileInput.files[0].name;
              const inferenceResultDecoded =
                inferenceResultDict.inference_result_decoded;
              const formattedResult = prettyJSON(inferenceResultDecoded);
              const coloredResult = formattedResult
                .replace(/({|})/g, '<span style="color: #4CAF50;">$1</span>') // Light green for braces
                .replace(
                  /"([^"]+)"(?=:)/g,
                  '<span style="color: #2196F3;">$1</span>'
                ) // Pale blue for keys
                .replace(
                  /: ("[^"]+")/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ) // Pale yellow for string values
                .replace(
                  /: (\d+)/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ) // Pale yellow for numeric values
                .replace(
                  /: (true|false|null)/g,
                  ': <span style="color: #FFC107;">$1</span>'
                ); // Pale yellow for boolean and null values
              combinedResults = `
                <p>Original File Name: ${originalFileName}</p>
                <p>Semantic Query String: ${modelInputDataJSON.question}</p>
                <div style="max-height: 1000px; overflow-y: auto;">
                  <pre>${coloredResult}</pre>
                </div>
              `;
            } else if (
              selectedInferenceType === "ask_question_about_an_image"
            ) {
              const imageFile = document.getElementById("imageFile").files[0];
              const imageUrl = URL.createObjectURL(imageFile);
              combinedResults = `
                <img src="${imageUrl}" alt="Input Image" style="max-width: 100%; max-height: 400px;">
                <p>Question: ${modelInputDataJSON.question}</p>
                <p>Answer:</p>
                <github-md>${JSON.parse(inferenceResultDict.inference_result_decoded)[0]
                }</github-md> 
              `;
            } else if (selectedInferenceType === "text_completion") {
              const inferenceResultsDecoded = JSON.parse(
                inferenceResultDict.inference_result_decoded
              );
              if (Array.isArray(inferenceResultsDecoded)) {
                inferenceResultsDecoded.forEach((result, i) => {
                  let parsedResult = result;
                  try {
                    const sanitizedResult = sanitizeJSON(result);
                    const parsedJSON = JSON.parse(sanitizedResult);
                    if (parsedJSON.text) {
                      parsedResult = parsedJSON.text;
                    }
                  } catch (e) {
                    try {
                      parsedResult = fallbackParseResult(result);
                    } catch (e) {
                      parsedResult = result;
                    }
                  }
                  combinedResults += `<h4>Completion ${i + 1} of ${inferenceResultsDecoded.length
                    }</h4>`;
                  combinedResults += `<github-md>${parsedResult}</github-md>`;
                  if (i < inferenceResultsDecoded.length - 1) {
                    combinedResults += "<hr>";
                  }
                });
              } else {
                // It's not an array, just a single result; so wrap it in markdown tags
                combinedResults = `<github-md>${inferenceResultsDecoded}</github-md>`;
              }
            }

            resultContainer.innerHTML = `
            <div class="mb-4">
              <h3 class="font-bold">Inference Result:</h3>
              ${combinedResults}
            </div>
            <h3 class="font-bold mt-4">Misc. Inference Parameters and Statistics:</h3>
            <div class="table-responsive">
              <table class="table">
                <tr>
                  <th>${selectedInferenceType === "embedding_document"
                ? "Input Document File Name"
                : selectedInferenceType === "embedding_audio"
                  ? "Input Audio File Name"
                  : "Input Prompt to LLM"
              }</th>
                  <td>${selectedInferenceType === "embedding_document"
                ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                  .document_file_name
                : selectedInferenceType === "embedding_audio"
                  ? JSON.parse(atob(modelInputDataJSONBase64Encoded))
                    .audio_file_name
                  : modelInputDataJSON.prompt
              }</td>
                </tr>
                <tr><th>Actual Cost (Credits)</th><td>${proposed_cost_of_request_in_inference_credits}</td></tr>
                <tr><th>Remaining Credits</th><td>${remaining_credits_in_pack_after_request_processed}</td></tr>
                <tr><th>Request Timestamp</th><td>${new Date().toISOString()}</td></tr>
                <tr><th>Model</th><td>${selectedModelCanonicalName}</td></tr>
                <tr><th>Total Time in Seconds to Process Request</th><td>${elapsedTimeInSeconds}</td></tr>
              </table>
            </div>
            ${selectedInferenceType === "embedding_document"
                ? `<p class="text-center">
                    <a href="#" id="downloadZipButton" class="btn success outline m-4">
                      Download Zip File of JSON Document Embeddings${inferenceResultDict.semantic_query_result
                  ? " and Semantic Search Results"
                  : ""
                }
                    </a>
                  </p>`
                : ""
              }
          `;

            saveInferenceRequestToLocalStorage({
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              inputFields: JSON.parse(atob(modelInputDataJSONBase64Encoded)),
              parameterFields: JSON.parse(
                atob(modelParametersJSONBase64Encoded)
              ),
              maxCost,
              inferenceResultsDecoded:
                inferenceResultDict.inference_result_decoded,
              prompt: document.getElementById("prompt").value,
              elapsedTimeInSeconds,
              actualCreditsUsed:
                proposed_cost_of_request_in_inference_credits,
              remainingCredits:
                remaining_credits_in_pack_after_request_processed,
              respondingSupernode:
                inferenceResultDict.responding_supernode_pastelid,
              requestTimestamp: startTime.toISOString(),
            });

            if (selectedInferenceType === "embedding_document") {
              const embeddingDocumentFileInput = document.getElementById(
                "embeddingDocumentFile"
              );
              const originalFileName =
                embeddingDocumentFileInput.files[0].name;
              document
                .getElementById("downloadZipButton")
                .addEventListener("click", () => {
                  const processedFileName = originalFileName
                    .replace(/\.[^/.]+$/, "")
                    .replace(/[^\w]/g, "_")
                    .replace(/_+/g, "_")
                    .substring(0, 100);
                  // Convert the buffer data to a Uint8Array
                  const zipFileDataBuffer =
                    inferenceResultDict.zip_file_data.data;
                  const zipFileUint8Array = new Uint8Array(zipFileDataBuffer);
                  const zipBlob = new Blob([zipFileUint8Array], {
                    type: "application/zip",
                  });
                  const downloadLink = document.createElement("a");
                  downloadLink.href = URL.createObjectURL(zipBlob);
                  downloadLink.download = `${processedFileName}.zip`;
                  downloadLink.click();
                });
              // Update the table cell with the original file name
              resultContainer.querySelector("td").textContent =
                originalFileName;
            }
            renderMarkdown();
          } else {
            throw new Error("Failed to create inference request");
          }
        } catch (error) {
          console.error(
            `Error creating new inference request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
          );
          resultContainer.innerHTML =
            "Failed to create inference request. Please try again.";
          logStatusMessage("Failed to create inference request.");
        } finally {
          loader.remove();
          displayInferenceRequestLoggerMessages = false;
        }
      }

      async function decompressJsonFromZip(zipUrl) {
        const response = await fetch(zipUrl);
        const blob = await response.blob();
        const jsZip = new JSZip();
        const zip = await jsZip.loadAsync(blob);
        const fileNames = Object.keys(zip.files);
        const jsonFile = await zip.files[fileNames[0]].async("text");
        return jsonFile;
      }

      // Function to fetch and display received messages
      async function fetchReceivedMessages() {
        try {
          const userPastelID =
            document.getElementById("pastelIDDropdown").value;

          const response = await axios.get("/get-best-supernode-url", {
            params: { userPastelID },
          });
          const supernodeURL = response.data.supernodeURL;
          const closestSupernodeIP = supernodeURL.match(
            /(?:https?:\/\/)?([^:/]+)/i
          )[1];

          const messagesResponse = await axios.get("/get-received-messages", {
            timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
          });
          const messageDict = messagesResponse.data.messageDict;

          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML = ""; // Clear previous messages

          for (const pastelId in messageDict) {
            const messages = messageDict[pastelId];
            messages.forEach((message) => {
              const messageElement = document.createElement("div");
              messageElement.classList.add(
                "mb-4",
                "border",
                "border-gray-300",
                "rounded-lg",
                "p-4"
              );

              const fromPastelIDElement = document.createElement("p");
              fromPastelIDElement.classList.add(
                "text-sm",
                "font-medium",
                "text-gray-600",
                "mb-2"
              );
              fromPastelIDElement.textContent = `From: ${pastelId}`;

              const messageBodyElement = document.createElement("p");
              messageBodyElement.classList.add(
                "text-base",
                "text-gray-800",
                "mb-2"
              );
              messageBodyElement.textContent = message.message_body;

              const timestampElement = document.createElement("p");
              timestampElement.classList.add("text-xs", "text-gray-500");
              timestampElement.textContent = new Date(
                message.timestamp
              ).toLocaleString();

              messageElement.appendChild(fromPastelIDElement);
              messageElement.appendChild(messageBodyElement);
              messageElement.appendChild(timestampElement);

              receivedMessagesContainer.appendChild(messageElement);
            });
          }
        } catch (error) {
          console.log("Error retrieving received messages:", error);
          const receivedMessagesContainer =
            document.getElementById("receivedMessages");
          receivedMessagesContainer.innerHTML =
            "Failed to retrieve received messages. Please try again later.";
        }
      }

      // Handle create PastelID button click
      document
        .getElementById("createPastelIDButton")
        .addEventListener("click", async () => {
          try {
            await axios.post("/check-for-pastel-id", { autoRegister: true });
            location.reload(); // Refresh the page to update the UI
          } catch (error) {
            console.error("Error creating PastelID:", error);
          }
        });

      // Handle import private key form submission
      document
        .getElementById("importPrivKeyButton")
        .addEventListener("click", async () => {
          const privKey = document.getElementById("importPrivKey").value;
          if (!privKey) {
            alert("Please enter private key!");
            return;
          }
          showLoading("importPrivKeyLoading");
          try {
            await axios.post("/import-priv-key", { zcashPrivKey: privKey });
            alert("Private key imported successfully!");
          } catch (error) {
            console.error("Error importing private key:", error);
          }
          hideLoading("importPrivKeyLoading");
        });

      // Handle import wallet form submission
      document
        .getElementById("importWalletButton")
        .addEventListener("click", async () => {
          const walletFile = document.getElementById("importWallet").files[0];
          if (!walletFile) {
            alert("Please select a Wallet file to import.");
            return;
          }
          showLoading("importWalletLoading");
          const formData = new FormData();
          formData.append("walletFile", walletFile);
          try {
            await axios.post("/import-wallet", formData);
            alert("Wallet imported successfully!");
          } catch (error) {
            console.error("Error importing wallet:", error);
          }
          hideLoading("importWalletLoading");
        });

      // Handle list address amounts button click
      document
        .getElementById("listAddressAmountsButton")
        .addEventListener("click", async () => {
          showLoading("listAddressAmountsLoading");
          try {
            const response = await axios.get("/list-address-amounts");
            const addressAmounts = response.data.result;
            console.log("Address amounts:", addressAmounts);

            // Populate the table
            const addressAmountsTable = document.getElementById(
              "addressAmountsTable"
            );
            addressAmountsTable.innerHTML =
              "<thead><tr><th>Address</th><th>Amount</th></tr></thead><tbody></tbody>";
            const tbody = addressAmountsTable.querySelector("tbody");
            for (const [address, amount] of Object.entries(addressAmounts)) {
              const row = document.createElement("tr");
              row.innerHTML = `<td>${address}</td><td>${parseAndFormatNumber(
                amount.toString()
              )}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const addressAmountsContainer = document.getElementById(
              "addressAmountsContainer"
            );
            addressAmountsContainer.style.display = "block";
            document.getElementById(
              "copyAddressAmountsButton"
            ).style.display = "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyAddressAmountsButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(addressAmounts)
                  .map(
                    ([address, amount]) =>
                      `${address},${amount.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Address amounts copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving address amounts:", error);
          }
          hideLoading("listAddressAmountsLoading");
        });
      // Handle get wallet info button click
      document
        .getElementById("getWalletInfoButton")
        .addEventListener("click", async () => {
          showLoading("getWalletInfoLoading");
          try {
            const response = await axios.get("/get-wallet-info");
            const walletInfo = response.data.result;
            console.log("Wallet info:", walletInfo);

            // Populate the table
            const walletInfoTable =
              document.getElementById("walletInfoTable");
            walletInfoTable.innerHTML =
              "<thead><tr><th>Key</th><th>Value</th></thead><tbody></tbody>";
            const tbody = walletInfoTable.querySelector("tbody");
            const balanceFields = [
              "balance",
              "unconfirmed_balance",
              "immature_balance",
            ]; // Add the balance fields you want to format

            for (const [key, value] of Object.entries(walletInfo)) {
              const formattedValue = balanceFields.includes(key)
                ? parseAndFormatNumber(value.toString())
                : value;
              const row = document.createElement("tr");
              row.innerHTML = `<td>${key}</td><td>${formattedValue}</td>`;
              tbody.appendChild(row);
            }

            // Show the container and the copy button
            const walletInfoContainer = document.getElementById(
              "walletInfoContainer"
            );
            walletInfoContainer.style.display = "block";
            document.getElementById("copyWalletInfoButton").style.display =
              "inline-block";

            // Add clipboard functionality
            document
              .getElementById("copyWalletInfoButton")
              .addEventListener("click", () => {
                const csvData = Object.entries(walletInfo)
                  .map(
                    ([key, value]) =>
                      `${key},${value.toString().replace(/,/g, "")}`
                  )
                  .join("\n");
                navigator.clipboard.writeText(csvData);
                alert("Wallet info copied to clipboard as CSV!");
              });
          } catch (error) {
            console.error("Error retrieving wallet info:", error);
          }
          hideLoading("getWalletInfoLoading");
        });

      document
        .getElementById("clearLocalStorageButton")
        .addEventListener("click", () => {
          if (
            confirm(
              "Are you sure you want to clear all local storage data for this page?"
            )
          ) {
            localStorage.clear();
            alert("Local storage cleared. The page will now reload.");
            location.reload();
          }
        });

      // Create a terminal and load the fit addon
      const term = new Terminal({ cols: 175, rows: 24 });
      term.open(document.getElementById("terminal"));
      term.terminalOptions = {
        fontSize: 6,
        enableBold: true,
        cols: 175,
        rows: 24,
      };

      function resizeTerminal() {
        const terminalElement = document.getElementById("terminal");
        const cols = Math.floor(terminalElement.clientWidth / 10); // Approximate character width
        const rows = Math.floor(terminalElement.clientHeight / 20); // Approximate character height

        console.log(
          `Cols: ${cols}, Rows: ${rows}, Type of Cols: ${typeof cols}, Type of Rows: ${typeof rows}`
        );

        if (cols > 0 && rows > 0) {
          term.resize(cols, rows);
        }
      }

      resizeTerminal();
      window.addEventListener("resize", resizeTerminal);

      function displayStatusMessage(message) {
        const currentStatus = document.getElementById("currentStatus");
        currentStatus.textContent = message;
      }

      function cleanAndFormatMessage(message) {
        if (typeof message === "object") {
          // If the message is a JSON object, stringify and format it
          return JSON.stringify(message, null, 2);
        } else if (typeof message === "string") {
          // Remove excess whitespace from strings
          return message.replace(/\s+/g, " ").trim();
        }
        return message;
      }

      function logMessageToTerminal(term, logMessage) {
        const message =
          typeof logMessage.message === "string" ? logMessage.message : "";
        const cleanMessage = cleanAndFormatMessage(message);
        if (typeof cleanMessage !== "string") {
          console.error("cleanMessage is not a string:", cleanMessage);
          return;
        }
        const parts = cleanMessage.split(/(\{[\s\S]*?\})/);
        const formattedParts = parts
          .map((part) => {
            if (part.startsWith("{") && part.endsWith("}")) {
              let parsed;
              try {
                parsed = JSON.parse(part);
              } catch (e) {
                try {
                  // Fix common JSON issues
                  let fixedPart = part
                    .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":') // Ensure keys are quoted
                    .replace(/:\s*(['"])?([^\n\r\t,}\]]+)(['"])?/g, ': "$2"') // Ensure values are quoted
                    .replace(/,\s*([\]}])/g, "$1") // Remove trailing commas
                    .replace(/\\n/g, "\\n") // Handle newlines
                    .replace(/\\r/g, "\\r") // Handle carriage returns
                    .replace(/\\t/g, "\\t") // Handle tabs
                    .replace(/[\u0000-\u001F\u007F-\u009F]/g, ""); // Remove control characters

                  // Fix for unterminated strings
                  const quotesBalanced =
                    fixedPart.split('"').length % 2 === 1;
                  if (quotesBalanced) {
                    fixedPart = fixedPart + '"';
                  }

                  parsed = JSON.parse(fixedPart);
                } catch (innerE) {
                  // Silently fail
                  return part;
                }
              }
              const formatted = prettyJSON(parsed);
              return formatted
                .replace(/({|})/g, "\x1b[1;32m$1\x1b[0m") // Light green for braces
                .replace(/"([^"]+)"(?=:)/g, '\x1b[1;34m"$1"\x1b[0m') // Pale blue for keys
                .replace(/: ("[^"]+")/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for string values
                .replace(/: (\d+)/g, ": \x1b[1;33m$1\x1b[0m") // Pale yellow for numeric values
                .replace(/: (true|false|null)/g, ": \x1b[1;33m$1\x1b[0m"); // Pale yellow for boolean and null values
            }
            return part;
          })
          .join("");
        const timestamp = logMessage.timestamp
          ? new Date(logMessage.timestamp).toISOString()
          : "Invalid timestamp";
        const logLevel = logMessage.level || "Unknown level";
        const messageLines =
          `[${timestamp}] [${logLevel}] ${formattedParts}`.split("\n");
        messageLines.forEach((line) => term.writeln(line));
      }

      fetch("/ws-url")
        .then((response) => response.json())
        .then((data) => {
          const socket = new WebSocket(data.wsUrl);

          socket.onopen = () => {
            console.log("WebSocket connection established");
          };

          socket.onmessage = (event) => {
            if (event.data) {
              const logMessage = JSON.parse(event.data);
              logMessageToTerminal(term, logMessage);

              if (displayInferenceRequestLoggerMessages) {
                logStatusMessage(logMessage.message);
              }

              if (displayCreateTicketLoggerMessages) {
                const statusContainer = document.getElementById(
                  "createTicketStatusContainer"
                );
                const statusContent =
                  document.getElementById("createTicketStatus");
                if (logMessage.message) {
                  logCreateTicketStatusMessage(
                    logMessage.message,
                    statusContent
                  );
                }
              }
            }
          };

          socket.onclose = () => {
            console.log("WebSocket connection closed");
          };

          socket.onerror = (error) => {
            console.error("WebSocket error:", error);
          };
        })
        .catch((error) => {
          console.error("Error fetching WebSocket URL:", error);
        });

      function toggleTerminal() {
        const terminal = document.getElementById("terminal");
        if (terminal.style.display === "none") {
          terminal.style.display = "block";
        } else {
          terminal.style.display = "none";
        }
        resizeTerminal();
      }

      tailwind.config = {
        theme: {
          extend: {},
        },
      };

      var storedTheme =
        localStorage.getItem("theme") ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light");
      if (storedTheme)
        document.documentElement.setAttribute("data-theme", storedTheme);

      function toggleDarkMode() {
        var currentTheme =
          document.documentElement.getAttribute("data-theme");
        var targetTheme = currentTheme === "light" ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", targetTheme);
        localStorage.setItem("theme", targetTheme);
        document
          .querySelector("#theme-toggle")
          .setAttribute("data-content", targetTheme === "dark" ? "🌙" : "☀");
      }

      // Set the initial state of the switch toggle
      const toggle = document.querySelector("#theme-toggle");
      if (storedTheme === "dark") {
        toggle.checked = true;
        toggle.setAttribute("data-content", "🌙");
      } else {
        toggle.checked = false;
        toggle.setAttribute("data-content", "☀");
      }

      // Format the values and display them using template literals
      function formatAndDisplay(inputElement) {
        const value = inputElement.value.replace(/,/g, "");
        const number = parseFloat(value);
        if (!isNaN(number)) {
          inputElement.setAttribute("data-raw-value", number);
          inputElement.value = number.toLocaleString();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const createTicketForm = document.getElementById("createTicketForm");
        createTicketForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const numCredits = parseInt(
            document.querySelector("#numCredits").value.replace(/,/g, "")
          );
          const maxTotalPrice = parseFloat(
            document.querySelector("#maxTotalPrice").value.replace(/,/g, "")
          );
          const maxPerCreditPrice = parseFloat(
            document
              .querySelector("#maxPerCreditPrice")
              .value.replace(/,/g, "")
          );

          const statusContainer = document.getElementById(
            "createTicketStatusContainer"
          );
          const statusContent = document.getElementById("createTicketStatus");
          statusContent.innerHTML = ""; // Clear previous logs

          logCreateTicketStatusMessage(
            "Initializing ticket creation...",
            statusContent
          );
          try {
            await createNewCreditPackTicket(
              numCredits,
              maxTotalPrice,
              maxPerCreditPrice
            );
          } catch (error) {
            console.error(
              "Error creating credit pack ticket:",
              error.message
            );
            logCreateTicketStatusMessage(
              `Failed to create credit pack ticket: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`,
              statusContent
            );
          }
        });

        // Add event listener to format and update raw values on input change
        const inputs = document.querySelectorAll(
          "#numCredits, #maxTotalPrice, #maxPerCreditPrice"
        );
        inputs.forEach((input) => {
          input.addEventListener("input", handleInputChange);
          input.addEventListener("blur", handleInputBlur);
        });

        document
          .getElementById("inferenceRequestForm")
          .addEventListener("submit", async (event) => {
            event.preventDefault();
            saveInferenceRequestSettings();

            const selectedCreditPackTicket = document.querySelector(
              'input[name="creditPackTicket"]:checked'
            );
            if (!selectedCreditPackTicket) {
              alert("Please select a credit pack ticket.");
              return;
            }
            const selectedRow = selectedCreditPackTicket.closest("tr");
            const selectedCreditPackTicketId = selectedRow
              .querySelector("td:last-child a")
              .textContent.trim();

            const selectedInferenceType =
              document.getElementById("inferenceType").value;
            const selectedModelCanonicalName =
              document.getElementById("model").value;
            const maxCost = parseFloat(
              document.querySelector("#maxCost").dataset.rawValue
            );
            const encodeToBase64 = (str) => {
              return btoa(unescape(encodeURIComponent(str)));
            };

            const encodeFileToBase64 = (file) => {
              return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(",")[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
            };

            const formData = new FormData(event.target);
            const modelParameters = {};
            formData.forEach((value, key) => {
              if (
                key !== "prompt" &&
                key !== "imagePrompt" &&
                key !== "embeddingDocumentFile" &&
                key !== "embeddingAudioFile"
              ) {
                modelParameters[key] = value;
              }
            });

            const modelParametersJSON = JSON.stringify(modelParameters);
            const modelParametersJSONBase64Encoded =
              encodeToBase64(modelParametersJSON);

            let inputPromptKey;
            if (selectedInferenceType === "text_completion") {
              inputPromptKey = "prompt";
            } else if (selectedInferenceType === "text_to_image") {
              inputPromptKey = "imagePrompt";
            } else if (selectedInferenceType === "embedding_document") {
              inputPromptKey = "embeddingDocumentFile";
            } else if (selectedInferenceType === "embedding_audio") {
              inputPromptKey = "embeddingAudioFile";
            } else {
              inputPromptKey = "prompt";
            }

            let modelInputDataBase64Encoded;
            if (selectedInferenceType === "ask_question_about_an_image") {
              const imageFile = document.getElementById("imageFile").files[0];
              const question = document.getElementById("question").value;
              if (!imageFile || !question) {
                alert("Please select an image and enter a question.");
                return;
              }
              const imageBase64 = await encodeFileToBase64(imageFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  image: imageBase64,
                  question: question,
                })
              );
            } else if (selectedInferenceType === "embedding_document") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "document_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Document file data cannot be empty.");
                return;
              }
              const documentBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  document: documentBase64,
                  question: semantic_query_string,
                })
              );
            } else if (selectedInferenceType === "embedding_audio") {
              const inputFile =
                document.getElementById(inputPromptKey).files[0];
              const semantic_query_string = document.getElementById(
                "audio_semantic_query_string"
              ).value;
              if (!inputFile) {
                alert("Audio file data cannot be empty.");
                return;
              }
              const audioBase64 = await encodeFileToBase64(inputFile);
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({
                  audio: audioBase64,
                  question: semantic_query_string,
                })
              );
            } else {
              const inputPromptValue =
                document.getElementById(inputPromptKey).value;
              modelInputDataBase64Encoded = encodeToBase64(
                JSON.stringify({ [inputPromptKey]: inputPromptValue })
              );
            }
            if (!maxCost) {
              alert("Maximum Cost (Credits) cannot be empty.");
              return;
            }
            await createNewInferenceRequest(
              selectedCreditPackTicketId,
              selectedInferenceType,
              selectedModelCanonicalName,
              maxCost,
              modelParametersJSONBase64Encoded,
              modelInputDataBase64Encoded
            );

            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(STORAGE_TIMESTAMP_KEY);

            // Refresh the credit pack tickets to reflect the updated balance
            await getMyValidCreditPacks(true);
          });

        // Attach debounced input and blur event listeners to all relevant input elements
        const inferenceRequestForm = document.getElementById(
          "inferenceRequestForm"
        );
        const inputElements = inferenceRequestForm.querySelectorAll(
          "input, textarea, select"
        );

        inputElements.forEach((inputElement) => {
          inputElement.addEventListener(
            "input",
            debounce(handleInputChange, 300)
          );
          inputElement.addEventListener("blur", handleInputBlur);
        });

        const maxCostInput = document.getElementById("maxCost");
        const maxCostFormattedSpan =
          document.getElementById("maxCostFormatted");
        maxCostInput.addEventListener(
          "input",
          debounce(
            () => formatAndDisplay(maxCostInput, maxCostFormattedSpan),
            300
          )
        );
      });

      document
        .getElementById("exportTerminalButton")
        .addEventListener("click", () => {
          let termText = "";
          for (let i = 0; i < term.buffer.active.length; i++) {
            const line = term.buffer.active.getLine(i);
            if (line) {
              termText += line.translateToString(false) + "\n";
            }
          }
          const blob = new Blob([termText], { type: "text/plain" });
          const link = document.createElement("a");
          const currentDate = new Date().toISOString();
          const fileName = `Pastel_Inference_Client_Terminal_Session_Log__${currentDate}.txt`;
          link.href = URL.createObjectURL(blob);
          link.download = fileName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
        handleCreditPackSelection();
        document.getElementById("inferenceType").value = "text_completion"; // Set default to Text Completion
        document
          .getElementById("inferenceType")
          .dispatchEvent(new Event("change")); // Trigger change event

        // Automatically refresh the table of existing credit packs on initial page load
        getMyValidCreditPacks(true).catch((error) => {
          console.error("Error refreshing credit pack tickets:", error);
        });
      });

      // This function ensures that the tracking addresses have a minimum balance of 1 PSL; only runs every 10 minutes to give time for a new block to be mined including the transactions
      document.addEventListener("DOMContentLoaded", function () {
        const refreshButton = document.getElementById("refreshButton");
        let lastRunTime = 0;
        const runInterval = 10 * 60 * 1000; // 10 minutes in milliseconds

        async function ensureMinimalPSLBalance() {
          const currentTime = new Date().getTime();
          if (currentTime - lastRunTime < runInterval) {
            console.log(
              "Skipping balance check: Less than 10 minutes since last run."
            );
            return; // Skip execution if not enough time has passed
          }

          try {
            // Wait for the table to load with a timeout
            await waitForTableLoad();

            // Once the table is confirmed to be loaded, proceed to gather addresses
            const table = document.getElementById(
              "creditPackTicketTableBody"
            );
            const trackingAddresses = Array.from(
              table.querySelectorAll("tr")
            ).map((row) => {
              return row.cells[3].textContent.trim(); // Assuming the tracking address is in the 4th column
            });

            const uniqueAddresses = [...new Set(trackingAddresses)];

            const response = await axios.post("/ensure-minimal-psl-balance", {
              addresses: uniqueAddresses,
            });

            if (response.data && response.data.success) {
              console.log("Balance check and update initiated successfully.");
              lastRunTime = currentTime; // Update last run time on successful execution
            } else {
              console.error("Failed to initiate balance check and update.");
            }
          } catch (error) {
            console.error("Error ensuring minimal PSL balance:", error);
          }
        }

        async function waitForTableLoad(maxWaitTime = 25000, interval = 500) {
          const startTime = new Date().getTime();

          function checkCondition() {
            const table = document.getElementById(
              "creditPackTicketTableBody"
            );
            return table && table.querySelectorAll("tr").length > 0; // Check if the table has at least one row
          }

          return new Promise((resolve, reject) => {
            (function waitForCondition() {
              if (checkCondition()) {
                resolve(true);
              } else if (new Date().getTime() - startTime < maxWaitTime) {
                setTimeout(waitForCondition, interval);
              } else {
                reject(new Error("Timeout waiting for the table to load."));
              }
            })();
          });
        }

        // Event listener for manual refresh
        refreshButton.addEventListener("click", ensureMinimalPSLBalance);

        // Automatically trigger the balance check on initial page load
        ensureMinimalPSLBalance().catch((error) =>
          console.error("Error on initial load:", error)
        );
      });
    </script>
    <script src="https://cdn.jsdelivr.net/gh/MarketingPipeline/Markdown-Tag/markdown-tag.js"></script>
  </div>
</body>

</html>

---
./initial_inference_js_client_setup_script.sh
---
#!/bin/bash

# Determine the user shell
user_shell=$(echo $SHELL)
echo "Detected user shell: $user_shell"

# Set shell path and profile file based on user shell
if [[ $user_shell == *"/zsh"* ]]; then
  profile_file=".zshrc"
else
  profile_file=".bashrc"
fi
echo "Using profile file: ~/$profile_file"

# Update code block with appropriate shell execution
if [ -d ~/pastel_inference_js_client ]; then
  echo "Directory exists. Stashing and pulling latest code..."
  cd ~/pastel_inference_js_client
  git stash
  git pull
else
  echo "Directory does not exist. Cloning repository..."
  git clone https://github.com/pastelnetwork/pastel_inference_js_client.git ~/pastel_inference_js_client
  cd ~/pastel_inference_js_client
fi

# Check if NVM is already installed; if not install it and configure it to use the latest version as the default
if [ ! -d "$HOME/.nvm" ]; then
  echo "Installing NVM..."
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
fi

nvm install --latest-npm
nvm use node
nvm alias default node

npm install

---
./logger.js
---
const winston = require("winston");
const Sequelize = require("sequelize");
const EventEmitter = require("events");

function safeStringify(obj, space = 2) {
  const seen = new WeakSet();

  const replacer = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);

      if (value instanceof Sequelize.Model) {
        return value.get({ plain: true });
      }
      if (value.isJoi) {
        return `Joi Schema for ${value.type}`;
      }
      if (value instanceof Map) {
        return Array.from(value.entries());
      }
      if (value instanceof Set) {
        return Array.from(value);
      }
      if (value instanceof Date) {
        return value.toISOString();
      }
      if (value instanceof Error) {
        const errorDetails = {};
        Object.getOwnPropertyNames(value).forEach((prop) => {
          errorDetails[prop] = value[prop];
        });
        return errorDetails;
      }
      if (value.constructor === Object) {
        const sortedObj = {};
        Object.keys(value)
          .sort()
          .forEach((key) => {
            sortedObj[key] = value[key];
          });
        return sortedObj;
      }
    } else if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };

  return JSON.stringify(obj, replacer, space);
}

const customFormatter = winston.format((info) => {
  const formattedInfo = { ...info };

  Object.keys(formattedInfo).forEach((key) => {
    if (formattedInfo[key] instanceof Date) {
      formattedInfo[key] = formattedInfo[key].toISOString();
    }
  });

  return formattedInfo;
});
let transports = [
  new winston.transports.File({ filename: "error.log", level: "error" }),
  new winston.transports.File({ filename: "combined.log" }),
];
if (process.env.USE_WINSTON_TRANSPORTS_CONSOLE === '1') {
  transports.push(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  )
}
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    customFormatter(),
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports,
});

const logEmitter = new EventEmitter();
const logBuffer = [];
const MAX_LOG_ENTRIES = 100;

logger.on("data", (logEntry) => {
  const logEntryString = safeStringify(logEntry);
  logBuffer.push(logEntryString);
  if (logBuffer.length > MAX_LOG_ENTRIES) {
    logBuffer.shift();
  }
  logEmitter.emit("newLog", logEntryString);
});

// Intercept logs and emit events
const originalLog = logger.log.bind(logger);
logger.log = (level, msg, meta) => {
  originalLog(level, msg, meta);
  const logEntry = { level, msg, meta, timestamp: new Date().toISOString() };
  logEmitter.emit("newLog", safeStringify(logEntry));
};

module.exports = { logger, logEmitter, logBuffer, safeStringify };


---
./package.json
---
{
  "name": "pastel-inference-js-client",
  "version": "1.0.0",
  "description": "A JavaScript client for interacting with the Pastel Network and performing inference tasks.",
  "main": "server.js",
  "scripts": {
    "start": "node update.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "lint": "eslint .",
    "format": "prettier --write ."
  },
  "keywords": [
    "pastel",
    "inference",
    "blockchain",
    "messaging",
    "credit-pack",
    "llm"
  ],
  "author": "Jeff Emanuel <jeff@pastel.network>",
  "license": "MIT",
  "dependencies": {
    "@xterm/xterm": "^5.5.0",
    "axios": "^1.7.7",
    "body-parser": "^1.20.2",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.13.3",
    "multer": "^1.4.5-lts.1",
    "node-persist": "^4.0.3",
    "p-limit": "^6.1.0",
    "ping": "^0.4.4",
    "sequelize": "^6.37.3",
    "sqlite3": "^5.1.7",
    "winston": "^3.14.2",
    "ws": "^8.18.0",
    "zstd-codec": "^0.1.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^8.10.0",
    "globals": "^15.9.0",
    "jest": "^28.1.3",
    "nodemon": "^3.1.4",
    "prettier": "^2.8.8"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pastelnetwork/pastel_inference_js_client.git"
  },
  "bugs": {
    "url": "https://github.com/pastelnetwork/pastel_inference_js_client/issues"
  },
  "homepage": "https://github.com/pastelnetwork/pastel_inference_js_client#readme"
}


---
./pastel_inference_client.js
---
require("dotenv").config();
const axios = require("axios");
const {
  signMessageWithPastelID,
  checkSupernodeList,
  getCurrentPastelBlockHeight,
} = require("./rpc_functions");
const {
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestPreliminaryPriceQuote,
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  CreditPackPurchaseRequestStatus,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  InferenceAPIUsageRequest,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmation,
} = require("./sequelize_data_models");
const {
  userMessageSchema,
  creditPackPurchaseRequestSchema,
  creditPackPurchaseRequestRejectionSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema,
  creditPackPurchaseRequestResponseTerminationSchema,
  creditPackPurchaseRequestResponseSchema,
  creditPackPurchaseRequestConfirmationSchema,
  creditPackPurchaseRequestConfirmationResponseSchema,
  creditPackRequestStatusCheckSchema,
  creditPackPurchaseRequestStatusSchema,
  creditPackStorageRetryRequestSchema,
  creditPackStorageRetryRequestResponseSchema,
  inferenceAPIUsageRequestSchema,
  inferenceAPIUsageResponseSchema,
  inferenceAPIOutputResultSchema,
  inferenceConfirmationSchema,
} = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const {
  filterSupernodes,
  getNClosestSupernodesToPastelIDURLs,
  computeSHA3256HashOfSQLModelResponseFields,
  prepareModelForEndpoint,
  prepareModelForValidation,
  removeSequelizeFields,
  pythonCompatibleStringify,
  estimatedMarketPriceOfInferenceCreditsInPSLTerms,
  logActionWithPayload,
  transformCreditPackPurchaseRequestResponse,
} = require("./utility_functions");
const globals = require("./globals");


const MESSAGING_TIMEOUT_IN_SECONDS = process.env.MESSAGING_TIMEOUT_IN_SECONDS;

function getIsoStringWithMicroseconds() {
  // Get the current time
  const now = new Date();
  // Convert the date to an ISO string and replace 'Z' with '+00:00' to match Python's format
  // Ensure to remove any unwanted spaces directly in this step if they were somehow introduced
  const isoString = now.toISOString().replace("Z", "+00:00").replace(/\s/g, "");
  // Return the correctly formatted ISO string without any spaces
  return isoString;
}

class PastelInferenceClient {
  constructor(pastelID, passphrase) {
    this.pastelID = pastelID;
    this.passphrase = passphrase;
  }

  async requestAndSignChallenge(supernodeURL) {
    try {
      const response = await axios.get(
        `${supernodeURL}/request_challenge/${this.pastelID}`,
        {
          timeout: 12000,
        }
      );
      const { challenge, challenge_id } = response.data;
      const challenge_signature = await signMessageWithPastelID(
        this.pastelID,
        challenge,
        this.passphrase
      );
      return {
        challenge,
        challenge_id,
        challenge_signature,
      };
    } catch (error) {
      logger.error(
        `Error requesting and signing challenge: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async sendUserMessage(supernodeURL, userMessage) {
    try {
      const { error } = userMessageSchema.validate(userMessage);
      if (error) {
        throw new Error(`Invalid user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = userMessage.toJSON();
      const response = await axios.post(
        `${supernodeURL}/send_user_message`,
        {
          user_message: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      const result = response.data;
      const { resultError, value: validatedResult } =
        await userMessageSchema.validate(result);
      if (error) {
        throw new Error(`Invalid user message: ${resultError.message}`);
      }
      const userMessageInstance = await UserMessage.create(validatedResult);
      return userMessageInstance;
    } catch (error) {
      logger.error(`Error sending user message: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getUserMessages(supernodeURL) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = {
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      const response = await axios.get(`${supernodeURL}/get_user_messages`, {
        params,
        timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
      });
      const result = response.data;
      const validatedResults = await Promise.all(
        result.map((messageData) => userMessageSchema.validate(messageData))
      );
      const userMessageInstances = await UserMessage.bulkCreate(
        validatedResults
      );
      return userMessageInstances;
    } catch (error) {
      logger.error(`Error retrieving user messages: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getModelMenu() {
    const minimumNumberOfResponses = 5; // Minimum number of valid responses needed
    const retryLimit = 1; // Number of retries per supernode
    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const closestSupernodes = await getNClosestSupernodesToPastelIDURLs(
        60,
        this.pastelID,
        validMasternodeListFullDF
      );
      let validResponses = [];

      // Custom promise to collect a specified minimum number of valid responses
      await new Promise((resolve, reject) => {
        let completedRequests = 0;
        closestSupernodes.forEach(({ url }) => {
          this.retryPromise(() => this.getModelMenuFromSupernode(url), retryLimit)
            .then(response => {
              logger.info(`Successful model menu response received from supernode at ${url}`);
              validResponses.push({ response, url });
              // Resolve promise when minimum number of valid responses are collected
              if (validResponses.length >= minimumNumberOfResponses) {
                resolve();
              }
            })
            .catch(error => {
              logger.error(`Error querying supernode at ${url}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
              completedRequests++;
              // Check if it's still possible to get the minimum number of valid responses
              if (completedRequests > closestSupernodes.length - minimumNumberOfResponses + validResponses.length) {
                reject(new Error("Insufficient valid responses received from supernodes"));
              }
            });
        });
      });

      // Determine the largest/longest response
      const largestResponse = validResponses.reduce((prev, current) => {
        return JSON.stringify(current.response).length > JSON.stringify(prev.response).length ? current : prev;
      }).response;

      return largestResponse;
    } catch (error) {
      logger.error(`Error in getModelMenu: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }

  async getModelMenuFromSupernode(supernodeURL) {
    try {
      const response = await axios.get(
        `${supernodeURL}/get_inference_model_menu`,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      return response.data;
    } catch (error) {
      // Silently catch the error and return undefined, null, or a default value.
      return null;  // You can return null, undefined, or an empty object depending on your use case.
    }
  }

  async retryPromise(promiseFunc, limit, count = 0) {
    try {
      return await promiseFunc();
    } catch (error) {
      if (count < limit) {
        return this.retryPromise(promiseFunc, limit, count + 1);
      } else {
        throw error;
      }
    }
  }

  async getValidCreditPackTicketsForPastelID(supernodeURL) {
    const useVerbose = false;
    try {
      if (!this.pastelID) {
        return [];
      }
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      if (useVerbose) {
        logActionWithPayload(
          "retrieving",
          "valid credit pack tickets for PastelID",
          payload
        );
      }
      const response = await axios.post(
        `${supernodeURL}/get_valid_credit_pack_tickets_for_pastelid`,
        payload,
        {
          timeout: 6000,
        }
      );
      if (response.status !== 200) {
        if (useVerbose) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return [];
      }
      const validCreditPackTickets = response.data;
      if (useVerbose && validCreditPackTickets.length) {
        logger.info(
          `Received ${validCreditPackTickets.length} valid credit pack tickets for PastelID ${this.pastelID}`
        );
      }

      // Process the new format of returned results
      const processedTickets = validCreditPackTickets.map(ticket => ({
        credit_pack_registration_txid: ticket.credit_pack_registration_txid,
        credit_purchase_request_confirmation_pastel_block_height: ticket.credit_purchase_request_confirmation_pastel_block_height,
        requesting_end_user_pastelid: ticket.requesting_end_user_pastelid,
        ticket_input_data_fully_parsed_sha3_256_hash: ticket.ticket_input_data_fully_parsed_sha3_256_hash,
        txid_of_credit_purchase_burn_transaction: ticket.txid_of_credit_purchase_burn_transaction,
        credit_usage_tracking_psl_address: ticket.credit_usage_tracking_psl_address,
        psl_cost_per_credit: ticket.psl_cost_per_credit,
        requested_initial_credits_in_credit_pack: ticket.requested_initial_credits_in_credit_pack,
        credit_pack_current_credit_balance: ticket.credit_pack_current_credit_balance,
        balance_as_of_datetime: ticket.balance_as_of_datetime,
        number_of_confirmation_transactions: ticket.number_of_confirmation_transactions
      }));

      return processedTickets;
    } catch (error) {
      if (useVerbose) {
        logger.error(
          `Error retrieving valid credit pack tickets for PastelID: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      if (useVerbose) {
        throw error;
      }
      return [];
    }
  }


  async checkCreditPackBalance(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        credit_pack_ticket_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload("checking", "credit pack balance", payload);

      const response = await axios.post(
        `${supernodeURL}/check_credit_pack_balance`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const balanceInfo = response.data;
      logger.info(
        `Received credit pack balance info for txid ${txid}: ${JSON.stringify(
          balanceInfo
        )}`
      );
      return balanceInfo;
    } catch (error) {
      logger.error(
        `Error checking credit pack balance for txid ${txid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async getCreditPackTicketFromTxid(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = {
        txid,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "credit pack ticket from txid",
        params
      );

      const response = await axios.get(
        `${supernodeURL}/get_credit_pack_ticket_from_txid`,
        {
          params,
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const {
        credit_pack_purchase_request_response,
        credit_pack_purchase_request_confirmation,
      } = response.data;

      logActionWithPayload("received", "credit pack ticket from Supernode", {
        credit_pack_purchase_request_response,
        credit_pack_purchase_request_confirmation,
      });

      const { errorRequestResponse, value: validatedRequestResponse } =
        creditPackPurchaseRequestResponseSchema.validate(
          credit_pack_purchase_request_response
        );
      if (errorRequestResponse) {
        throw new Error(
          `Invalid credit pack request response: ${errorRequestResponse.message}`
        );
      }
      const { errorRequestConfirmation, value: validatedRequestConfirmation } =
        creditPackPurchaseRequestConfirmationSchema.validate(
          credit_pack_purchase_request_confirmation
        );
      if (errorRequestConfirmation) {
        throw new Error(
          `Invalid credit pack request confirmation: ${errorRequestConfirmation.message}`
        );
      }
      return {
        creditPackPurchaseRequestResponse:
          new CreditPackPurchaseRequestResponse(validatedRequestResponse),
        creditPackPurchaseRequestConfirmation:
          new CreditPackPurchaseRequestConfirmation(
            validatedRequestConfirmation
          ),
      };
    } catch (error) {
      logger.error(
        `Error retrieving credit pack ticket from txid: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async creditPackTicketInitialPurchaseRequest(
    supernodeURL,
    creditPackRequest
  ) {
    try {
      // Validate the credit pack request using Joi
      const { error, value: validatedCreditPackRequest } =
        creditPackPurchaseRequestSchema.validate(creditPackRequest.toJSON());
      if (error) {
        throw new Error(`Invalid credit pack request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      }
      // Create the credit pack purchase request in the database
      const _creditPackPurchaseRequestInstance =
        await CreditPackPurchaseRequest.create(validatedCreditPackRequest);
      logActionWithPayload(
        "requesting",
        "a new Pastel credit pack ticket",
        validatedCreditPackRequest
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      let preparedCreditPackRequest = await prepareModelForEndpoint(
        creditPackRequest
      );
      const response = await axios.post(
        `${supernodeURL}/credit_purchase_initial_request`,
        {
          challenge,
          challenge_id,
          challenge_signature,
          credit_pack_request: preparedCreditPackRequest,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      const result = response.data;

      if (result.rejection_reason_string) {
        logger.error(
          `Credit pack purchase request rejected: ${result.rejection_reason_string}`
        );
        let rejectionResponse = await prepareModelForValidation(result);
        const { rejectionError, value: validatedRejection } =
          await creditPackPurchaseRequestRejectionSchema.validateAsync(
            rejectionResponse
          );
        if (rejectionError) {
          throw new Error(
            `Invalid credit pack purchase request rejection: ${rejectionError.message}`
          );
        }
        const creditPackPurchaseRequestRejectionInstance =
          await CreditPackPurchaseRequestRejection.create(validatedRejection);
        return creditPackPurchaseRequestRejectionInstance;
      } else {
        logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          result
        );
        let preparedResult = await prepareModelForValidation(result);
        const { priceQuoteError, value: validatedPriceQuote } =
          await creditPackPurchaseRequestPreliminaryPriceQuoteSchema.validate(
            preparedResult
          );
        if (priceQuoteError) {
          throw new Error(
            "Invalid credit pack request: " + priceQuoteError.message
          );
        }
        const creditPackPurchaseRequestPreliminaryPriceQuoteInstance =
          await CreditPackPurchaseRequestPreliminaryPriceQuote.create(
            validatedPriceQuote
          );
        return creditPackPurchaseRequestPreliminaryPriceQuoteInstance;
      }
    } catch (error) {
      logger.error(
        `Error initiating credit pack ticket purchase: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async calculatePriceDifferencePercentage(quotedPrice, estimatedPrice) {
    if (estimatedPrice === 0) {
      throw new Error("Estimated price cannot be zero.");
    }
    const differencePercentage =
      Math.abs(quotedPrice - estimatedPrice) / estimatedPrice;
    return differencePercentage;
  }

  async confirmPreliminaryPriceQuote(
    preliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL,
    maximumPerCreditPriceInPSL
  ) {
    if (!maximumTotalCreditPackPriceInPSL && !maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL =
        process.env.MAXIMUM_PER_CREDIT_PRICE_IN_PSL_FOR_CLIENT;
    }
    const {
      preliminary_quoted_price_per_credit_in_psl: quotedPricePerCredit,
      preliminary_total_cost_of_credit_pack_in_psl: quotedTotalPrice,
      credit_pack_purchase_request_fields_json_b64: requestFieldsB64,
    } = preliminaryPriceQuote;
    let requestFields = JSON.parse(atob(requestFieldsB64)); // Decode base64 string
    const { requested_initial_credits_in_credit_pack: requestedCredits } =
      requestFields;
    if (!maximumTotalCreditPackPriceInPSL) {
      maximumTotalCreditPackPriceInPSL =
        maximumPerCreditPriceInPSL * requestedCredits;
    } else if (!maximumPerCreditPriceInPSL) {
      maximumPerCreditPriceInPSL =
        maximumTotalCreditPackPriceInPSL / requestedCredits;
    }
    const estimatedPricePerCredit =
      await estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    const priceDifferencePercentage =
      await this.calculatePriceDifferencePercentage(
        quotedPricePerCredit,
        estimatedPricePerCredit
      );

    const numberFormat = new Intl.NumberFormat("en-US");
    const percentageFormat = (value) => value.toFixed(2);

    if (
      quotedPricePerCredit <= maximumPerCreditPriceInPSL &&
      quotedTotalPrice <= maximumTotalCreditPackPriceInPSL &&
      priceDifferencePercentage <=
      process.env
        .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING
    ) {
      logger.info(
        `Preliminary price quote is within the acceptable range: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, which is within the maximum of ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit and ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which is within the allowed maximum of ${percentageFormat(
          process.env
            .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING *
          100
        )}%. Please be patient while the new credit pack request is initialized.`
      );
      return true;
    } else {
      logger.warn(
        `Preliminary price quote exceeds the maximum acceptable price or the price difference from the estimated fair price is too high! Quoted price: ${numberFormat.format(
          quotedPricePerCredit
        )} PSL per credit, ${numberFormat.format(
          quotedTotalPrice
        )} PSL total, maximum price: ${numberFormat.format(
          maximumPerCreditPriceInPSL
        )} PSL per credit, ${numberFormat.format(
          maximumTotalCreditPackPriceInPSL
        )} PSL total. The price difference from the estimated fair market price is ${percentageFormat(
          priceDifferencePercentage * 100
        )}%, which exceeds the allowed maximum of ${percentageFormat(
          process.env
            .MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING *
          100
        )}%.`
      );
      return false;
    }
  }

  async internalEstimateOfCreditPackTicketCostInPSL(
    desiredNumberOfCredits,
    priceCushionPercentage
  ) {
    const estimatedPricePerCredit =
      await estimatedMarketPriceOfInferenceCreditsInPSLTerms();
    const estimatedTotalCostOfTicket =
      Math.round(
        desiredNumberOfCredits *
        estimatedPricePerCredit *
        (1 + priceCushionPercentage) *
        100
      ) / 100;
    return estimatedTotalCostOfTicket;
  }

  async creditPackTicketPreliminaryPriceQuoteResponse(
    supernodeURL,
    creditPackRequest,
    preliminaryPriceQuote,
    maximumTotalCreditPackPriceInPSL,
    maximumPerCreditPriceInPSL
  ) {
    try {
      if (preliminaryPriceQuote instanceof CreditPackPurchaseRequestRejection) {
        logger.error(
          `Credit pack purchase request rejected: ${preliminaryPriceQuote.rejection_reason_string}`
        );
        return preliminaryPriceQuote;
      }

      const agreeWithPriceQuote = await this.confirmPreliminaryPriceQuote(
        preliminaryPriceQuote,
        maximumTotalCreditPackPriceInPSL,
        maximumPerCreditPriceInPSL
      );

      logger.info(`Agree with price quote: ${agreeWithPriceQuote}; responding to preliminary price quote to Supernode at ${supernodeURL}...`);
      const priceQuoteResponse =
        CreditPackPurchaseRequestPreliminaryPriceQuoteResponse.build({
          sha3_256_hash_of_credit_pack_purchase_request_fields:
            creditPackRequest.sha3_256_hash_of_credit_pack_purchase_request_fields,
          sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
            preliminaryPriceQuote.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields,
          credit_pack_purchase_request_fields_json_b64:
            preliminaryPriceQuote.credit_pack_purchase_request_fields_json_b64,
          agree_with_preliminary_price_quote: agreeWithPriceQuote,
          credit_usage_tracking_psl_address:
            preliminaryPriceQuote.credit_usage_tracking_psl_address,
          preliminary_quoted_price_per_credit_in_psl: parseFloat(
            preliminaryPriceQuote.preliminary_quoted_price_per_credit_in_psl
          ),
          preliminary_price_quote_response_timestamp_utc_iso_string:
            getIsoStringWithMicroseconds(),
          preliminary_price_quote_response_pastel_block_height: parseInt(
            await getCurrentPastelBlockHeight(),
            10
          ),
          preliminary_price_quote_response_message_version_string: "1.0",
          requesting_end_user_pastelid:
            creditPackRequest.requesting_end_user_pastelid,
          sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
            "",
          requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
            "",
        });
      // Compute hashes and signatures
      priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields =
        await computeSHA3256HashOfSQLModelResponseFields(priceQuoteResponse);
      priceQuoteResponse.requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash =
        await signMessageWithPastelID(
          creditPackRequest.requesting_end_user_pastelid,
          priceQuoteResponse.sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields,
          this.passphrase
        );
      // Validate the price quote response
      const {
        error: priceQuoteValidationError,
        value: validatedPriceQuoteResponse,
      } =
        await creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema.validate(
          priceQuoteResponse.toJSON()
        );
      if (priceQuoteValidationError) {
        throw new Error(
          `Invalid price quote response: ${priceQuoteValidationError.message}`
        );
      }
      // Prepare model for endpoint before sending
      let preparedPriceQuoteResponse = await prepareModelForEndpoint(
        priceQuoteResponse
      );

      delete preparedPriceQuoteResponse["id"];
      preparedPriceQuoteResponse["agree_with_preliminary_price_quote"] =
        preparedPriceQuoteResponse["agree_with_preliminary_price_quote"]
          ? 1
          : 0;

      // Prepare and send the payload to the supernode
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const completePriceQuoteResponse = {
        challenge,
        challenge_id,
        challenge_signature,
        preliminary_price_quote_response: preparedPriceQuoteResponse,
      };

      const response = await axios.post(
        `${supernodeURL}/credit_purchase_preliminary_price_quote_response`,
        completePriceQuoteResponse,
        { timeout: 3 * MESSAGING_TIMEOUT_IN_SECONDS * 1000 }
      );
      const result = response.data;
      if (result.termination_reason_string) {
        logger.error(
          `Credit pack purchase request response terminated: ${result.termination_reason_string}`
        );
        const terminationResponse = await prepareModelForValidation(result);
        const { error: terminationError, value: validatedTermination } =
          await creditPackPurchaseRequestResponseTerminationSchema.validateAsync(
            terminationResponse
          );
        if (terminationError) {
          throw new Error(
            `Invalid credit pack purchase request response termination: ${terminationError.message}`
          );
        }
        const terminationInstance =
          await CreditPackPurchaseRequestResponseTermination.create(
            validatedTermination
          );
        return terminationInstance;
      } else {
        let transformedResult = transformCreditPackPurchaseRequestResponse(
          await prepareModelForValidation(result)
        );
        logActionWithPayload(
          "receiving",
          "response to credit pack purchase request",
          transformedResult
        );
        const { error: resultError, value: validatedResponse } =
          await creditPackPurchaseRequestResponseSchema.validate(
            transformedResult
          );
        if (resultError) {
          throw new Error(
            `Invalid credit pack purchase request response: ${resultError.message}`
          );
        }
        const responseInstance = await CreditPackPurchaseRequestResponse.create(
          validatedResponse
        );
        return responseInstance;
      }
    } catch (error) {
      logger.error(
        `Error responding to preliminary price quote: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async confirmCreditPurchaseRequest(
    supernodeURL,
    creditPackPurchaseRequestConfirmation
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = await prepareModelForEndpoint(
        creditPackPurchaseRequestConfirmation
      );
      logActionWithPayload(
        "confirming",
        "credit pack purchase request",
        payload
      );
      const response = await axios.post(
        `${supernodeURL}/confirm_credit_purchase_request`,
        {
          confirmation: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 30 * 1000, // Need to be patient with the timeout here since it requires the transaction to be mined/confirmed
        }
      );
      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to credit pack purchase confirmation",
        result
      );
      const { error: validationError, value: validatedResult } =
        await creditPackPurchaseRequestConfirmationResponseSchema.validate(
          result
        );
      if (validationError) {
        throw new Error(
          `Invalid credit pack purchase request confirmation response: ${validationError.message}`
        );
      }
      const creditPackPurchaseRequestConfirmationResponseInstance =
        await CreditPackPurchaseRequestConfirmationResponse.create(result);
      return creditPackPurchaseRequestConfirmationResponseInstance;
    } catch (error) {
      logger.error(
        `Error confirming credit pack purchase request: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async checkStatusOfCreditPurchaseRequest(
    supernodeURL,
    creditPackPurchaseRequestHash
  ) {
    try {
      // Request challenge from the server
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      // Build and validate the status check model
      const statusCheck = CreditPackRequestStatusCheck.build({
        sha3_256_hash_of_credit_pack_purchase_request_fields:
          creditPackPurchaseRequestHash,
        requesting_end_user_pastelid: this.pastelID,
        requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
          await signMessageWithPastelID(
            this.pastelID,
            creditPackPurchaseRequestHash,
            this.passphrase
          ),
      });
      const { error: validationError, value: validatedStatusCheck } =
        await creditPackRequestStatusCheckSchema.validate(statusCheck.toJSON());
      if (validationError) {
        logger.error(
          `Invalid credit pack request status check: ${validationError.message}`
        );
        throw new Error(
          `Invalid credit pack request status check: ${validationError.message}`
        );
      }
      delete validatedStatusCheck["id"];
      logActionWithPayload(
        "checking",
        "status of credit pack purchase request",
        validatedStatusCheck
      );
      // Send the request to the server
      const response = await axios.post(
        `${supernodeURL}/check_status_of_credit_purchase_request`,
        {
          credit_pack_request_status_check: validatedStatusCheck,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );
      // Check response status and handle any errors
      if (response.status !== 200) {
        throw new Error(
          `HTTP error ${response.status}: ${response.statusText}`
        );
      }
      logActionWithPayload(
        "receiving",
        "credit pack purchase request response from Supernode",
        response.data
      );
      // Validate the received result
      let transformedResult = await prepareModelForValidation(response.data);
      delete transformedResult["id"];
      const { error: resultError, value: validatedResult } =
        await creditPackPurchaseRequestStatusSchema.validate(transformedResult);
      if (resultError) {
        throw new Error(
          `Invalid credit pack purchase request status: ${resultError.message}`
        );
      }
      // Create and return the status instance from the validated result
      const statusInstance = await CreditPackPurchaseRequestStatus.create(
        validatedResult
      );
      return statusInstance;
    } catch (error) {
      logger.error(
        `Error checking status of credit purchase request: ${safeStringify(
          error.message
        )}`
      );
      throw error; // Rethrow to handle error upstream
    }
  }

  async creditPackPurchaseCompletionAnnouncement(
    supernodeURL,
    creditPackPurchaseRequestConfirmation
  ) {
    try {
      // Validate the incoming data
      const { error, value: validatedConfirmation } =
        await creditPackPurchaseRequestConfirmationSchema.validate(
          creditPackPurchaseRequestConfirmation.toJSON()
        );
      if (error) {
        logger.error(
          `Invalid credit pack purchase request confirmation: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        return; // Return early instead of throwing an error
      }

      // Request challenge from the server
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      // Prepare the model for the endpoint
      let payload = validatedConfirmation;
      delete payload["id"]; // Removing the 'id' key as done in the Python method

      // Send the request to the server with a shortened timeout
      const response = await axios.post(
        `${supernodeURL}/credit_pack_purchase_completion_announcement`,
        {
          confirmation: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: 2 * 1000, // Shortened timeout of 2 seconds
        }
      );

      // Check response status and log any errors
      if (response.status !== 200) {
        logger.error(`HTTP error ${response.status}: ${response.statusText}`);
      } else {
        logger.info(
          `Credit pack purchase completion announcement sent successfully to ${supernodeURL}`
        );
      }
    } catch (error) {
      // Log the error without rethrowing to prevent upstream disruption
      if (error.response) {
        logger.error(
          `HTTP error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.response.status} ${error.response.statusText}`
        );
      } else if (error.code === "ECONNABORTED") {
        logger.error(
          `Timeout error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      } else {
        logger.error(
          `Error sending credit pack purchase completion announcement to ${supernodeURL}: ${error.message || error
          }`
        );
      }
    }
  }

  async creditPackStorageRetryRequest(
    supernodeURL,
    creditPackStorageRetryRequest
  ) {
    try {
      const { error, value: validatedRequest } =
        await creditPackStorageRetryRequestSchema.validate(
          creditPackStorageRetryRequest.toJSON()
        );
      if (error) {
        throw new Error(
          `Invalid credit pack storage retry request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }

      const requestInstance = await CreditPackStorageRetryRequest.create(
        validatedRequest
      );

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(requestInstance);
      logActionWithPayload(
        "sending",
        "credit pack storage retry request",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/credit_pack_storage_retry_request`,
        {
          request: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to credit pack storage retry request",
        result
      );

      let transformedResult = await prepareModelForValidation(result);
      const { error: responseError, value: validatedResponse } =
        await creditPackStorageRetryRequestResponseSchema.validate(
          transformedResult
        );
      if (responseError) {
        throw new Error(
          `Invalid credit pack storage retry request response: ${responseError.message}`
        );
      }

      const responseInstance =
        await CreditPackStorageRetryRequestResponse.create(validatedResponse);
      return responseInstance;
    } catch (error) {
      logger.error(
        `Error sending credit pack storage retry request: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async creditPackStorageRetryCompletionAnnouncement(
    supernodeURL,
    creditPackStorageRetryRequestResponse
  ) {
    try {
      const { error, value: validatedResponse } =
        await creditPackStorageRetryRequestResponseSchema.validate(
          creditPackStorageRetryRequestResponse.toJSON()
        );
      if (error) {
        throw new Error(
          `Invalid credit pack storage retry request response: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }

      const responseInstance =
        await CreditPackStorageRetryRequestResponse.create(validatedResponse);

      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(responseInstance);
      logActionWithPayload(
        "sending",
        "storage retry completion announcement message",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/credit_pack_storage_retry_completion_announcement`,
        {
          response: payload,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      response.data; // Access the response data to trigger any potential errors
    } catch (error) {
      logger.error(
        `Error sending credit pack storage retry completion announcement: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async retrieveCreditPackTicketFromPurchaseBurnTxid(supernodeURL, txid) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: txid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "credit pack ticket from purchase burn txid",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/retrieve_credit_pack_ticket_from_purchase_burn_txid`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const ticketInfo = response.data;
      logger.info(
        `Received credit pack ticket for purchase burn txid ${txid}: ${JSON.stringify(
          ticketInfo
        )}`
      );
      return ticketInfo;
    } catch (error) {
      logger.error(
        `Error retrieving credit pack ticket for purchase burn txid ${txid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async getFinalCreditPackRegistrationTxidFromPurchaseBurnTxid(
    supernodeURL,
    purchaseBurnTxid
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = {
        purchase_burn_txid: purchaseBurnTxid,
        challenge,
        challenge_id,
        challenge_signature,
      };
      logActionWithPayload(
        "retrieving",
        "final credit pack registration txid",
        payload
      );

      const response = await axios.post(
        `${supernodeURL}/get_final_credit_pack_registration_txid_from_credit_purchase_burn_txid`,
        payload,
        { timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000 }
      );

      if (response.status !== 200) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const finalTxid = response.data.final_credit_pack_registration_txid;
      logger.info(
        `Received final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${finalTxid}`
      );
      return finalTxid;
    } catch (error) {
      logger.error(
        `Error retrieving final credit pack registration txid for purchase burn txid ${purchaseBurnTxid}: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async makeInferenceAPIUsageRequest(supernodeURL, requestData) {
    try {
      const { error, value: validatedRequest } =
        await inferenceAPIUsageRequestSchema.validate(requestData.toJSON());
      if (error) {
        throw new Error(
          `Invalid inference API usage request: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      delete validatedRequest["id"];
      const requestInstance = await InferenceAPIUsageRequest.create(
        validatedRequest
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const payload = await prepareModelForEndpoint(requestInstance);
      logActionWithPayload(
        "making",
        "inference usage request",
        validatedRequest
      );
      const response = await axios.post(
        `${supernodeURL}/make_inference_api_usage_request`,
        {
          inference_api_usage_request: validatedRequest,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 6 * 1000,
        }
      );
      const result = response.data;
      logActionWithPayload(
        "received",
        "response to inference usage request",
        result
      );
      let transformedResult = await prepareModelForValidation(result);
      delete transformedResult["id"];
      const { error: responseError, value: validatedResponse } =
        await inferenceAPIUsageResponseSchema.validate(transformedResult);
      if (responseError) {
        throw new Error(
          `Invalid inference API usage response: ${responseError.message}`
        );
      }
      const responseInstance = await InferenceAPIUsageResponse.create(
        validatedResponse
      );
      return responseInstance;
    } catch (error) {
      logger.error(
        `Error making inference API usage request: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
      );
      throw error;
    }
  }

  async sendInferenceConfirmation(supernodeURL, confirmationData) {
    try {
      const confirmationDataJSON = confirmationData.toJSON();
      // Remove the 'id' field from the JSON object
      delete confirmationDataJSON["id"];

      const { error, value: validatedConfirmation } =
        await inferenceConfirmationSchema.validate(confirmationDataJSON);
      if (error) {
        throw new Error(
          `Invalid inference confirmation data: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
      }
      const confirmationInstance = await InferenceConfirmation.create(
        validatedConfirmation
      );
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);

      const payload = await prepareModelForEndpoint(confirmationInstance);
      logActionWithPayload("sending", "inference confirmation", payload);
      const response = await axios.post(
        `${supernodeURL}/confirm_inference_request`,
        {
          inference_confirmation: confirmationDataJSON,
          challenge,
          challenge_id,
          challenge_signature,
        },
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 4 * 1000,
        }
      );
      const result = response.data;
      logActionWithPayload(
        "receiving",
        "response to inference confirmation",
        result
      );

      return result;
    } catch (error) {
      logger.error(
        `Error sending inference confirmation: ${safeStringify(error.message)}`
      );
      throw error;
    }
  }
  async checkStatusOfInferenceRequestResults(
    supernodeURL,
    inferenceResponseID
  ) {
    try {
      logger.info(
        `Checking status of inference request results for ID ${inferenceResponseID}`
      );

      const response = await axios.get(
        `${supernodeURL}/check_status_of_inference_request_results/${inferenceResponseID}`,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 1000,
        }
      );

      const result = response.data;
      logActionWithPayload(
        "receiving",
        `status of inference request results for ID ${inferenceResponseID}`,
        result
      );

      return typeof result === "boolean" ? result : false;
    } catch (error) {
      if (error.response) {
        logger.error(
          `HTTP error checking status of inference request results from Supernode URL: ${supernodeURL}: ${safeStringify(
            error
          )}`
        );
      } else {
        logger.error(
          `Error checking status of inference request results from Supernode URL: ${supernodeURL}: ${safeStringify(
            error
          )}`
        );
      }
      return false;
    }
  }

  async retrieveInferenceOutputResults(
    supernodeURL,
    inferenceRequestID,
    inferenceResponseID
  ) {
    try {
      const { challenge, challenge_id, challenge_signature } =
        await this.requestAndSignChallenge(supernodeURL);
      const params = new URLSearchParams({
        inference_response_id: inferenceResponseID,
        pastelid: this.pastelID,
        challenge,
        challenge_id,
        challenge_signature,
      }).toString();
      logActionWithPayload(
        "attempting",
        `to retrieve inference output results for response ID ${inferenceResponseID}`,
        params
      );
      const response = await axios.post(
        `${supernodeURL}/retrieve_inference_output_results?${params}`,
        {}, // No data object needed since we're sending parameters in the URL
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 4 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      logActionWithPayload("receiving", "inference output results", result);
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIOutputResultSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API output result: ${validationError.message}`
        );
      }
      const resultInstance = await InferenceAPIOutputResult.create(
        validatedResult
      );
      return resultInstance;
    } catch (error) {
      logger.error(
        `Error retrieving inference output results: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResponse(supernodeURL, inferenceResponseID) {
    try {
      const signature = await signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await axios.post(
        `${supernodeURL}/audit_inference_request_response`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 2 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIUsageResponseSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API usage response: ${validationError.message}`
        );
      }
      return validatedResult;
    } catch (error) {
      logger.error(
        `Error calling audit inference request response from Supernode URL: ${supernodeURL}: ${safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async callAuditInferenceRequestResult(supernodeURL, inferenceResponseID) {
    try {
      const signature = await signMessageWithPastelID(
        this.pastelID,
        inferenceResponseID,
        this.passphrase
      );
      const payload = {
        inference_response_id: inferenceResponseID,
        pastel_id: this.pastelID,
        signature,
      };
      const response = await axios.post(
        `${supernodeURL}/audit_inference_request_result`,
        payload,
        {
          timeout: MESSAGING_TIMEOUT_IN_SECONDS * 2 * 1000,
        }
      );
      const result = response.data;
      delete result["id"]; // Remove the 'id' field from the JSON object
      let transformedResult = await prepareModelForValidation(result);
      const { error: validationError, value: validatedResult } =
        await inferenceAPIOutputResultSchema.validate(transformedResult);
      if (validationError) {
        throw new Error(
          `Invalid inference API output result: ${validationError.message}`
        );
      }
      return validatedResult;
    } catch (error) {
      logger.error(
        `Error calling audit inference request result from Supernode URL: ${supernodeURL}: ${safeStringify(
          error
        )}`
      );
      throw error;
    }
  }

  async auditInferenceRequestResponseID(
    inferenceResponseID,
    pastelIDOfSupernodeToAudit
  ) {
    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const filteredSupernodes = await filterSupernodes(validMasternodeListFullDF);

      const supernodeURLsAndPastelIDs = filteredSupernodes
        .filter(({ pastelID }) => pastelID !== pastelIDOfSupernodeToAudit)
        .slice(0, 5); // Get the 5 closest supernodes

      const listOfSupernodePastelIDs = supernodeURLsAndPastelIDs.map(({ pastelID }) => pastelID);
      const listOfSupernodeURLs = supernodeURLsAndPastelIDs.map(({ url }) => url);
      const listOfSupernodeIPs = listOfSupernodeURLs.map(
        (url) => url.split("//")[1].split(":")[0]
      );

      logger.info(
        `Now attempting to audit inference request response with ID ${inferenceResponseID} with ${listOfSupernodePastelIDs.length} closest supernodes (with Supernode IPs of ${listOfSupernodeIPs})...`
      );

      const responseAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResponse(url, inferenceResponseID)
      );
      const responseAuditResults = await Promise.all(responseAuditTasks);

      await new Promise((resolve) => setTimeout(resolve, 20000));

      logger.info(
        `Now attempting to audit inference request result for response ID ${inferenceResponseID} by comparing information from other Supernodes to the information reported by the Responding Supernode...`
      );

      const resultAuditTasks = listOfSupernodeURLs.map((url) =>
        this.callAuditInferenceRequestResult(url, inferenceResponseID)
      );
      const resultAuditResults = await Promise.all(resultAuditTasks);

      const auditResults = [...responseAuditResults, ...resultAuditResults];
      logger.info(
        `Audit results retrieved for inference response ID ${inferenceResponseID}`
      );

      return auditResults;
    } catch (error) {
      logger.error(
        `Error auditing inference request response ID: ${safeStringify(
          error.message
        )}`
      );
      throw error;
    }
  }

  async checkIfSupernodeSupportsDesiredModel(
    supernodeURL,
    modelCanonicalString,
    modelInferenceTypeString,
    modelParametersJSON
  ) {
    try {
      const response = await axios.get(
        `${supernodeURL}/get_inference_model_menu`,
        {
          timeout: 8 * 1000,
        }
      );

      const modelMenu = response.data;
      const desiredParameters = JSON.parse(modelParametersJSON);

      for (const model of modelMenu.models) {
        if (
          model.model_name === modelCanonicalString &&
          model.supported_inference_type_strings.includes(
            modelInferenceTypeString
          )
        ) {
          const unsupportedParameters = [];

          for (const [desiredParam, desiredValue] of Object.entries(
            desiredParameters
          )) {
            let paramFound = false;

            for (const param of model.model_parameters) {
              if (
                param.name === desiredParam &&
                param.inference_types_parameter_applies_to.includes(
                  modelInferenceTypeString
                )
              ) {
                if ("type" in param) {
                  if (
                    param.type === "int" &&
                    Number.isInteger(Number(desiredValue))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "float" &&
                    !isNaN(parseFloat(desiredValue))
                  ) {
                    paramFound = true;
                  } else if (
                    param.type === "string" &&
                    typeof desiredValue === "string"
                  ) {
                    if (
                      "options" in param &&
                      param.options.includes(desiredValue)
                    ) {
                      paramFound = true;
                    } else if (!("options" in param)) {
                      paramFound = true;
                    }
                  }
                } else {
                  paramFound = true;
                }
                break;
              }
            }

            if (!paramFound) {
              unsupportedParameters.push(desiredParam);
            }
          }

          if (unsupportedParameters.length === 0) {
            return true;
          } else {
            const unsupportedParamStr = unsupportedParameters.join(", ");
            logger.error(
              `Unsupported model parameters for ${modelCanonicalString}: ${unsupportedParamStr}`
            );
            return false;
          }
        }
      }
      return false;
    } catch (error) {
      return false;
    }
  }

  async getClosestSupernodeURLsThatSupportsDesiredModel(
    desiredModelCanonicalString,
    desiredModelInferenceTypeString,
    desiredModelParametersJSON,
    N = 12 // Limit to 12 supernodes
  ) {
    const timeoutPeriod = 3000; // Timeout period in milliseconds

    try {
      const { validMasternodeListFullDF } = await checkSupernodeList();
      const filteredSupernodes = await filterSupernodes(validMasternodeListFullDF);

      // Prepare all the promises for checking supernodes concurrently
      const checkSupernodePromises = filteredSupernodes.map((supernode) => {
        const startTime = Date.now(); // Capture the start time for the supernode check

        return Promise.race([
          this.checkIfSupernodeSupportsDesiredModel(
            supernode.url,
            desiredModelCanonicalString,
            desiredModelInferenceTypeString,
            desiredModelParametersJSON
          ).then((result) => ({
            result,
            url: supernode.url,
            responseTime: Date.now() - startTime // Capture the response time
          })),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), timeoutPeriod)
          )
        ]).catch(() => null); // Silently catch and return null for failed requests
      });

      // Wait for all promises to settle
      const results = await Promise.allSettled(checkSupernodePromises);

      // Filter out null or rejected results
      const validResponses = results
        .filter((res) => res.status === 'fulfilled' && res.value !== null)
        .map((res) => res.value);

      // Sort the valid responses by their response times (fastest first)
      const sortedResponses = validResponses.sort((a, b) => a.responseTime - b.responseTime);

      // Return the closest N supernodes, capped at the number available
      return sortedResponses.slice(0, N).map((response) => response.url);
    } catch (error) {
      throw new Error(`Failed to get closest supernodes: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    }
  }


}

module.exports = {
  PastelInferenceClient,
};


---
./rpc_functions.js
---
// rpc_functions.js

require("dotenv").config();
const http = require("http");
const https = require("https");
const fs = require("fs");
const os = require("os");
const path = require("path");
const readline = require("readline");
const { URL } = require("url");
const axios = require("axios");
const Joi = require("joi");
const { SupernodeList } = require("./sequelize_data_models");
const { messageSchema, supernodeListSchema } = require("./validation_schemas");
const { logger, safeStringify } = require("./logger");
const { execSync, spawn } = require("child_process");
const storage = require("node-persist");
const { setPastelIdAndPassphrase } = require("./storage");
let rpc_connection;
const globals = require("./globals");

// Initialize the storage
storage.init();

async function searchBinaryRecursively(directory, binaryName) {
  try {
    const result = execSync(
      `sudo find ${directory} -type f -name ${binaryName} -size +7M`,
      { encoding: "utf-8" }
    );
    return result.trim().split("\n").filter(Boolean);
  } catch (error) {
    return [];
  }
}

async function getMostRecentBinary(binaries) {
  const stats = await Promise.all(
    binaries.map(async (binary) => {
      const stat = await fs.promises.stat(binary);
      return { binary, mtime: stat.mtime };
    })
  );
  return stats.sort((a, b) => b.mtime - a.mtime)[0]?.binary;
}

async function locatePasteldBinary() {
  await storage.init();
  let pasteldBinaryPath = await storage.getItem("pasteldBinaryPath");
  if (!pasteldBinaryPath || !fs.existsSync(pasteldBinaryPath)) {
    const searchDirectories = ["/home", "/usr/local/bin", "/usr/bin"];
    if (process.platform === "win32") {
      searchDirectories.push(process.env.ProgramFiles);
    } else if (process.platform === "darwin") {
      searchDirectories.push("/Users");
    } else {
      searchDirectories.push("/home", "/etc");
    }
    const foundBinaries = (
      await Promise.all(
        searchDirectories.map((dir) => searchBinaryRecursively(dir, "pasteld"))
      )
    ).flat();
    pasteldBinaryPath = await getMostRecentBinary(foundBinaries);
    if (!pasteldBinaryPath) {
      throw new Error("pasteld binary not found on the system.");
    }
    await storage.setItem("pasteldBinaryPath", pasteldBinaryPath);
  }
  return pasteldBinaryPath;
}

async function startPastelDaemon() {
  try {
    const pasteldPath = await locatePasteldBinary();
    console.log(`Starting pasteld from path: ${pasteldPath}`);

    const pastelDaemon = spawn(pasteldPath, [], { stdio: "inherit" });

    pastelDaemon.on("close", (code) => {
      console.log(`pasteld process exited with code ${code}`);
    });

    pastelDaemon.on("error", (err) => {
      console.error("Error starting pasteld:", err);
    });
  } catch (error) {
    console.error("Failed to start pasteld:", error);
  }
}

async function getMostRecentFile(files) {
  return files
    .map((file) => ({ file, mtime: fs.statSync(file).mtime }))
    .sort((a, b) => b.mtime - a.mtime)[0]?.file;
}

function searchFileRecursively(directory, filename) {
  try {
    const results = [];

    function searchRecursive(currentPath) {
      const files = fs.readdirSync(currentPath);

      for (const file of files) {
        const filePath = path.join(currentPath, file);
        const stat = fs.statSync(filePath);

        if (stat.isDirectory()) {
          searchRecursive(filePath);
        } else if (file === filename) {
          results.push(filePath);
        }
      }
    }

    searchRecursive(directory);
    return results;
  } catch (error) {
    console.error(`Error searching for file: ${error.message}`);
    return [];
  }
}

async function getLocalRPCSettings(
  directoryWithPastelConf = path.join(os.homedir(), ".pastel")
) {
  let newDirectoryWithPastelConf = directoryWithPastelConf;
  if (process.platform === "win32") {
    newDirectoryWithPastelConf = path.join(os.homedir(), "AppData", "Roaming", "Pastel")
  }
  if (process.platform === "darwin") {
    newDirectoryWithPastelConf = path.join(os.homedir(), "Library", "Application Support", "Pastel")
  }
  if (['darwin', 'linux'].indexOf(process.platform) !== -1) {
    newDirectoryWithPastelConf = newDirectoryWithPastelConf.replace(/ /g, '\\ ')
  }
  await storage.init();
  let pastelConfPath =
    (await storage.getItem("pastelConfPath")) ||
    path.join(newDirectoryWithPastelConf, "pastel.conf");
  if (!fs.existsSync(pastelConfPath)) {
    console.log(
      `pastel.conf not found in stored path or default directory, scanning the system...`
    );
    const searchDirectories = ["/home"];
    if (process.platform === "win32") {
      searchDirectories.push(process.env.ProgramData);
    } else if (process.platform === "darwin") {
      searchDirectories.push(path.join(os.homedir(), "Library", "Application Support", "Pastel"));
    } else {
      searchDirectories.push("/home", "/etc");
    }
    const foundFiles = searchDirectories.flatMap((dir) =>
      searchFileRecursively(dir, "pastel.conf")
    );
    pastelConfPath = await getMostRecentFile(foundFiles);
    if (!pastelConfPath) {
      throw new Error("pastel.conf file not found on the system.");
    }
    await storage.setItem("pastelConfPath", pastelConfPath);
  }
  const lines = fs.readFileSync(pastelConfPath, "utf-8").split("\n");
  const otherFlags = {};
  let rpchost = "127.0.0.1";
  let rpcport = "19932";
  let rpcuser = "";
  let rpcpassword = "";
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine || trimmedLine.startsWith("#")) {
      continue; // Ignore blank lines and comments
    }
    if (trimmedLine.includes("=")) {
      const [key, value] = trimmedLine.split("=", 2);
      const trimmedKey = key.trim();
      const trimmedValue = value.trim();

      if (trimmedKey === "rpcport") {
        rpcport = trimmedValue;
      } else if (trimmedKey === "rpcuser") {
        rpcuser = trimmedValue;
      } else if (trimmedKey === "rpcpassword") {
        rpcpassword = trimmedValue;
      } else if (trimmedKey === "rpchost") {
        rpchost = trimmedValue;
      } else {
        otherFlags[trimmedKey] = trimmedValue;
      }
    }
  }
  return { rpchost, rpcport, rpcuser, rpcpassword, otherFlags };
}

class JSONRPCException extends Error {
  constructor(rpcError) {
    super(rpcError.message);
    this.error = rpcError;
    this.code = rpcError.code || null;
    this.message = rpcError.message || null;
  }
  toString() {
    return `${this.code}: ${this.message}`;
  }
}

class Semaphore {
  constructor(maxConcurrent) {
    this.maxConcurrent = maxConcurrent;
    this.counter = maxConcurrent;
    this.waiting = [];
  }
  async acquire() {
    if (this.counter <= 0) {
      await new Promise((resolve) => this.waiting.push(resolve));
    }
    this.counter--;
  }
  release() {
    this.counter++;
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift();
      resolve();
    }
  }
}

class AsyncAuthServiceProxy {
  static maxConcurrentRequests = 5000;
  static semaphore = new Semaphore(AsyncAuthServiceProxy.maxConcurrentRequests);

  constructor(
    serviceUrl,
    serviceName = null,
    reconnectTimeout = 15,
    reconnectAmount = 2,
    requestTimeout = 20
  ) {
    this.serviceUrl = serviceUrl;
    this.serviceName = serviceName;
    this.url = new URL(serviceUrl);
    this.client = axios.create({
      timeout: requestTimeout * 1000,
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      httpAgent: new http.Agent({ keepAlive: true, maxSockets: 200 }),
      httpsAgent: new https.Agent({ keepAlive: true, maxSockets: 200 }),
    });
    this.idCount = 0;
    const { username, password } = this.url;
    const authPair = `${username}:${password}`;
    this.authHeader = `Basic ${Buffer.from(authPair).toString("base64")}`;
    this.reconnectTimeout = reconnectTimeout;
    this.reconnectAmount = reconnectAmount;
    this.requestTimeout = requestTimeout;
  }

  async call(methodName, ...args) {
    await AsyncAuthServiceProxy.semaphore.acquire();
    try {
      this.idCount += 1;
      const postData = JSON.stringify({
        jsonrpc: "2.0",
        method: methodName,
        params: args,
        id: this.idCount,
      });
      const headers = {
        Host: this.url.hostname,
        "User-Agent": "AuthServiceProxy/0.1",
        Authorization: this.authHeader,
        "Content-Type": "application/json",
      };

      let response;
      for (let i = 0; i < this.reconnectAmount; i++) {
        try {
          if (i > 0) {
            const sleepTime = this.reconnectTimeout * 2 ** i;
            logger.error(`Reconnect try #${i + 1}`);
            logger.info(`Waiting for ${sleepTime} seconds before retrying.`);
            await new Promise((resolve) =>
              setTimeout(resolve, sleepTime * 1000)
            );
          }
          response = await this.client.post(this.serviceUrl, postData, {
            headers,
          });
          break;
        } catch (error) {
          logger.error(`Error occurred on attempt ${i + 1}: ${error}`);
          if (i === this.reconnectAmount - 1) {
            logger.error("Reconnect tries exceeded.");
            throw error;
          }
        }
      }
      if (!response) {
        throw new Error("No response from server, all retry attempts failed.");
      }
      const responseJson = response.data;
      if (responseJson.error) {
        throw new JSONRPCException(responseJson.error);
      } else if (!("result" in responseJson)) {
        throw new JSONRPCException({
          code: -343,
          message: "Missing JSON-RPC result",
        });
      }
      return responseJson.result;
    } finally {
      AsyncAuthServiceProxy.semaphore.release();
    }
  }

  // Create a proxy to handle method calls dynamically
  static create(serviceUrl) {
    const handler = {
      get: function (target, propKey) {
        if (typeof target[propKey] === "function") {
          return function (...args) {
            return target[propKey](...args);
          };
        } else {
          return function (...args) {
            return target.call(propKey, ...args);
          };
        }
      },
    };
    return new Proxy(new AsyncAuthServiceProxy(serviceUrl), handler);
  }
}

async function initializeRPCConnection() {
  const { rpchost, rpcport, rpcuser, rpcpassword } =
    await getLocalRPCSettings();
  rpc_connection = AsyncAuthServiceProxy.create(
    `http://${rpcuser}:${rpcpassword}@${rpchost}:${rpcport}`
  );
}

async function waitForRPCConnection(maxRetries = 5, interval = 1000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    if (rpc_connection) {
      return true; // Connection is available
    }
    logger.info(
      `Waiting for RPC connection... Attempt ${attempt}/${maxRetries}`
    );
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  logger.error("Failed to establish RPC connection after several attempts.");
  return false; // Connection is not available after retries
}

async function checkMasternodeTop() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const masternodeTopOutput = await rpc_connection.masternode("top");
  return masternodeTopOutput;
}

async function stopPastelDaemon() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const masternodeTopOutput = await rpc_connection.stop();
  return masternodeTopOutput;
}

async function getCurrentPastelBlockHeight() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const bestBlockHash = await rpc_connection.getbestblockhash();
  const bestBlockDetails = await rpc_connection.getblock(bestBlockHash);
  const currentBlockHeight = bestBlockDetails.height;
  return currentBlockHeight;
}

async function getBestBlockHashAndMerkleRoot() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const bestBlockHeight = await getCurrentPastelBlockHeight();
  const bestBlockHash = await rpc_connection.getblockhash(bestBlockHeight);
  const bestBlockDetails = await rpc_connection.getblock(bestBlockHash);
  const bestBlockMerkleRoot = bestBlockDetails.merkleroot;
  return [bestBlockHash, bestBlockMerkleRoot, bestBlockHeight];
}

async function verifyMessageWithPastelID(
  pastelid,
  messageToVerify,
  pastelIDSignatureOnMessage
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const verificationResult = await rpc_connection.pastelid(
    "verify",
    messageToVerify,
    pastelIDSignatureOnMessage,
    pastelid,
    "ed448"
  );
  return verificationResult.verification; // Return the verification result
}

async function sendToAddress(
  address,
  amount,
  comment = "",
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return { success: false, message: "RPC connection is not available" };
  }
  try {
    // Check available balance
    const balance = await getBalance();
    if (balance < amount) {
      const message = `Insufficient balance. Available: ${balance}, Required: ${amount}`;
      logger.error(message);
      return { success: false, message };
    }
    // Proceed with sending the amount
    const result = await rpc_connection.sendtoaddress(
      address,
      amount,
      comment,
    );
    return { success: true, result };
  } catch (error) {
    logger.error(`Error in sendToAddress: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return {
      success: false,
      message: `Error in sendToAddress: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`,
    };
  }
}

async function sendMany(
  amounts,
  minConf = 1,
  comment = "",
  changeAddress = ""
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const fromAccount = "";
    const result = await rpc_connection.sendmany(
      fromAccount,
      amounts,
      minConf,
      comment,
      [""],
      changeAddress
    );
    return result;
  } catch (error) {
    logger.error(`Error in sendMany: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return null;
  }
}

async function checkPSLAddressBalance(addressToCheck) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const balance = await rpc_connection.z_getbalance(addressToCheck);
  return balance;
}

async function checkIfAddressIsAlreadyImportedInLocalWallet(addressToCheck) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const addressAmounts = await rpc_connection.listaddressamounts();
  const addressAmountsArray = Object.entries(addressAmounts).map(
    ([address, amount]) => ({ address, amount })
  );
  const filteredAddressAmounts = addressAmountsArray.filter(
    (entry) => entry.address === addressToCheck
  );
  return filteredAddressAmounts.length > 0;
}

async function getAndDecodeRawTransaction(txid, blockhash = null) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const rawTxData = await rpc_connection.getrawtransaction(
      txid,
      0,
      blockhash
    );
    if (!rawTxData) {
      logger.error(`Failed to retrieve raw transaction data for ${txid}`);
      return {};
    }
    const decodedTxData = await rpc_connection.decoderawtransaction(rawTxData);
    if (!decodedTxData) {
      logger.error(`Failed to decode raw transaction data for ${txid}`);
      return {};
    }
    logger.debug(
      `Decoded transaction details for ${txid}:`,
      safeStringify(decodedTxData)
    );
    return decodedTxData;
  } catch (error) {
    logger.error(
      `Error in getAndDecodeRawTransaction for ${txid}:`,
      safeStringify(error)
    );
    return {};
  }
}

async function getTransactionDetails(txid, includeWatchonly = false) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const transactionDetails = await rpc_connection.gettransaction(
      txid,
      includeWatchonly
    );
    logger.debug(
      `Retrieved transaction details for ${txid}:`,
      safeStringify(transactionDetails)
    );
    return transactionDetails;
  } catch (error) {
    logger.error(
      `Error retrieving transaction details for ${txid}:`,
      safeStringify(error)
    );
    return {};
  }
}

async function sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest(
  inferenceRequestId,
  creditUsageTrackingPSLAddress,
  creditUsageTrackingAmountInPSL,
  burnAddress
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const amounts = {
      [burnAddress]: creditUsageTrackingAmountInPSL,
    };
    const txid = await sendMany(
      amounts,
      0,
      "Confirmation tracking transaction for inference request with request_id " +
      inferenceRequestId,
      creditUsageTrackingPSLAddress
    );
    if (txid) {
      logger.info(
        `Sent ${creditUsageTrackingAmountInPSL} PSL from ${creditUsageTrackingPSLAddress} to ${burnAddress} to confirm inference request ${inferenceRequestId}. TXID: ${txid}`
      );
      const transactionInfo = await rpc_connection.gettransaction(txid);
      if (transactionInfo) {
        return txid;
      } else {
        logger.error(
          `No transaction info found for TXID: ${txid} to confirm inference request ${inferenceRequestId}`
        );
      }
      return null;
    } else {
      logger.error(
        `Failed to send ${creditUsageTrackingAmountInPSL} PSL from ${creditUsageTrackingPSLAddress} to ${burnAddress} to confirm inference request ${inferenceRequestId}`
      );
      return null;
    }
  } catch (error) {
    logger.error(
      "Error in sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest:",
      error
    );
    throw error;
  }
}

async function importAddress(address, label = "", rescan = false) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    await rpc_connection.importaddress(address, label, rescan);
    logger.info(`Imported address: ${address}`);
  } catch (error) {
    logger.error(
      `Error importing address: ${address}. Error:`,
      safeStringify(error)
    );
  }
}

async function getBlockHash(blockHeight) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const blockHash = await rpc_connection.getblockhash(blockHeight);
    return blockHash;
  } catch (error) {
    logger.error(
      `Error in getBlockHash for block height ${blockHeight}:`,
      error
    );
    return null;
  }
}

async function getBlock(blockHash) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const block = await rpc_connection.getblock(blockHash);
    return block;
  } catch (error) {
    logger.error(
      `Error in getBlock for block hash ${blockHash}:`,
      safeStringify(error)
    );
    return null;
  }
}

async function signMessageWithPastelID(pastelid, messageToSign, passphrase) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const responseObj = await rpc_connection.pastelid(
      "sign",
      messageToSign,
      pastelid,
      passphrase,
      "ed448"
    );
    return responseObj.signature;
  } catch (error) {
    logger.error(`Error in signMessageWithPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return null;
  }
}

async function checkPSLAddressBalanceAlternative(addressToCheck) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    const addressAmountsDict = await rpc_connection.listaddressamounts();
    // Convert the object into an array of objects, each representing a row
    const data = Object.entries(addressAmountsDict).map(
      ([address, amount]) => ({ address, amount })
    );
    // Filter the array for the specified address
    const filteredData = data.filter((item) => item.address === addressToCheck);
    // Calculate the sum of the 'amount' column for the filtered array
    const balanceAtAddress = filteredData.reduce(
      (acc, item) => acc + item.amount,
      0
    );
    return balanceAtAddress;
  } catch (error) {
    logger.error(
      `Error in checkPSLAddressBalanceAlternative: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function formatNumberWithCommas(number) {
  return new Intl.NumberFormat("en-US").format(number);
}

async function getMyPslAddressWithLargestBalance() {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  try {
    const addressAmounts = await rpc_connection.listaddressamounts();
    const addressWithLargestBalance = Object.keys(addressAmounts).reduce(
      (maxAddress, currentAddress) => {
        return addressAmounts[currentAddress] >
          (addressAmounts[maxAddress] || 0)
          ? currentAddress
          : maxAddress;
      },
      null
    );
    return addressWithLargestBalance;
  } catch (error) {
    logger.error(
      `Error in getMyPslAddressWithLargestBalance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

async function createAndFundNewPSLCreditTrackingAddress(
  amountOfPSLToFundAddressWith
) {
  const isConnectionReady = await waitForRPCConnection();
  if (!isConnectionReady) {
    logger.error("RPC connection is not available. Cannot proceed.");
    return; // Stop the function if the connection is not available
  }
  const extraCushion = 1.0; // Add an extra PSL to the funding address to ensure it has a minimum balance
  try {
    const newCreditTrackingAddress = await rpc_connection.getnewaddress();
    const sendResult = await sendToAddress(
      newCreditTrackingAddress,
      amountOfPSLToFundAddressWith + extraCushion,
      "Funding new credit tracking address",
    );
    if (!sendResult.success) {
      logger.error(
        `Error funding new credit tracking address ${newCreditTrackingAddress} with ${formatNumberWithCommas(
          amountOfPSLToFundAddressWith
        )} PSL. Reason: ${sendResult.message}`
      );
      return null; // Or handle the error accordingly
    }
    logger.info(
      `Funded new credit tracking address ${newCreditTrackingAddress} with ${formatNumberWithCommas(
        amountOfPSLToFundAddressWith
      )} PSL. TXID: ${sendResult.result}`
    );
    return { newCreditTrackingAddress, txid: sendResult.result };
  } catch (error) {
    logger.error(
      `Error creating and funding new PSL credit tracking address: ${safeStringify(
        error
      )}`
    );
    throw error;
  }
}

async function waitForTableCreation() {
  const maxRetries = 5;
  const retryDelay = 1000; // 1 second
  for (let i = 0; i < maxRetries; i++) {
    try {
      await SupernodeList.findOne();
      return; // Table exists, proceed with data insertion
    } catch (error) {
      if (
        error.name === "SequelizeDatabaseError" &&
        error.original.code === "SQLITE_ERROR" &&
        error.original.errno === 1
      ) {
        // Table doesn't exist, wait and retry
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
      } else {
        throw error; // Rethrow other errors
      }
    }
  }
  throw new Error("Table creation timed out.");
}

async function checkSupernodeList() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const [
      masternodeListFull,
      masternodeListRank,
      masternodeListPubkey,
      masternodeListExtra,
    ] = await Promise.all([
      rpc_connection.masternodelist("full"),
      rpc_connection.masternodelist("rank"),
      rpc_connection.masternodelist("pubkey"),
      rpc_connection.masternodelist("extra"),
    ]);
    const masternodeListFullData = Object.entries(masternodeListFull).map(
      ([txidVout, data]) => {
        const splitData = data?.trim()?.split(/\s+/);
        return {
          txid_vout: txidVout,
          supernode_status: splitData[0],
          protocol_version: Number(splitData[1]),
          supernode_psl_address: splitData[2],
          lastseentime: Number(splitData[3]),
          activeseconds: Number(splitData[4]),
          lastpaidtime: Number(splitData[5]),
          lastpaidblock: Number(splitData[6]),
          ipaddress_port: splitData[7],
        };
      }
    );
    const masternodeListFullDF = masternodeListFullData.map((data) => {
      const rank = masternodeListRank[data.txid_vout];
      const pubkey = masternodeListPubkey[data.txid_vout];
      const extra = masternodeListExtra[data.txid_vout] || {};
      return {
        ...data,
        rank: Number(rank),
        pubkey,
        extAddress: extra.extAddress || "NA",
        extP2P: extra.extP2P || "NA",
        extKey: extra.extKey || "NA", // Fill missing extKey with "NA"
        activedays: data.activeseconds / 86400,
      };
    });
    const validMasternodeListFullDF = masternodeListFullDF.filter(
      (data) =>
        ["ENABLED", "PRE_ENABLED"].includes(data.supernode_status) &&
        data["ipaddress_port"] !== "154.38.164.75:29933" &&
        data.extP2P
    );
    if (validMasternodeListFullDF.length === 0) {
      logger.error("No valid masternodes found.");
      return;
    }
    const validationSchema = Joi.array().items(supernodeListSchema);
    const validation = validationSchema.validate(validMasternodeListFullDF);
    if (validation.error) {
      throw new Error(`Validation error: ${validation.error.message}`);
    }
    // Wait for the table to be created before inserting data
    await waitForTableCreation();

    try {
      const _ = await SupernodeList.bulkCreate(validMasternodeListFullDF, {
        updateOnDuplicate: [
          "supernode_status",
          "protocol_version",
          "supernode_psl_address",
          "lastseentime",
          "activeseconds",
          "lastpaidtime",
          "lastpaidblock",
          "ipaddress_port",
          "rank",
          "pubkey",
          "extAddress",
          "extP2P",
          "extKey",
        ],
      });
    } catch (error) {
      logger.error("Failed to insert data:", error);
    }
    const masternodeListFullDFJSON = JSON.stringify(
      Object.fromEntries(
        validMasternodeListFullDF.map((data) => [data.txid_vout, data])
      )
    );
    return { validMasternodeListFullDF, masternodeListFullDFJSON };
  } catch (error) {
    logger.error(`An error occurred: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
  }
}

async function registerPastelID(pastelid, passphrase, address) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets(
      "register",
      "id",
      pastelid,
      passphrase,
      address
    );
    logger.info(`Registered PastelID: ${pastelid}. TXID: ${result}`);
    return result;
  } catch (error) {
    logger.error(
      `Error registering PastelID: ${pastelid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listPastelIDTickets(filter = "mine", minheight = null) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    if (filter !== "mine") {
      const params = [filter];
      if (minheight !== null) {
        params.push(minheight);
      }
      const result = await rpc_connection.tickets("list", "id", ...params);
      logger.info(`Pastel ID Tickets: ${result}`);
      logger.info(`Listed PastelID tickets with filter: ${filter}`);
      return result;
    }
    // If filter is "mine", combine results from `pastelid list` and `tickets find id <PastelID>`
    const pastelIDs = await rpc_connection.pastelid("list");
    const registeredTickets = [];

    for (const pastelIDObj of pastelIDs) {
      const pastelID = pastelIDObj.PastelID;
      try {
        const ticket = await rpc_connection.tickets("find", "id", pastelID);
        if (ticket && ticket.ticket) {
          if (minheight === null || ticket.height >= minheight) {
            registeredTickets.push(ticket);
          }
        }
      } catch (error) {
        // Handle the case where the PastelID is not registered
        if (error.message.includes("ticket not found")) {
          continue;
        } else {
          throw error;
        }
      }
    }
    logger.info(`Registered Pastel ID Tickets: ${registeredTickets}`);
    logger.info(`Listed registered PastelID tickets with filter: ${filter}`);
    return registeredTickets;
  } catch (error) {
    logger.error(
      `Error listing PastelID tickets with filter: ${filter}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listPastelIDTicketsOld(filter = "mine", minheight = null) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const params = [filter];
    if (minheight !== null) {
      params.push(minheight);
    }
    const result = await rpc_connection.tickets("list", "id", ...params);
    logger.info(`Pastel ID Tickets: ${result}`);
    logger.info(`Listed PastelID tickets with filter: ${filter}`);
    return result;
  } catch (error) {
    logger.error(
      `Error listing PastelID tickets with filter: ${filter}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function findPastelIDTicket(key) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("find", "id", key);
    logger.info(`Found PastelID ticket with key: ${key}`);
    return result;
  } catch (error) {
    logger.error(
      `Error finding PastelID ticket with key: ${key}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function getPastelTicket(txid, decodeProperties = false) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("get", txid, decodeProperties);
    logger.info(`Got Pastel ticket with TXID: ${txid}`);
    return result;
  } catch (error) {
    logger.error(
      `Error getting Pastel ticket with TXID: ${txid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function listContractTickets(
  ticketTypeIdentifier,
  startingBlockHeight = 0
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets(
      "list",
      "contract",
      ticketTypeIdentifier,
      startingBlockHeight
    );
    logger.info(
      `Listed contract tickets of type ${ticketTypeIdentifier} starting from block height ${startingBlockHeight}`
    );
    return result;
  } catch (error) {
    logger.error(
      `Error listing contract tickets of type ${ticketTypeIdentifier}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function findContractTicket(key) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("find", "contract", key);
    logger.info(`Found contract ticket with key: ${key}`);
    return result;
  } catch (error) {
    logger.error(
      `Error finding contract ticket with key: ${key}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function getContractTicket(txid, decodeProperties = true) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.tickets("get", txid, decodeProperties);
    if (result && result.ticket && result.ticket.contract_ticket) {
      logger.info(`Got contract ticket with TXID: ${txid}`);
      return result.ticket.contract_ticket;
    } else {
      logger.error(`Error getting contract ticket with TXID: ${txid}`);
      return null;
    }
  } catch (error) {
    logger.error(
      `Error getting contract ticket with TXID: ${txid}. Error:`,
      safeStringify(error)
    );
    throw error;
  }
}

async function importPrivKey(zcashPrivKey, label = "", rescan = true) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.importprivkey(
      zcashPrivKey,
      label,
      rescan
    );
    logger.info(`Imported private key with label: ${label}`);
    return result;
  } catch (error) {
    logger.error(`Error importing private key: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function importWallet(filename) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.importwallet(filename);
    logger.info(`Imported wallet from file: ${filename}`);
    return result;
  } catch (error) {
    logger.error(`Error importing wallet: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function listAddressAmounts(includeEmpty = false, isMineFilter = "all") {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.listaddressamounts(
      includeEmpty,
      isMineFilter
    );
    logger.info(
      `Listed address amounts with includeEmpty: ${includeEmpty} and isMineFilter: ${isMineFilter}`
    );
    return result;
  } catch (error) {
    logger.error(`Error listing address amounts: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getBalance() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getbalance();
    return result;
  } catch (error) {
    logger.error(`Error getting balance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getWalletInfo() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getwalletinfo();
    logger.info("Got wallet info");
    return result;
  } catch (error) {
    logger.error(`Error getting wallet info: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function getNewAddress() {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return;
    }
    const result = await rpc_connection.getnewaddress();
    logger.info("Got new Pastel address");
    return result;
  } catch (error) {
    logger.error(`Error getting new address: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

async function checkForRegisteredPastelID() {
  try {
    const { rpchost, rpcport, rpcuser, rpcpassword } = getLocalRPCSettings();
    logger.info(
      `RPC settings: host=${rpchost}, port=${rpcport}, user=${rpcuser}, password=${rpcpassword}`
    );
    const { network, burnAddress } = getNetworkInfo(rpcport);
    logger.info(`Network: ${network}, Burn Address: ${burnAddress}`);
    const pastelIDDir = getPastelIDDirectory(network);
    logger.info(`Pastel ID directory: ${pastelIDDir}`);
    const pastelIDs = await getPastelIDsFromDirectory(pastelIDDir);
    logger.info(`Found Pastel IDs: ${pastelIDs}`);
    for (const pastelID of pastelIDs) {
      const isRegistered = await isPastelIDRegistered(pastelID);
      logger.info(`Pastel ID ${pastelID} is registered: ${isRegistered}`);
      if (isRegistered) {
        logger.info(`Found registered Pastel ID: ${pastelID}`);
        return pastelID;
      }
    }
    logger.info("No registered Pastel ID found.");
    return null;
  } catch (error) {
    logger.error(
      `Error in checkForRegisteredPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

function getNetworkInfo(rpcport) {
  let network = "";
  let burnAddress = "";
  if (rpcport === "9932") {
    network = "mainnet";
    burnAddress = "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
  } else if (rpcport === "19932") {
    network = "testnet";
    burnAddress = "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
  } else if (rpcport === "29932") {
    network = "devnet";
    burnAddress = "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
  } else {
    throw new Error(`Unknown RPC port: ${rpcport}`);
  }
  return { network, burnAddress };
}

function getPastelIDDirectory(network) {
  const homeDir = process.env.HOME;
  let pastelIDDir = "";
  if (network === "mainnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "pastelkeys");
  } else if (network === "testnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "testnet3", "pastelkeys");
  } else if (network === "devnet") {
    pastelIDDir = path.join(homeDir, ".pastel", "devnet3", "pastelkeys");
  }
  return pastelIDDir;
}

async function getPastelIDsFromDirectory(directory) {
  const files = await fs.promises.readdir(directory);
  const pastelIDs = files.filter((file) => file.length === 87);
  return pastelIDs;
}

async function isPastelIDRegistered(pastelID) {
  try {
    const ticketFindResult = await rpc_connection.tickets(
      "find",
      "id",
      pastelID
    );
    return !!ticketFindResult?.ticket?.pastelID;
  } catch (error) {
    logger.error(
      `Error checking if Pastel ID is registered: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return false;
  }
}

async function promptUserConfirmation(message) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise((resolve) => {
    rl.question(message + " ", (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

async function createAndRegisterPastelID(burnAddress) {
  try {
    const newPastelIDResult = await rpc_connection.pastelid("newkey");
    const newPastelID = newPastelIDResult.pastelid;
    const passphrase = newPastelIDResult.passphrase;
    const address = await rpc_connection.getnewaddress();
    const registrationResult = await registerPastelID(
      newPastelID,
      passphrase,
      address
    );
    if (registrationResult) {
      return newPastelID;
    } else {
      throw new Error("Failed to register new Pastel ID");
    }
  } catch (error) {
    logger.error(
      `Error creating and registering Pastel ID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    throw error;
  }
}

async function createAndRegisterNewPastelID(passphraseForNewPastelID) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return { success: false, message: "RPC connection is not available." };
    }
    let addressAmounts = await rpc_connection.listaddressamounts();
    const registrationFee = 1000;
    const transactionFee = 0.1;
    const requiredBalance = registrationFee + transactionFee;
    let fundingAddress = Object.keys(addressAmounts).find(
      (addr) => addressAmounts[addr] >= requiredBalance
    );
    if (!fundingAddress) {
      const newAddress = await getNewAddress();
      return {
        success: false,
        message: `Error: You do not have enough PSL in your wallet in a single address to register a new PastelID. Get some PSL (either from mining, buying on an exchange, a faucet, etc.) and then send at least 1,001 PSL of it to the following new PSL address which has been created for you: ${newAddress}`,
      };
    }
    const newPastelIDResult = await rpc_connection.pastelid(
      "newkey",
      passphraseForNewPastelID
    );
    const newPastelID = newPastelIDResult.pastelid;
    await setPastelIdAndPassphrase(newPastelID, passphraseForNewPastelID);

    addressAmounts = await rpc_connection.listaddressamounts();
    fundingAddress = Object.keys(addressAmounts).find(
      (addr) => addressAmounts[addr] >= registrationFee
    );
    if (!fundingAddress) {
      return {
        success: false,
        message:
          "Error: No address found with enough PSL to register a new PastelID.",
      };
    }
    const registerResult = await rpc_connection.tickets(
      "register",
      "id",
      newPastelID,
      passphraseForNewPastelID,
      fundingAddress
    );
    return {
      success: true,
      PastelID: newPastelID,
      PastelIDRegistrationTXID: registerResult.txid,
    };
  } catch (error) {
    logger.error(
      `Error in createAndRegisterNewPastelID: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return { success: false, message: error.message };
  }
}

async function isCreditPackConfirmed(txid) {
  try {
    const ticket = await getPastelTicket(txid);
    return ticket && ticket.height > 0;
  } catch (error) {
    logger.error(
      `Error checking if credit pack is confirmed: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
    );
    return false;
  }
}

async function ensureTrackingAddressesHaveMinimalPSLBalance(
  addressesList = null
) {
  try {
    const isConnectionReady = await waitForRPCConnection();
    if (!isConnectionReady) {
      logger.error("RPC connection is not available. Cannot proceed.");
      return; // Stop the function if the connection is not available
    }
    let addresses = addressesList;
    if (!addresses) {
      // If no address list is provided, retrieve all addresses and their balances
      addresses = Object.keys(await rpc_connection.listaddressamounts());
    }

    // Get the address with the largest balance to use for sending PSL if needed
    const fundingAddress = await getMyPslAddressWithLargestBalance();
    if (!fundingAddress) {
      logger.error("No address with sufficient funds to fund other addresses.");
      return; // No address has sufficient funds
    }

    for (const address of addresses) {
      const balance = await checkPSLAddressBalance(address); // Get balance for each address
      if (balance < 1.0) {
        // If balance is less than 1.0 PSL, send the needed amount
        const amountNeeded = Math.round((1.0 - balance) * 10000) / 10000;
        if (amountNeeded > 0.0001) {
          const sendResult = await sendToAddress(
            address,
            amountNeeded,
            "Balancing PSL amount to ensure tracking address has a minimum balance of 1 PSL",
          );
          if (sendResult.success) {
            logger.info(
              `Sent ${amountNeeded} PSL from address ${fundingAddress} to address ${address} to maintain minimum balance. TXID: ${sendResult.result}`
            );
          } else {
            logger.error(
              `Failed to send PSL from address ${fundingAddress} to address ${address}: ${sendResult.message}`
            );
          }
        }
      }
    }
  } catch (error) {
    logger.error(
      `Error in ensureTrackingAddressesHaveMinimalPSLBalance: ${safeStringify(
        error
      )}`
    );
    throw error;
  }
}

module.exports = {
  safeStringify,
  getLocalRPCSettings,
  JSONRPCException,
  AsyncAuthServiceProxy,
  initializeRPCConnection,
  waitForRPCConnection,
  checkMasternodeTop,
  getCurrentPastelBlockHeight,
  getBestBlockHashAndMerkleRoot,
  verifyMessageWithPastelID,
  sendToAddress,
  sendMany,
  checkPSLAddressBalance,
  checkIfAddressIsAlreadyImportedInLocalWallet,
  getAndDecodeRawTransaction,
  getTransactionDetails,
  sendTrackingAmountFromControlAddressToBurnAddressToConfirmInferenceRequest,
  importAddress,
  getBlockHash,
  getBlock,
  signMessageWithPastelID,
  checkPSLAddressBalanceAlternative,
  createAndFundNewPSLCreditTrackingAddress,
  checkSupernodeList,
  checkForRegisteredPastelID,
  getLocalRPCSettings,
  getNetworkInfo,
  getPastelIDDirectory,
  getPastelIDsFromDirectory,
  isPastelIDRegistered,
  promptUserConfirmation,
  createAndRegisterPastelID,
  createAndRegisterNewPastelID,
  getBalance,
  getWalletInfo,
  getNewAddress,
  listAddressAmounts,
  getPastelTicket,
  listPastelIDTickets,
  findPastelIDTicket,
  getPastelTicket,
  listContractTickets,
  findContractTicket,
  getContractTicket,
  importPrivKey,
  importWallet,
  registerPastelID,
  rpc_connection,
  stopPastelDaemon,
  startPastelDaemon,
  getMyPslAddressWithLargestBalance,
  isCreditPackConfirmed,
  ensureTrackingAddressesHaveMinimalPSLBalance,
};


---
./sequelize_data_models.js
---
require("dotenv").config();
const { Sequelize, DataTypes } = require("sequelize");

// SQLite database in project root directory
const sequelize = new Sequelize({
  dialect: "sqlite",
  storage: "pastel_inference_client.sqlite", // Path to the database file
  logging: false, // Disable logging; default: console.log
});

sequelize
  .authenticate()
  .then(() => console.log("Connection has been established successfully."))
  .catch((err) => console.error("Unable to connect to the database:", err));

const SupernodeList = sequelize.define(
  "SupernodeList",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    supernode_status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    protocol_version: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    supernode_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    lastseentime: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    activeseconds: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    activedays: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    lastpaidtime: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    lastpaidblock: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    ipaddress_port: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rank: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    pubkey: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extAddress: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extP2P: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    extKey: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "supernode_lists",
    timestamps: false,
  }
);

const Message = sequelize.define(
  "Message",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sending_sn_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    receiving_sn_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sending_sn_txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    receiving_sn_txid_vout: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_type: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_body: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    signature: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    timestamp: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal("CURRENT_TIMESTAMP"),
    },
  },
  {
    tableName: "messages",
    timestamps: false,
  }
);

const UserMessage = sequelize.define(
  "UserMessage",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    from_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    to_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    message_body: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    message_signature: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    timestamp: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal("CURRENT_TIMESTAMP"),
    },
  },
  {
    tableName: "user_messages",
    timestamps: false,
  }
);

const CreditPackPurchaseRequest = sequelize.define(
  "CreditPackPurchaseRequest",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requested_initial_credits_in_credit_pack: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    list_of_authorized_pastelids_allowed_to_use_credit_pack: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    requesting_end_user_pastelid_signature_on_request_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "credit_pack_purchase_requests",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestRejection = sequelize.define(
  "CreditPackPurchaseRequestRejection",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_reason_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    rejection_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_rejection_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_rejection_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_rejection_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_rejections",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestPreliminaryPriceQuote = sequelize.define(
  "CreditPackPurchaseRequestPreliminaryPriceQuote",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_quoted_price_per_credit_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_total_cost_of_credit_pack_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_price_quote_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_price_quote_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    preliminary_price_quote_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    responding_supernode_signature_on_credit_pack_purchase_request_preliminary_price_quote_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_preliminary_price_quotes",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestPreliminaryPriceQuoteResponse = sequelize.define(
  "CreditPackPurchaseRequestPreliminaryPriceQuoteResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    agree_with_preliminary_price_quote: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_quoted_price_per_credit_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    preliminary_price_quote_response_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    preliminary_price_quote_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    preliminary_price_quote_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
    requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_preliminary_price_quote_responses",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestResponseTermination = sequelize.define(
  "CreditPackPurchaseRequestResponseTermination",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_reason_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    termination_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_termination_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_termination_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_termination_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_response_terminations",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestResponse = sequelize.define(
  "CreditPackPurchaseRequestResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    psl_cost_per_credit: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    proposed_total_cost_of_credit_pack_in_psl: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_response_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    best_block_merkle_root: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    best_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    list_of_blacklisted_supernode_pastelids: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_potentially_agreeing_supernodes: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion:
      {
        type: DataTypes.JSON,
        allowNull: false,
      },
    selected_agreeing_supernodes_signatures_dict: {
      type: DataTypes.JSON,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_responses",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestConfirmation = sequelize.define(
  "CreditPackPurchaseRequestConfirmation",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_responses",
        key: "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
      },
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    txid_of_credit_purchase_burn_transaction: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_confirmation_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_confirmations",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestConfirmationResponse = sequelize.define(
  "CreditPackPurchaseRequestConfirmationResponse",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_confirmations",
        key: "sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields",
      },
    },
    credit_pack_confirmation_outcome_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    pastel_api_credit_pack_ticket_registration_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_confirmation_failure_reason_if_applicable: {
      type: DataTypes.STRING,
      allowNull: true,
      defaultValue: "",
    },
    credit_purchase_request_confirmation_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_purchase_request_confirmation_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_confirmation_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
      },
    responding_supernode_signature_on_credit_pack_purchase_request_confirmation_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_confirmation_responses",
    timestamps: false,
  }
);

const CreditPackRequestStatusCheck = sequelize.define(
  "CreditPackRequestStatusCheck",
  {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_request_status_checks",
    timestamps: false,
  }
);

const CreditPackPurchaseRequestStatus = sequelize.define(
  "CreditPackPurchaseRequestStatus",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_requests",
        key: "sha3_256_hash_of_credit_pack_purchase_request_fields",
      },
    },
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "credit_pack_purchase_request_responses",
        key: "sha3_256_hash_of_credit_pack_purchase_request_response_fields",
      },
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_details: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_update_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    status_update_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_purchase_request_status_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_status_fields: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    responding_supernode_signature_on_credit_pack_purchase_request_status_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_purchase_request_statuses",
    timestamps: false,
  }
);

const CreditPackStorageRetryRequest = sequelize.define(
  "CreditPackStorageRetryRequest",
  {
    sha3_256_hash_of_credit_pack_purchase_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_purchase_request_fields_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_request_timestamp_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_pack_storage_retry_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_storage_retry_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_storage_retry_requests",
    timestamps: false,
  }
);

const CreditPackStorageRetryRequestResponse = sequelize.define(
  "CreditPackStorageRetryRequestResponse",
  {
    sha3_256_hash_of_credit_pack_purchase_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_outcome_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    pastel_api_credit_pack_ticket_registration_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_failure_reason_if_applicable: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    credit_pack_storage_retry_confirmation_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_credit_pack_storage_retry_confirmation_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    closest_agreeing_supernode_to_retry_storage_pastelid_signature_on_credit_pack_storage_retry_confirmation_response_hash:
      {
        type: DataTypes.STRING,
        allowNull: false,
      },
  },
  {
    tableName: "credit_pack_storage_retry_request_responses",
    timestamps: false,
  }
);

const InferenceAPIUsageRequest = sequelize.define(
  "InferenceAPIUsageRequest",
  {
    inference_request_id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: DataTypes.UUIDV4,
    },
    requesting_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    credit_pack_ticket_pastel_txid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requested_model_canonical_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_inference_type_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_parameters_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    model_input_data_json_b64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_request_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_pastelid_signature_on_request_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_usage_requests",
    timestamps: false,
  }
);

const InferenceAPIUsageResponse = sequelize.define(
  "InferenceAPIUsageResponse",
  {
    inference_response_id: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_requests",
        key: "inference_request_id",
      },
    },
    proposed_cost_of_request_in_inference_credits: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    remaining_credits_in_pack_after_request_processed: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    credit_usage_tracking_psl_address: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    request_confirmation_message_amount_in_patoshis: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    max_block_height_to_include_confirmation_transaction: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_request_response_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_request_response_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_request_response_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_request_response_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    supernode_pastelid_and_signature_on_inference_request_response_hash: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_usage_responses",
    timestamps: false,
  }
);

const InferenceAPIOutputResult = sequelize.define(
  "InferenceAPIOutputResult",
  {
    inference_result_id: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_requests",
        key: "inference_request_id",
      },
    },
    inference_response_id: {
      type: DataTypes.STRING,
      allowNull: false,
      references: {
        model: "inference_api_usage_responses",
        key: "inference_response_id",
      },
    },
    responding_supernode_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_json_base64: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_file_type_strings: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_utc_iso_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    inference_result_pastel_block_height: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    inference_result_message_version_string: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    sha3_256_hash_of_inference_result_fields: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    responding_supernode_signature_on_inference_result_id: {
      type: DataTypes.STRING,
      allowNull: false,
    },
  },
  {
    tableName: "inference_api_output_results",
    timestamps: false,
  }
);

const InferenceConfirmation = sequelize.define(
  "InferenceConfirmation",
  {
    inference_request_id: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    requesting_pastelid: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    confirmation_transaction: {
      type: DataTypes.JSON,
      allowNull: false,
    },
  },
  {
    tableName: "inference_confirmations",
    timestamps: false,
  }
);

// Sync all defined models to the DB
sequelize.sync({ force: true }).then(() => {
  console.log("Database & tables created!");
});

module.exports = {
  SupernodeList,
  Message,
  UserMessage,
  CreditPackPurchaseRequest,
  CreditPackPurchaseRequestRejection,
  CreditPackPurchaseRequestPreliminaryPriceQuote,
  CreditPackPurchaseRequestPreliminaryPriceQuoteResponse,
  CreditPackPurchaseRequestResponseTermination,
  CreditPackPurchaseRequestResponse,
  CreditPackPurchaseRequestConfirmation,
  CreditPackPurchaseRequestConfirmationResponse,
  CreditPackRequestStatusCheck,
  CreditPackPurchaseRequestStatus,
  CreditPackStorageRetryRequest,
  CreditPackStorageRetryRequestResponse,
  InferenceAPIUsageRequest,
  InferenceAPIUsageResponse,
  InferenceAPIOutputResult,
  InferenceConfirmation,
};


---
./server.js
---
// server.js

const express = require("express");
const multer = require("multer");
const bodyParser = require("body-parser");
const WebSocket = require("ws");
const os = require("os");
const path = require("path");
const fs = require("fs");
const {
  getCurrentPastelIdAndPassphrase,
  setPastelIdAndPassphrase,
} = require("./storage");
const { PastelInferenceClient } = require("./pastel_inference_client");

const {
  checkForNewIncomingMessages,
  sendMessageAndCheckForNewIncomingMessages,
  handleCreditPackTicketEndToEnd,
  getCreditPackTicketInfoEndToEnd,
  getMyValidCreditPackTicketsEndToEnd,
  handleInferenceRequestEndToEnd,
  estimateCreditPackCostEndToEnd,
} = require("./end_to_end_functions");
const {
  getLocalRPCSettings,
  getNetworkInfo,
  initializeRPCConnection,
  createAndFundNewPSLCreditTrackingAddress,
  checkSupernodeList,
  registerPastelID,
  listPastelIDTickets,
  findPastelIDTicket,
  getPastelTicket,
  listContractTickets,
  findContractTicket,
  getContractTicket,
  importPrivKey,
  importWallet,
  listAddressAmounts,
  getBalance,
  getWalletInfo,
  getNewAddress,
  checkForRegisteredPastelID,
  createAndRegisterNewPastelID,
  stopPastelDaemon,
  startPastelDaemon,
  getMyPslAddressWithLargestBalance,
  isPastelIDRegistered,
  isCreditPackConfirmed,
  ensureTrackingAddressesHaveMinimalPSLBalance,
} = require("./rpc_functions");
const { logger, logEmitter, logBuffer, safeStringify } = require("./logger");
const {
  prettyJSON,
  getClosestSupernodeToPastelIDURL,
  getNClosestSupernodesToPastelIDURLs,
} = require("./utility_functions");
const globals = require("./globals");
let MY_LOCAL_PASTELID = "";
let MY_PASTELID_PASSPHRASE = "";

const app = express();
app.use(bodyParser.urlencoded({ extended: true, limit: "50mb" }));
app.use(bodyParser.json({ limit: "50mb" }));
const upload = multer({ dest: "uploads/" });

const port = process.env.CLIENT_PORT || 3100;
const webSocketPort = process.env.CLIENT_WEBSOCKET_PORT || 3101;

const wss = new WebSocket.Server({ port: webSocketPort }, () => {
  console.log(`WebSocket server started on port ${webSocketPort}`);
});

function getServerIpAddress() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === "IPv4" && !iface.internal) {
        return iface.address;
      }
    }
  }
  return "localhost";
}

app.get("/ws-url", (req, res) => {
  const ipAddress = getServerIpAddress();
  const wsUrl = `ws://${ipAddress}:${webSocketPort}`;
  res.json({ wsUrl });
});

wss.on("connection", (ws) => {
  logger.info(`Client connected: ${ws}`);

  logBuffer.forEach((logEntry) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(logEntry);
    }
  });

  const logListener = (logEntry) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(logEntry);
    }
  };
  logEmitter.on("newLog", logListener);

  ws.on("message", (message) => {
    logger.info(`Received message from client: ${message}`);
  });

  ws.on("close", (code, reason) => {
    logger.info(`Client disconnected; code: ${code}, reason: ${reason}`);
    logEmitter.removeListener("newLog", logListener);
  });

  ws.on("error", (error) => {
    logger.error(`WebSocket error: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    logEmitter.removeListener("newLog", logListener);
  });
});

async function initializeServer() {
  try {
    const { pastelID, passphrase } = await getCurrentPastelIdAndPassphrase();
    if (pastelID && passphrase) {
      // Set global variables
      globals.setPastelIdAndPassphrase(pastelID, passphrase);

      // Set local variables
      MY_LOCAL_PASTELID = pastelID;
      MY_PASTELID_PASSPHRASE = passphrase;

      logger.info(`Successfully set global and local PastelID`);
    } else {
      logger.warn(
        `Failed to set global and local PastelID and passphrase from storage`
      );
    }

    // Rest of your server initialization code...
  } catch (error) {
    logger.error(`Error initializing server: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    process.exit(1);
  }
}

let rpcport;
let network;

(async () => {
  try {
    await initializeRPCConnection();
    await initializeServer();
    const rpcSettings = await getLocalRPCSettings();
    rpcport = rpcSettings.rpcport;
    network = getNetworkInfo(rpcport).network;

    const { pastelID, passphrase } = await getCurrentPastelIdAndPassphrase();
    if (pastelID && passphrase) {
      MY_LOCAL_PASTELID = pastelID;
      MY_PASTELID_PASSPHRASE = passphrase;
      logger.info(`Successfully set global PastelID`);
    } else {
      logger.warn(`Failed to set global PastelID and passphrase from storage`);
    }

    const { validMasternodeListFullDF } = await checkSupernodeList();
    if (!validMasternodeListFullDF) {
      throw new Error(
        "The Pastel Daemon is not fully synced, and thus the Supernode information commands are not returning complete information. Finish fully syncing and try again."
      );
    }

    let supernodeURL;
    if (MY_LOCAL_PASTELID !== "") {
      const result = await getClosestSupernodeToPastelIDURL(
        MY_LOCAL_PASTELID,
        validMasternodeListFullDF
      );
      if (result) {
        supernodeURL = result.url;
      }
    }

    async function configureRPCAndSetBurnAddress() {
      try {
        let burnAddress;
        if (rpcport === "9932") {
          burnAddress = "PtpasteLBurnAddressXXXXXXXXXXbJ5ndd";
        } else if (rpcport === "19932") {
          burnAddress = "tPpasteLBurnAddressXXXXXXXXXXX3wy7u";
        } else if (rpcport === "29932") {
          burnAddress = "44oUgmZSL997veFEQDq569wv5tsT6KXf9QY7";
        } else {
          throw new Error(`Unsupported RPC port: ${rpcport}`);
        }
        return burnAddress;
      } catch (error) {
        console.error("Failed to configure RPC or set burn address:", error);
        throw error;
      }
    }

    app.get("/", (req, res) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });

    app.get("/favicon.ico", (req, res) => {
      res.sendFile(path.join(__dirname, "favicon.ico"));
    });

    app.get("/get-network-info", async (req, res) => {
      try {
        res.json({ network });
      } catch (error) {
        console.error("Error getting network info:", error);
        res
          .status(500)
          .json({ success: false, message: "Failed to get network info" });
      }
    });

    app.get("/get-best-supernode-url", async (req, res) => {
      try {
        const userPastelID = req.query.userPastelID;
        const supernodeListDF = await checkSupernodeList();
        const { url: supernodeURL } = await getClosestSupernodeToPastelIDURL(
          userPastelID,
          supernodeListDF.validMasternodeListFullDF
        );
        if (!supernodeURL) {
          throw new Error("No valid supernode URL found.");
        }
        res.json({ success: true, supernodeURL });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-inference-model-menu", async (req, res) => {
      try {
        if (!MY_LOCAL_PASTELID || !MY_PASTELID_PASSPHRASE) {
          return res.status(400).json({
            success: false,
            message: "Pastel ID and passphrase not set.",
          });
        }
        const pastelInferenceClient = new PastelInferenceClient(
          MY_LOCAL_PASTELID,
          MY_PASTELID_PASSPHRASE
        );
        const modelMenu = await pastelInferenceClient.getModelMenu();
        res.json({ success: true, modelMenu });
      } catch (error) {
        logger.error(`Error in getInferenceModelMenu: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/estimate-credit-pack-cost", async (req, res) => {
      const { desiredNumberOfCredits, creditPriceCushionPercentage } = req.body;
      try {
        const result = await estimateCreditPackCostEndToEnd(
          desiredNumberOfCredits,
          creditPriceCushionPercentage
        );
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/send-message", async (req, res) => {
      const { toPastelID, messageBody } = req.body;
      try {
        const messageDict = await sendMessageAndCheckForNewIncomingMessages(
          toPastelID,
          messageBody
        );
        res.json({ success: true, messageDict });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-received-messages", async (req, res) => {
      try {
        const messageDict = await checkForNewIncomingMessages();
        res.json({ success: true, messageDict });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-credit-pack-ticket", async (req, res) => {
      const burnAddress = await configureRPCAndSetBurnAddress();
      const {
        numCredits,
        creditUsageTrackingPSLAddress,
        maxTotalPrice,
        maxPerCreditPrice,
      } = req.body;
      try {
        const result = await handleCreditPackTicketEndToEnd(
          numCredits,
          creditUsageTrackingPSLAddress,
          burnAddress,
          maxTotalPrice,
          maxPerCreditPrice
        );
        res.json({ success: true, result });
      } catch (error) {
        console.error("Error in create-credit-pack-ticket:", error);
        res.status(500).json({
          success: false,
          error: error.message,
          details: error.details || "No additional details available",
        });
      }
    });

    app.get("/credit-pack-info/:txid", async (req, res) => {
      const { txid } = req.params;
      try {
        const result = await getCreditPackTicketInfoEndToEnd(txid);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-my-valid-credit-packs", async (req, res) => {
      try {
        const result = await getMyValidCreditPackTicketsEndToEnd();
        res.json({ success: true, result: result || [] });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-my-psl-address-with-largest-balance", async (req, res) => {
      try {
        const result = await getMyPslAddressWithLargestBalance();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-inference-request", async (req, res) => {
      const {
        model_inference_type_string: modelInferenceTypeString,
        model_parameters_json_b64,
        model_input_data_json_b64,
        selectedCreditPackTicketId: creditPackTicketPastelTxid,
        maxCost: maximumInferenceCostInCredits,
        model_canonical_name: requestedModelCanonicalString,
      } = req.body;
      try {
        const burnAddress = await configureRPCAndSetBurnAddress();
        const modelParameters = JSON.parse(
          Buffer.from(model_parameters_json_b64, "base64").toString()
        );
        const modelInputData = JSON.parse(
          Buffer.from(model_input_data_json_b64, "base64").toString()
        );
        console.log(`Model Inference Type: ${modelInferenceTypeString}`);
        const result = await handleInferenceRequestEndToEnd(
          creditPackTicketPastelTxid,
          modelInputData,
          requestedModelCanonicalString,
          modelInferenceTypeString,
          modelParameters,
          maximumInferenceCostInCredits,
          burnAddress
        );
        res.json({ success: true, result });
      } catch (error) {
        console.error("Error in create-inference-request:", error);
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/check-supernode-list", async (req, res) => {
      try {
        const { validMasternodeListFullDF } = await checkSupernodeList();
        res.json({ success: true, result: { validMasternodeListFullDF } });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/register-pastel-id", async (req, res) => {
      const { pastelid, passphrase, address } = req.body;
      try {
        const result = await registerPastelID(pastelid, passphrase, address);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-pastel-id-tickets", async (req, res) => {
      const { filter, minheight } = req.query;
      try {
        const result = await listPastelIDTickets(filter, minheight);
        console.log("Pastel ID Tickets:", result);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/find-pastel-id-ticket/:key", async (req, res) => {
      const { key } = req.params;
      try {
        const result = await findPastelIDTicket(key);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-pastel-ticket/:txid", async (req, res) => {
      const { txid } = req.params;
      const { decodeProperties } = req.query;
      try {
        const result = await getPastelTicket(txid, decodeProperties);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-contract-tickets", async (req, res) => {
      const { ticketTypeIdentifier, startingBlockHeight } = req.query;
      try {
        const result = await listContractTickets(
          ticketTypeIdentifier,
          startingBlockHeight
        );
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/find-contract-ticket/:key", async (req, res) => {
      const { key } = req.params;
      try {
        const result = await findContractTicket(key);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-contract-ticket/:txid", async (req, res) => {
      const { txid } = req.params;
      const { decodeProperties } = req.query;
      try {
        const result = await getContractTicket(txid, decodeProperties);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/import-priv-key", async (req, res) => {
      const { zcashPrivKey, label, rescan } = req.body;
      try {
        const result = await importPrivKey(zcashPrivKey, label, rescan);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/import-wallet", async (req, res) => {
      const { filename } = req.body;
      try {
        const result = await importWallet(filename);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/list-address-amounts", async (req, res) => {
      const { includeEmpty, isMineFilter } = req.query;
      try {
        const result = await listAddressAmounts(includeEmpty, isMineFilter);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-balance", async (req, res) => {
      try {
        const result = await getBalance();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/get-wallet-info", async (req, res) => {
      try {
        const result = await getWalletInfo();
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/create-and-fund-new-address", async (req, res) => {
      try {
        const { amount } = req.body;
        const result = await createAndFundNewPSLCreditTrackingAddress(amount);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post("/check-for-pastel-id", async (req, res) => {
      const { autoRegister } = req.body;
      try {
        const result = await checkForRegisteredPastelID(autoRegister);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post(
      "/import-pastel-id",
      upload.single("pastelIDFile"),
      async (req, res) => {
        try {
          const destFolder = getNetworkSpecificDestFolder(network);
          fs.mkdirSync(destFolder, { recursive: true });
          const sourceFilePath = req.file.path;
          const destFilePath = path.join(destFolder, req.file.originalname);
          fs.renameSync(sourceFilePath, destFilePath);

          await stopPastelDaemon();
          await startPastelDaemon();

          res.json({
            success: true,
            message: "PastelID imported successfully!",
          });
        } catch (error) {
          console.error("Error importing PastelID:", error);
          res
            .status(500)
            .json({ success: false, message: "Failed to import PastelID." });
        }
      }
    );

    app.get("/credit-pack-status/:txid", async (req, res) => {
      try {
        const txid = req.params.txid;
        const confirmed = await isCreditPackConfirmed(txid);
        res.json({ confirmed });
      } catch (error) {
        console.error("Error checking credit pack status:", error);
        res.status(500).json({ error: "Failed to check credit pack status" });
      }
    });

    app.post("/create-and-register-pastel-id", async (req, res) => {
      const { passphraseForNewPastelID } = req.body;
      try {
        const result = await createAndRegisterNewPastelID(
          passphraseForNewPastelID
        );
        if (result.success) {
          res.json({
            success: true,
            PastelID: result.PastelID,
            PastelIDRegistrationTXID: result.PastelIDRegistrationTXID,
          });
        } else {
          res.json({ success: false, message: result.message });
        }
      } catch (error) {
        logger.error(
          `Error in create-and-register-pastel-id: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        res.status(500).json({ success: false, message: error.message });
      }
    });

    app.get("/check-pastel-id-status/:pastelID", async (req, res) => {
      try {
        const pastelID = req.params.pastelID;
        const isRegistered = await isPastelIDRegistered(pastelID);
        res.json({ registered: isRegistered });
      } catch (error) {
        console.error("Error checking PastelID status:", error);
        res.status(500).json({ error: "Failed to check PastelID status" });
      }
    });

    app.post("/set-pastel-id-passphrase", async (req, res) => {
      const { pastelID, passphrase } = req.body;
      try {
        // Check if the PastelID is valid
        const isValid = await isPastelIDRegistered(pastelID);

        if (!isValid) {
          // If not valid, send a response indicating that the PastelID is invalid
          return res.json({ success: false, message: "Invalid PastelID" });
        }

        // If valid, proceed with updating storage and global variables
        await setPastelIdAndPassphrase(pastelID, passphrase);
        globals.setPastelIdAndPassphrase(pastelID, passphrase);
        MY_LOCAL_PASTELID = pastelID;
        MY_PASTELID_PASSPHRASE = passphrase;

        res.json({ success: true });
        app.emit("pastelIDAndPassphraseSet");
      } catch (error) {
        console.error("Error setting PastelID and passphrase:", error);
        res.status(500).json({
          success: false,
          message: "Failed to set PastelID and passphrase",
        });
      }
    });

    app.post("/ensure-minimal-psl-balance", async (req, res) => {
      try {
        const { addresses } = req.body; // Expects a JSON body with an "addresses" array
        await ensureTrackingAddressesHaveMinimalPSLBalance(addresses);
        res.json({
          success: true,
          message: "Balance check and update process initiated.",
        });
      } catch (error) {
        logger.error(
          `Error in ensuring minimal PSL balance: ${safeStringify(error).slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`
        );
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.get("/ensure-minimal-psl-balance", async (req, res) => {
      try {
        await ensureTrackingAddressesHaveMinimalPSLBalance();
        res.json({
          success: true,
          message:
            "Balance check and update process initiated for all addresses.",
        });
      } catch (error) {
        logger.error(
          `Error in ensuring minimal PSL balance for all addresses: ${safeStringify(
            error
          )}`
        );
        res.status(500).json({ success: false, error: error.message });
      }
    });

    app.post('/check-pastel-id-validity', async (req, res) => {
      try {
        const { pastelID } = req.body;
        const isValid = await isPastelIDRegistered(pastelID);
        res.json({ isValid });
      } catch (error) {
        console.error("Error checking PastelID validity:", error);
        res.status(500).json({ error: "Failed to check PastelID validity" });
      }
    });

    app.listen(port, () => {
      console.log(`Server running at http://localhost:${port}`);
    });
  } catch (error) {
    console.error("Error initializing server:", error);
    process.exit(1);
  }
})();

function getNetworkSpecificDestFolder(network) {
  if (network === "mainnet") {
    return path.join(process.env.HOME, ".pastel/pastelkeys");
  } else if (network === "testnet") {
    return path.join(process.env.HOME, ".pastel/testnet/pastelkeys");
  } else if (network === "devnet") {
    return path.join(process.env.HOME, ".pastel/devnet/pastelkeys");
  } else {
    throw new Error(`Unknown network: ${network}`);
  }
}


---
./set_node_memory_limit.sh
---
#!/bin/bash

# Memory limit to set (in MB)
MEMORY_LIMIT=4096

# The alias command to set the Node.js memory limit
ALIAS_COMMAND="alias node=\"node --max-old-space-size=${MEMORY_LIMIT}\""

# Check if the alias is already in the .zshrc file
if grep -q "alias node=" ~/.zshrc; then
    echo "Updating existing Node.js memory limit alias in .zshrc"
    sed -i.bak "s/alias node=.*/$ALIAS_COMMAND/" ~/.zshrc
else
    echo "Adding Node.js memory limit alias to .zshrc"
    echo "$ALIAS_COMMAND" >> ~/.zshrc
fi

echo "Node.js memory limit set to ${MEMORY_LIMIT} MB globally for zsh."
echo "Please run 'source ~/.zshrc' in your zsh session to apply the changes."


---


---
./storage.js
---
const storage = require("node-persist");
const { logger } = require("./logger");
const globals = require("./globals");

let storageInitialized = false;

async function initializeStorage() {
  if (!storageInitialized) {
    try {
      await storage.init({ logging: false });
      logger.info("Storage initialized successfully");
      storageInitialized = true;
    } catch (error) {
      logger.error(`Error initializing storage: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      throw error;
    }
  }
}

async function getCurrentPastelIdAndPassphrase() {
  try {
    await initializeStorage();
    const pastelID = await storage.getItem("MY_LOCAL_PASTELID");
    const passphrase = await storage.getItem("MY_PASTELID_PASSPHRASE");

    if (!pastelID || !passphrase) {
      logger.warn("PastelID or passphrase not found in storage");
      return { pastelID: null, passphrase: null };
    }

    logger.info(`Retrieved PastelID from storage: ${pastelID}`);
    return { pastelID, passphrase };
  } catch (error) {
    logger.error(`Error retrieving PastelID and passphrase: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    return { pastelID: null, passphrase: null };
  }
}

async function setPastelIdAndPassphrase(pastelID, passphrase) {
  if (!pastelID || !passphrase) {
    logger.error("Attempted to set empty PastelID or passphrase");
    throw new Error("PastelID and passphrase must not be empty");
  }

  try {
    await initializeStorage();
    await storage.setItem("MY_LOCAL_PASTELID", pastelID);
    await storage.setItem("MY_PASTELID_PASSPHRASE", passphrase);
    logger.info(`Set PastelID: ${pastelID}`);
  } catch (error) {
    logger.error(`Error setting PastelID and passphrase: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
    throw error;
  }
}

module.exports = {
  getCurrentPastelIdAndPassphrase,
  setPastelIdAndPassphrase,
};

---
./update.js
---
require("dotenv").config();
const { exec, spawn } = require("child_process");
const path = require("path");
const fs = require("fs");
const currentDir = __dirname;
const envFilePath = path.join(currentDir, ".env");
const tempEnvFilePath = path.join(currentDir, ".env.temp");

// Configuration
const useDebugMode = process.env.USE_DEBUG_MODE === "1";
console.log(
  `USE_DEBUG_MODE: ${process.env.USE_DEBUG_MODE}, useDebugMode: ${useDebugMode}`
);
const repoUrl =
  "https://github.com/pastelnetwork/pastel_inference_js_client.git";
const branch = "master"; // Changed from "main" to "master"

function updateApplication() {
  if (useDebugMode) {
    console.log("Debug mode is enabled. Skipping auto-update.");
    startApplication();
    return;
  }

  console.log("Checking for updates...");

  // Move .env file to a temporary location
  if (fs.existsSync(envFilePath)) {
    fs.renameSync(envFilePath, tempEnvFilePath);
  }

  exec(
    `git fetch origin ${branch}`,
    { cwd: currentDir },
    (err, stdout, stderr) => {
      if (err) {
        console.error("Error fetching updates:", stderr);

        // Restore .env file if an error occurs
        if (fs.existsSync(tempEnvFilePath)) {
          fs.renameSync(tempEnvFilePath, envFilePath);
        }
        return;
      }

      exec("git rev-parse HEAD", { cwd: currentDir }, (err, currentCommit) => {
        if (err) {
          console.error("Error getting current commit:", stderr);

          // Restore .env file if an error occurs
          if (fs.existsSync(tempEnvFilePath)) {
            fs.renameSync(tempEnvFilePath, envFilePath);
          }
          return;
        }

        exec(
          `git rev-parse origin/${branch}`,
          { cwd: currentDir },
          (err, latestCommit) => {
            if (err) {
              console.error("Error getting latest commit:", stderr);

              // Restore .env file if an error occurs
              if (fs.existsSync(tempEnvFilePath)) {
                fs.renameSync(tempEnvFilePath, envFilePath);
              }
              return;
            }

            if (currentCommit.trim() !== latestCommit.trim()) {
              console.log("Update available. Pulling latest changes...");
              exec(
                `git pull origin ${branch}`,
                { cwd: currentDir },
                (err, stdout, stderr) => {
                  if (err) {
                    console.error("Error pulling updates:", stderr);

                    // Restore .env file if an error occurs
                    if (fs.existsSync(tempEnvFilePath)) {
                      fs.renameSync(tempEnvFilePath, envFilePath);
                    }
                    return;
                  }

                  console.log("Installing dependencies...");
                  exec(
                    "npm install",
                    { cwd: currentDir },
                    (err, stdout, stderr) => {
                      if (err) {
                        console.error("Error installing dependencies:", stderr);

                        // Restore .env file if an error occurs
                        if (fs.existsSync(tempEnvFilePath)) {
                          fs.renameSync(tempEnvFilePath, envFilePath);
                        }
                        return;
                      }

                      console.log(
                        "Update applied successfully. Restarting application..."
                      );

                      // Restore .env file after successful update
                      if (fs.existsSync(tempEnvFilePath)) {
                        fs.renameSync(tempEnvFilePath, envFilePath);
                      }

                      process.exit(0); // Exit to let the process manager (e.g., PM2) restart the app
                    }
                  );
                }
              );
            } else {
              console.log("Application is up-to-date.");

              // Restore .env file if no update is needed
              if (fs.existsSync(tempEnvFilePath)) {
                fs.renameSync(tempEnvFilePath, envFilePath);
              }

              startApplication();
            }
          }
        );
      });
    }
  );
}

function startApplication() {
  console.log("Starting application...");
  const server = spawn("node", ["server.js"], {
    cwd: currentDir,
    stdio: "inherit",
  });

  server.on("close", (code) => {
    console.log(`server.js process exited with code ${code}`);
  });

  server.on("error", (err) => {
    console.error("Error starting application:", err);
  });
}

updateApplication();


---
./utility_functions.js
---
require("dotenv").config();
const crypto = require("crypto");
const zstd = require("zstd-codec").ZstdCodec;
const axios = require("axios");
const Sequelize = require("sequelize");
const ping = require("ping");
const { logger, safeStringify } = require("./logger");
const supernodeCacheStorage = require("node-persist");
const { getCurrentPastelIdAndPassphrase } = require('./storage');
const globals = require("./globals");

const {
  verifyMessageWithPastelID,
  getBestBlockHashAndMerkleRoot,
  checkSupernodeList,
} = require("./rpc_functions");

const MAX_CACHE_AGE_MS = 1 * 60 * 1000; // 1 minute in milliseconds

const { messageSchema } = require("./validation_schemas");

const TARGET_VALUE_PER_CREDIT_IN_USD = parseFloat(
  process.env.TARGET_VALUE_PER_CREDIT_IN_USD
);
const TARGET_PROFIT_MARGIN = parseFloat(process.env.TARGET_PROFIT_MARGIN);
const MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING =
  parseFloat(
    process.env.MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING
  );
const MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS = parseInt(
  process.env.MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS
);

async function initializeSupernodeCacheStorage() {
  await supernodeCacheStorage.init({ dir: "./supernode-cache" });
  await clearOldCache();
}

async function clearOldCache() {
  const currentTime = Date.now();
  const cacheKeys = await supernodeCacheStorage.keys();

  for (const key of cacheKeys) {
    const item = await supernodeCacheStorage.getItem(key);
    if (item && item.timestamp) {
      if (currentTime - item.timestamp > MAX_CACHE_AGE_MS) {
        await supernodeCacheStorage.removeItem(key);
      }
    } else {
      // If the item doesn't have a timestamp, remove it as well
      await supernodeCacheStorage.removeItem(key);
    }
  }
}

async function storeInCache(key, data) {
  await supernodeCacheStorage.setItem(key, {
    timestamp: Date.now(),
    data: data
  });
}

// Modify the function that retrieves data from the cache
async function getFromCache(key) {
  const item = await supernodeCacheStorage.getItem(key);
  if (item && item.timestamp) {
    if (Date.now() - item.timestamp <= MAX_CACHE_AGE_MS) {
      return item.data;
    } else {
      // Data is too old, remove it
      await supernodeCacheStorage.removeItem(key);
    }
  }
  return null;
}

async function fetchCurrentPSLMarketPrice() {
  async function checkPrices() {
    try {
      const [responseCMC, responseCG] = await Promise.all([
        axios.get("https://coinmarketcap.com/currencies/pastel/"),
        axios.get(
          "https://api.coingecko.com/api/v3/simple/price?ids=pastel&vs_currencies=usd"
        ),
      ]);
      const priceCMC = parseFloat(
        responseCMC.data.match(/price today is \$([0-9.]+) USD/)[1]
      );
      const priceCG = responseCG.data.pastel.usd;
      return { priceCMC, priceCG };
    } catch (error) {
      logger.error(`Error fetching PSL market prices: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
      return { priceCMC: null, priceCG: null };
    }
  }
  let { priceCMC, priceCG } = await checkPrices();
  if (priceCMC === null && priceCG === null) {
    await new Promise((resolve) => setTimeout(resolve, 2000));
    ({ priceCMC, priceCG } = await checkPrices());
  }
  const prices = [priceCMC, priceCG].filter((price) => price !== null);
  if (prices.length === 0) {
    throw new Error("Could not retrieve PSL price from any source.");
  }
  const averagePrice =
    prices.reduce((sum, price) => sum + price, 0) / prices.length;
  if (averagePrice < 0.0000001 || averagePrice > 0.02) {
    throw new Error(`Invalid PSL price: ${averagePrice}`);
  }
  logger.info(
    `The current Average PSL price is: $${averagePrice.toFixed(8)} based on ${prices.length
    } sources`
  );
  return averagePrice;
}

async function estimatedMarketPriceOfInferenceCreditsInPSLTerms() {
  try {
    const pslPriceUSD = await fetchCurrentPSLMarketPrice();
    const costPerCreditUSD =
      TARGET_VALUE_PER_CREDIT_IN_USD / (1 - TARGET_PROFIT_MARGIN);
    const costPerCreditPSL = costPerCreditUSD / pslPriceUSD;
    logger.info(
      `Estimated market price of 1.0 inference credit: ${costPerCreditPSL.toFixed(
        4
      )} PSL`
    );
    return costPerCreditPSL;
  } catch (error) {
    logger.error(
      `Error calculating estimated market price of inference credits: ${safeStringify(
        error.message
      )}`
    );
    throw error;
  }
}

function parseAndFormat(value) {
  try {
    if (typeof value === "string") {
      if (value.includes("\n")) {
        return value;
      }
      const parsedValue = JSON.parse(value);
      return JSON.stringify(parsedValue, null, 4);
    }
    return JSON.stringify(value, null, 4);
  } catch (error) {
    return value;
  }
}

function prettyJSON(data) {
  if (data instanceof Sequelize.Model) {
    data = data.get({ plain: true });
  }
  if (data instanceof Map) {
    data = Object.fromEntries(data);
  }
  if (Array.isArray(data) || (typeof data === "object" && data !== null)) {
    const formattedData = {};
    for (const [key, value] of Object.entries(data)) {
      if (typeof value === "string" && key.endsWith("_json")) {
        formattedData[key] = parseAndFormat(value);
      } else if (typeof value === "object" && value !== null) {
        formattedData[key] = prettyJSON(value);
      } else {
        formattedData[key] = value;
      }
    }
    return JSON.stringify(formattedData, null, 4);
  } else if (typeof data === "string") {
    return parseAndFormat(data);
  }
  return data;
}

function abbreviateJSON(jsonString, maxLength) {
  if (jsonString.length <= maxLength) return jsonString;
  const abbreviated = jsonString.slice(0, maxLength) + "...";
  const openBraces =
    (jsonString.match(/{/g) || []).length -
    (abbreviated.match(/{/g) || []).length;
  const openBrackets =
    (jsonString.match(/\[/g) || []).length -
    (abbreviated.match(/\[/g) || []).length;
  return abbreviated + "}".repeat(openBraces) + "]".repeat(openBrackets);
}

function logActionWithPayload(action, payloadName, jsonPayload) {
  const maxPayloadLength = 10000;
  let formattedPayload = prettyJSON(jsonPayload);
  if (formattedPayload.length > maxPayloadLength) {
    formattedPayload = abbreviateJSON(formattedPayload, maxPayloadLength);
  }
  logger.info(
    `Now ${action} ${payloadName} with payload:\n${formattedPayload}`
  );
}

function transformCreditPackPurchaseRequestResponse(result) {
  const transformedResult = { ...result };
  const fieldsToConvert = [
    "list_of_potentially_agreeing_supernodes",
    "list_of_blacklisted_supernode_pastelids",
    "list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms",
    "list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion",
    "selected_agreeing_supernodes_signatures_dict",
  ];
  fieldsToConvert.forEach((field) => {
    if (transformedResult[field]) {
      transformedResult[field] = safeStringify(transformedResult[field]);
    }
  });
  return transformedResult;
}

function computeSHA3256Hexdigest(input) {
  const hash = crypto.createHash("sha3-256");
  hash.update(input);
  return hash.digest("hex");
}

function getSHA256HashOfInputData(inputData) {
  const hash = crypto.createHash("sha3-256");
  hash.update(inputData, "utf-8");
  return hash.digest("hex");
}

async function compressDataWithZstd(inputData) {
  const zstdCodec = new zstd();
  const compressedData = await zstdCodec.compress(inputData, 20);
  const base64EncodedData = compressedData.toString("base64");
  return { compressedData, base64EncodedData };
}

async function decompressDataWithZstd(compressedInputData) {
  const zstdCodec = new zstd();
  const decompressedData = await zstdCodec.decompress(compressedInputData);
  return decompressedData;
}

async function calculateXORDistance(pastelID1, pastelID2) {
  const hash1 = crypto.createHash("sha3-256").update(pastelID1).digest("hex");
  const hash2 = crypto.createHash("sha3-256").update(pastelID2).digest("hex");
  const xorResult = BigInt(`0x${hash1}`) ^ BigInt(`0x${hash2}`);
  return xorResult;
}

function adjustJSONSpacing(jsonString) {
  return jsonString.replace(/(?<!\d):(\s*)/g, ": ").replace(/,(\s*)/g, ", ");
}

function escapeJsonString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function pythonCompatibleStringify(obj) {
  function sortObjectByKeys(unsortedObj) {
    const priorityKeys = ["challenge", "challenge_id", "challenge_signature"];
    return Object.keys(unsortedObj)
      .sort((a, b) => {
        const aPriority = priorityKeys.indexOf(a);
        const bPriority = priorityKeys.indexOf(b);

        if (aPriority !== -1 && bPriority !== -1) {
          return aPriority - bPriority;
        }
        if (aPriority !== -1) {
          return 1;
        }
        if (bPriority !== -1) {
          return -1;
        }
        return a.localeCompare(b);
      })
      .reduce((acc, key) => {
        const value = unsortedObj[key];
        if (
          typeof value === "object" &&
          value !== null &&
          !(value instanceof Date)
        ) {
          acc[key] = Array.isArray(value)
            ? value.map(sortObjectByKeys)
            : sortObjectByKeys(value);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {});
  }

  function customReplacer(key, value) {
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (typeof value === "object" && value !== null) {
      return sortObjectByKeys(value);
    }
    if (
      typeof value === "string" &&
      value.startsWith("{") &&
      value.endsWith("}")
    ) {
      return escapeJsonString(value);
    }
    if (typeof value === "number") {
      return value;
    }
    return value;
  }
  const sortedObject = sortObjectByKeys(obj);
  let jsonString = JSON.stringify(sortedObject, customReplacer);
  jsonString = jsonString.replace(/"(true|false)"/g, "$1");
  jsonString = adjustJSONSpacing(jsonString);
  return jsonString;
}

function base64EncodeJson(jsonInput) {
  return btoa(pythonCompatibleStringify(JSON.parse(jsonInput)));
}

async function extractResponseFieldsFromCreditPackTicketMessageDataAsJSON(
  modelInstance
) {
  const responseFields = {};
  const plainObject =
    modelInstance instanceof Sequelize.Model
      ? modelInstance.get({ plain: true })
      : modelInstance;

  let lastHashFieldName = null;
  let lastSignatureFieldNames = [];
  for (const fieldName in plainObject) {
    if (fieldName.startsWith("sha3_256_hash_of")) {
      lastHashFieldName = fieldName;
    } else if (fieldName.includes("_signature_on_")) {
      lastSignatureFieldNames.push(fieldName);
    }
  }
  Object.keys(plainObject)
    .sort()
    .forEach((fieldName) => {
      if (
        ![
          lastHashFieldName,
          lastSignatureFieldNames.at(-1),
          "id",
          "_changed",
          "_options",
          "_previousDataValues",
          "dataValues",
          "isNewRecord",
          "uniqno",
        ].includes(fieldName)
      ) {
        const fieldValue = plainObject[fieldName];
        if (fieldValue instanceof Date) {
          responseFields[fieldName] = fieldValue.toISOString();
        } else if (typeof fieldValue === "boolean") {
          responseFields[fieldName] = fieldValue ? 1 : 0;
        } else if (typeof fieldValue === "object" && fieldValue !== null) {
          responseFields[fieldName] = pythonCompatibleStringify(fieldValue);
        } else {
          responseFields[fieldName] =
            typeof fieldValue === "number" ? fieldValue : fieldValue.toString();
        }
      }
    });
  return pythonCompatibleStringify(responseFields);
}

async function computeSHA3256HashOfSQLModelResponseFields(modelInstance) {
  let responseFieldsJSON =
    await extractResponseFieldsFromCreditPackTicketMessageDataAsJSON(
      modelInstance
    );
  const sha256HashOfResponseFields =
    getSHA256HashOfInputData(responseFieldsJSON);
  return sha256HashOfResponseFields;
}

async function prepareModelForEndpoint(modelInstance) {
  let preparedModelInstance = {};
  let instanceData =
    typeof modelInstance.get === "function"
      ? modelInstance.get({ plain: true })
      : modelInstance;
  for (const key in instanceData) {
    if (Object.prototype.hasOwnProperty.call(instanceData, key)) {
      if (key.endsWith("_json")) {
        if (typeof instanceData[key] === "string") {
          try {
            const parsedJson = JSON.parse(instanceData[key]);
            preparedModelInstance[key] = pythonCompatibleStringify(parsedJson);
          } catch (e) {
            console.error("Failed to parse JSON for key:", key, "Error:", e);
            preparedModelInstance[key] = instanceData[key];
          }
        } else {
          preparedModelInstance[key] = pythonCompatibleStringify(
            instanceData[key]
          );
        }
      } else {
        preparedModelInstance[key] = instanceData[key];
      }
    }
  }
  return preparedModelInstance;
}

function removeSequelizeFields(plainObject) {
  const fieldsToRemove = [
    "id",
    "_changed",
    "_options",
    "_previousDataValues",
    "dataValues",
    "isNewRecord",
    "uniqno",
  ];
  Object.keys(plainObject).forEach((fieldName) => {
    if (fieldsToRemove.includes(fieldName)) {
      delete plainObject[fieldName];
    }
  });
}

async function prepareModelForValidation(modelInstance) {
  let preparedModelInstance;
  if (typeof modelInstance.get === "function") {
    preparedModelInstance = modelInstance.get({ plain: true });
  } else if (typeof modelInstance === "object") {
    preparedModelInstance = { ...modelInstance };
  } else {
    throw new Error("Invalid modelInstance type");
  }
  Object.keys(preparedModelInstance).forEach((key) => {
    if (
      key.endsWith("_json") &&
      typeof preparedModelInstance[key] === "string"
    ) {
      try {
        preparedModelInstance[key] = JSON.parse(preparedModelInstance[key]);
      } catch (error) {
        console.error(`Error parsing ${key}: ${error}`);
      }
    }
  });
  return preparedModelInstance;
}

function compareDatetimes(datetime1, datetime2) {
  const diffInSeconds = Math.abs(datetime1 - datetime2) / 1000;
  const areCloseEnough =
    diffInSeconds <=
    MAXIMUM_LOCAL_CREDIT_PRICE_DIFFERENCE_TO_ACCEPT_CREDIT_PRICING;
  return { diffInSeconds, areCloseEnough };
}

function validateTimestampFields(modelInstance, validationErrors) {
  for (const [fieldName, fieldValue] of Object.entries(modelInstance)) {
    if (fieldName.endsWith("_timestamp_utc_iso_string")) {
      try {
        const timestamp = new Date(fieldValue);
        const currentTimestamp = new Date();
        const { areCloseEnough } = compareDatetimes(
          timestamp,
          currentTimestamp
        );
        if (!areCloseEnough) {
          validationErrors.push(
            `Timestamp in field ${fieldName} is too far from the current time`
          );
        }
      } catch (error) {
        validationErrors.push(
          `Invalid timestamp format for field ${fieldName}`
        );
      }
    }
  }
}

async function validatePastelBlockHeightFields(
  modelInstance,
  validationErrors
) {
  const [, , bestBlockHeight] = await getBestBlockHashAndMerkleRoot();
  for (const [fieldName, fieldValue] of Object.entries(modelInstance)) {
    if (fieldName.endsWith("_pastel_block_height")) {
      if (
        Math.abs(fieldValue - bestBlockHeight) >
        MAXIMUM_LOCAL_PASTEL_BLOCK_HEIGHT_DIFFERENCE_IN_BLOCKS
      ) {
        validationErrors.push(
          `Pastel block height in field ${fieldName} does not match the current block height; difference is ${Math.abs(
            fieldValue - bestBlockHeight
          )} blocks (local: ${fieldValue}, remote: ${bestBlockHeight})`
        );
      }
    }
  }
}

async function validateHashFields(modelInstance, validationErrors) {
  const expectedHash = await computeSHA3256HashOfSQLModelResponseFields(
    modelInstance
  );
  let hashFieldName = null;
  for (const fieldName in modelInstance) {
    if (
      fieldName.includes("sha3_256_hash_of_") &&
      fieldName.endsWith("_fields")
    ) {
      hashFieldName = fieldName;
      break;
    }
  }
  if (hashFieldName) {
    const actualHash = modelInstance[hashFieldName];
    if (actualHash !== expectedHash) {
      validationErrors.push(
        `SHA3-256 hash in field ${hashFieldName} does not match the computed hash of the response fields`
      );
    }
  }
}


async function getClosestSupernodePastelIDFromList(
  localPastelID,
  filteredSupernodes,
  maxResponseTimeInMilliseconds = 800
) {
  await initializeSupernodeCacheStorage();
  if (!filteredSupernodes || filteredSupernodes.length === 0) {
    logger.warn("No filtered supernodes available");
    return null;
  }

  const xorDistances = await Promise.all(
    filteredSupernodes.map(async (supernode) => {
      let pastelID;
      if (typeof supernode === 'string') {
        pastelID = supernode;
      } else if (supernode && supernode.pastelID) {
        pastelID = supernode.pastelID;
      } else {
        logger.warn(`Invalid supernode data: ${JSON.stringify(supernode)}`);
        return null;
      }

      try {
        const distance = await calculateXORDistance(localPastelID, pastelID);
        return { pastelID, distance: BigInt(distance) };
      } catch (error) {
        logger.error(`Error calculating XOR distance: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
        return null;
      }
    })
  );

  const validDistances = xorDistances.filter(Boolean);

  if (validDistances.length === 0) {
    logger.warn("No valid XOR distances calculated");
    return null;
  }

  const sortedXorDistances = validDistances.sort((a, b) => {
    if (a.distance < b.distance) return -1;
    if (a.distance > b.distance) return 1;
    return 0;
  });

  return sortedXorDistances[0].pastelID;
}

function checkIfPastelIDIsValid(inputString) {
  const pattern = /^jX[A-Za-z0-9]{84}$/;
  return pattern.test(inputString);
}

async function getSupernodeUrlFromPastelID(pastelID, supernodeListDF) {
  const isValidPastelID = checkIfPastelIDIsValid(pastelID);
  if (!isValidPastelID) {
    throw new Error(`Invalid PastelID: ${pastelID}`);
  }
  const supernodeEntry = supernodeListDF.find(
    (node) => node.extKey === pastelID
  );
  if (!supernodeEntry) {
    throw new Error(
      `Supernode with PastelID ${pastelID} not found in the supernode list`
    );
  }
  const ipaddress = supernodeEntry["ipaddress_port"].split(":")[0];
  const supernodeURL = `http://${ipaddress}:7123`;
  return supernodeURL;
}

async function validatePastelIDSignatureFields(
  modelInstance,
  validationErrors
) {
  let lastSignatureFieldName = null;
  let lastHashFieldName = null;
  let firstPastelID;
  let pastelID, messageToVerify, signature;

  const fields = modelInstance.dataValues
    ? modelInstance.dataValues
    : modelInstance;
  for (const fieldName in fields) {
    if (
      fieldName.toLowerCase().includes("_pastelid") &&
      fields[fieldName] !== "NA"
    ) {
      firstPastelID = fields[fieldName];
      break;
    }
  }
  for (const fieldName in fields) {
    if (fieldName.includes("_signature_on_")) {
      lastSignatureFieldName = fieldName;
    } else if (
      fieldName.includes("sha3_256_hash_of_") &&
      fieldName.endsWith("_fields")
    ) {
      lastHashFieldName = fieldName;
    }
  }
  const embeddedField =
    fields[
    "supernode_pastelid_and_signature_on_inference_request_response_hash"
    ];
  if (embeddedField) {
    try {
      const parsedData = JSON.parse(embeddedField);
      firstPastelID = parsedData["signing_sn_pastelid"];
      signature = parsedData["sn_signature_on_response_hash"];
    } catch (e) {
      validationErrors.push(
        "Error parsing JSON from signature field: " + e.message
      );
      return;
    }
  }
  if (
    firstPastelID &&
    lastHashFieldName &&
    lastSignatureFieldName &&
    signature
  ) {
    pastelID = firstPastelID;
    messageToVerify = fields[lastHashFieldName];
    if (!embeddedField) {
      signature = fields[lastSignatureFieldName];
    }
    const verificationResult = await verifyMessageWithPastelID(
      pastelID,
      messageToVerify,
      signature
    );
    if (verificationResult !== "OK") {
      validationErrors.push(
        `PastelID signature in field ${lastSignatureFieldName} failed verification`
      );
    }
  } else {
    validationErrors.push(`Necessary fields for validation are missing`);
  }
}

async function getClosestSupernodeToPastelIDURL(
  inputPastelID,
  supernodeListDF,
  maxResponseTimeInMilliseconds = 1200
) {
  logger.info(`Attempting to find closest supernode for PastelID: ${inputPastelID}`);
  if (!inputPastelID) {
    logger.warn("No input PastelID provided");
    return null;
  }
  await initializeSupernodeCacheStorage();
  const filteredSupernodes = await filterSupernodes(
    supernodeListDF,
    maxResponseTimeInMilliseconds
  );
  if (filteredSupernodes.length > 0) {
    const closestSupernodePastelID = await getClosestSupernodePastelIDFromList(
      inputPastelID,
      filteredSupernodes,
      maxResponseTimeInMilliseconds
    );
    if (!closestSupernodePastelID) {
      logger.warn("No closest supernode PastelID found");
      return { url: null, pastelID: null };
    }

    // Find the supernode info in the original supernodeListDF
    const closestSupernode = supernodeListDF.find(
      (supernode) => supernode.extKey === closestSupernodePastelID
    );

    if (closestSupernode) {
      const supernodeURL = `http://${closestSupernode.ipaddress_port.split(":")[0]}:7123`;
      try {
        await axios.get(supernodeURL, { timeout: maxResponseTimeInMilliseconds });
        return { url: supernodeURL, pastelID: closestSupernodePastelID };
      } catch (error) {
        logger.error(`Error connecting to closest supernode: ${error.message.slice(0, globals.MAX_CHARACTERS_TO_DISPLAY_IN_ERROR_MESSAGE)}`);
        return { url: null, pastelID: null };
      }
    }
  }
  logger.warn("No filtered supernodes available");
  return { url: null, pastelID: null };
}

async function getNClosestSupernodesToPastelIDURLs(
  n,
  inputPastelID,
  supernodeListDF,
  maxResponseTimeInMilliseconds = 800
) {
  if (!inputPastelID) {
    return null;
  }
  await initializeSupernodeCacheStorage();
  const filteredSupernodes = await filterSupernodes(
    supernodeListDF,
    maxResponseTimeInMilliseconds
  );

  const xorDistances = await Promise.all(
    filteredSupernodes.map(async (supernode) => {
      const distance = await calculateXORDistance(
        inputPastelID,
        supernode.pastelID
      );
      return { ...supernode, distance };
    })
  );
  const sortedXorDistances = xorDistances.sort((a, b) => {
    if (a.distance < b.distance) return -1;
    if (a.distance > b.distance) return 1;
    return 0;
  });
  const closestSupernodes = sortedXorDistances.slice(0, n);

  const validSupernodePromises = closestSupernodes.map(async ({ url, pastelID }) => {
    try {
      await axios.get(url, { timeout: maxResponseTimeInMilliseconds });
      return { url, pastelID };
    } catch (error) {
      return null;
    }
  });

  const validSupernodes = (await Promise.all(validSupernodePromises)).filter(Boolean);

  return validSupernodes;
}

async function validateCreditPackTicketMessageData(modelInstance) {
  const validationErrors = [];
  validateTimestampFields(modelInstance, validationErrors);
  await validatePastelBlockHeightFields(modelInstance, validationErrors);
  await validateHashFields(modelInstance, validationErrors);
  await validatePastelIDSignatureFields(modelInstance, validationErrors);
  return validationErrors;
}

function validateInferenceResponseFields(
  responseAuditResults,
  usageRequestResponse
) {
  const inferenceResponseIDCounts = {};
  const inferenceRequestIDCounts = {};
  const proposedCostInCreditsCounts = {};
  const remainingCreditsAfterRequestCounts = {};
  const creditUsageTrackingPSLAddressCounts = {};
  const requestConfirmationMessageAmountInPatoshisCounts = {};
  const maxBlockHeightToIncludeConfirmationTransactionCounts = {};
  const supernodePastelIDAndSignatureOnInferenceResponseIDCounts = {};

  for (const result of responseAuditResults) {
    inferenceResponseIDCounts[result.inference_response_id] =
      (inferenceResponseIDCounts[result.inference_response_id] || 0) + 1;
    inferenceRequestIDCounts[result.inference_request_id] =
      (inferenceRequestIDCounts[result.inference_request_id] || 0) + 1;
    proposedCostInCreditsCounts[
      result.proposed_cost_of_request_in_inference_credits
    ] =
      (proposedCostInCreditsCounts[
        result.proposed_cost_of_request_in_inference_credits
      ] || 0) + 1;
    remainingCreditsAfterRequestCounts[
      result.remaining_credits_in_pack_after_request_processed
    ] =
      (remainingCreditsAfterRequestCounts[
        result.remaining_credits_in_pack_after_request_processed
      ] || 0) + 1;
    creditUsageTrackingPSLAddressCounts[
      result.credit_usage_tracking_psl_address
    ] =
      (creditUsageTrackingPSLAddressCounts[
        result.credit_usage_tracking_psl_address
      ] || 0) + 1;
    requestConfirmationMessageAmountInPatoshisCounts[
      result.request_confirmation_message_amount_in_patoshis
    ] =
      (requestConfirmationMessageAmountInPatoshisCounts[
        result.request_confirmation_message_amount_in_patoshis
      ] || 0) + 1;
    maxBlockHeightToIncludeConfirmationTransactionCounts[
      result.max_block_height_to_include_confirmation_transaction
    ] =
      (maxBlockHeightToIncludeConfirmationTransactionCounts[
        result.max_block_height_to_include_confirmation_transaction
      ] || 0) + 1;
    supernodePastelIDAndSignatureOnInferenceResponseIDCounts[
      result.supernode_pastelid_and_signature_on_inference_request_response_hash
    ] =
      (supernodePastelIDAndSignatureOnInferenceResponseIDCounts[
        result
          .supernode_pastelid_and_signature_on_inference_request_response_hash
      ] || 0) + 1;
  }

  const majorityInferenceResponseID = Object.keys(
    inferenceResponseIDCounts
  ).reduce((a, b) =>
    inferenceResponseIDCounts[a] > inferenceResponseIDCounts[b] ? a : b
  );
  const majorityInferenceRequestID = Object.keys(
    inferenceRequestIDCounts
  ).reduce((a, b) =>
    inferenceRequestIDCounts[a] > inferenceRequestIDCounts[b] ? a : b
  );
  const majorityProposedCostInCredits = Object.keys(
    proposedCostInCreditsCounts
  ).reduce((a, b) =>
    proposedCostInCreditsCounts[a] > proposedCostInCreditsCounts[b] ? a : b
  );
  const majorityRemainingCreditsAfterRequest = Object.keys(
    remainingCreditsAfterRequestCounts
  ).reduce((a, b) =>
    remainingCreditsAfterRequestCounts[a] >
      remainingCreditsAfterRequestCounts[b]
      ? a
      : b
  );
  const majorityCreditUsageTrackingPSLAddress = Object.keys(
    creditUsageTrackingPSLAddressCounts
  ).reduce((a, b) =>
    creditUsageTrackingPSLAddressCounts[a] >
      creditUsageTrackingPSLAddressCounts[b]
      ? a
      : b
  );
  const majorityRequestConfirmationMessageAmountInPatoshis = Object.keys(
    requestConfirmationMessageAmountInPatoshisCounts
  ).reduce((a, b) =>
    requestConfirmationMessageAmountInPatoshisCounts[a] >
      requestConfirmationMessageAmountInPatoshisCounts[b]
      ? a
      : b
  );
  const majorityMaxBlockHeightToIncludeConfirmationTransaction = Object.keys(
    maxBlockHeightToIncludeConfirmationTransactionCounts
  ).reduce((a, b) =>
    maxBlockHeightToIncludeConfirmationTransactionCounts[a] >
      maxBlockHeightToIncludeConfirmationTransactionCounts[b]
      ? a
      : b
  );
  const majoritySupernodePastelIDAndSignatureOnInferenceResponseID =
    Object.keys(
      supernodePastelIDAndSignatureOnInferenceResponseIDCounts
    ).reduce((a, b) =>
      supernodePastelIDAndSignatureOnInferenceResponseIDCounts[a] >
        supernodePastelIDAndSignatureOnInferenceResponseIDCounts[b]
        ? a
        : b
    );

  const validationResults = {
    inference_response_id:
      majorityInferenceResponseID ===
      usageRequestResponse.inference_response_id,
    inference_request_id:
      majorityInferenceRequestID === usageRequestResponse.inference_request_id,
    proposed_cost_in_credits:
      majorityProposedCostInCredits ===
      usageRequestResponse.proposed_cost_of_request_in_inference_credits,
    remaining_credits_after_request:
      majorityRemainingCreditsAfterRequest ===
      usageRequestResponse.remaining_credits_in_pack_after_request_processed,
    credit_usage_tracking_psl_address:
      majorityCreditUsageTrackingPSLAddress ===
      usageRequestResponse.credit_usage_tracking_psl_address,
    request_confirmation_message_amount_in_patoshis:
      majorityRequestConfirmationMessageAmountInPatoshis ===
      usageRequestResponse.request_confirmation_message_amount_in_patoshis,
    max_block_height_to_include_confirmation_transaction:
      majorityMaxBlockHeightToIncludeConfirmationTransaction ===
      usageRequestResponse.max_block_height_to_include_confirmation_transaction,
    supernode_pastelid_and_signature_on_inference_response_id:
      majoritySupernodePastelIDAndSignatureOnInferenceResponseID ===
      usageRequestResponse.supernode_pastelid_and_signature_on_inference_request_response_hash,
  };

  return validationResults;
}

function validateInferenceResultFields(resultAuditResults, usageResult) {
  const inferenceResultIDCounts = {};
  const inferenceRequestIDCounts = {};
  const inferenceResponseIDCounts = {};
  const respondingSupernodePastelIDCounts = {};
  const inferenceResultJSONBase64Counts = {};
  const inferenceResultFileTypeStringsCounts = {};
  const respondingSupernodeSignatureOnInferenceResultIDCounts = {};

  for (const result of resultAuditResults) {
    inferenceResultIDCounts[result.inference_result_id] =
      (inferenceResultIDCounts[result.inference_result_id] || 0) + 1;
    inferenceRequestIDCounts[result.inference_request_id] =
      (inferenceRequestIDCounts[result.inference_request_id] || 0) + 1;
    inferenceResponseIDCounts[result.inference_response_id] =
      (inferenceResponseIDCounts[result.inference_response_id] || 0) + 1;
    respondingSupernodePastelIDCounts[result.responding_supernode_pastelid] =
      (respondingSupernodePastelIDCounts[
        result.responding_supernode_pastelid
      ] || 0) + 1;
    inferenceResultJSONBase64Counts[
      result.inference_result_json_base64.slice(0, 32)
    ] =
      (inferenceResultJSONBase64Counts[
        result.inference_result_json_base64.slice(0, 32)
      ] || 0) + 1;
    inferenceResultFileTypeStringsCounts[
      result.inference_result_file_type_strings
    ] =
      (inferenceResultFileTypeStringsCounts[
        result.inference_result_file_type_strings
      ] || 0) + 1;
    respondingSupernodeSignatureOnInferenceResultIDCounts[
      result.responding_supernode_signature_on_inference_result_id
    ] =
      (respondingSupernodeSignatureOnInferenceResultIDCounts[
        result.responding_supernode_signature_on_inference_result_id
      ] || 0) + 1;
  }

  const majorityInferenceResultID = Object.keys(inferenceResultIDCounts).reduce(
    (a, b) => (inferenceResultIDCounts[a] > inferenceResultIDCounts[b] ? a : b)
  );
  const majorityInferenceRequestID = Object.keys(
    inferenceRequestIDCounts
  ).reduce((a, b) =>
    inferenceRequestIDCounts[a] > inferenceRequestIDCounts[b] ? a : b
  );
  const majorityInferenceResponseID = Object.keys(
    inferenceResponseIDCounts
  ).reduce((a, b) =>
    inferenceResponseIDCounts[a] > inferenceResponseIDCounts[b] ? a : b
  );
  const majorityRespondingSupernodePastelID = Object.keys(
    respondingSupernodePastelIDCounts
  ).reduce((a, b) =>
    respondingSupernodePastelIDCounts[a] > respondingSupernodePastelIDCounts[b]
      ? a
      : b
  );
  const majorityInferenceResultJSONBase64 = Object.keys(
    inferenceResultJSONBase64Counts
  ).reduce((a, b) =>
    inferenceResultJSONBase64Counts[a] > inferenceResultJSONBase64Counts[b]
      ? a
      : b
  );
  const majorityInferenceResultFileTypeStrings = Object.keys(
    inferenceResultFileTypeStringsCounts
  ).reduce((a, b) =>
    inferenceResultFileTypeStringsCounts[a] >
      inferenceResultFileTypeStringsCounts[b]
      ? a
      : b
  );
  const majorityRespondingSupernodeSignatureOnInferenceResultID = Object.keys(
    respondingSupernodeSignatureOnInferenceResultIDCounts
  ).reduce((a, b) =>
    respondingSupernodeSignatureOnInferenceResultIDCounts[a] >
      respondingSupernodeSignatureOnInferenceResultIDCounts[b]
      ? a
      : b
  );

  const validationResults = {
    inference_result_id:
      majorityInferenceResultID === usageResult.inference_result_id,
    inference_request_id:
      majorityInferenceRequestID === usageResult.inference_request_id,
    inference_response_id:
      majorityInferenceResponseID === usageResult.inference_response_id,
    responding_supernode_pastelid:
      majorityRespondingSupernodePastelID ===
      usageResult.responding_supernode_pastelid,
    inference_result_json_base64:
      majorityInferenceResultJSONBase64 ===
      usageResult.inference_result_json_base64.slice(0, 32),
    inference_result_file_type_strings:
      majorityInferenceResultFileTypeStrings ===
      usageResult.inference_result_file_type_strings,
    responding_supernode_signature_on_inference_result_id:
      majorityRespondingSupernodeSignatureOnInferenceResultID ===
      usageResult.responding_supernode_signature_on_inference_result_id,
  };

  return validationResults;
}

function validateInferenceData(inferenceResultDict, auditResults) {
  const usageRequestResponse = inferenceResultDict.usage_request_response;
  const usageResult = inferenceResultDict.output_results;

  const responseValidationResults = validateInferenceResponseFields(
    auditResults.filter((result) => result.inference_response_id),
    usageRequestResponse
  );

  const resultValidationResults = validateInferenceResultFields(
    auditResults.filter((result) => result.inference_result_id),
    usageResult
  );

  const validationResults = {
    response_validation: responseValidationResults,
    result_validation: resultValidationResults,
  };

  return validationResults;
}

async function filterSupernodes(
  supernodeList,
  maxResponseTimeInMilliseconds = 700,
  minPerformanceRatio = 0.75,
  maxSupernodes = 130,
  totalTimeoutMs = 1100
) {
  const cacheKey = "filteredSupernodes";

  const stats = {
    totalProcessed: 0,
    removedDueToPing: 0,
    removedDueToPerformance: 0,
    removedDueToError: 0,
    timeouts: 0
  };

  const logResults = () => {
    let USE_VERBOSE_LOGGING = false;
    const totalRemoved = stats.removedDueToPing + stats.removedDueToPerformance + stats.removedDueToError;
    const removedPercentage = ((totalRemoved / stats.totalProcessed) * 100).toFixed(2);
    if (USE_VERBOSE_LOGGING) {
      logger.info(`Total supernodes processed: ${stats.totalProcessed}`);
      logger.info(`Total supernodes removed: ${totalRemoved} (${removedPercentage}%)`);
      logger.info(`- Removed due to ping: ${stats.removedDueToPing}`);
      logger.info(`- Removed due to performance: ${stats.removedDueToPerformance}`);
      logger.info(`- Removed due to errors: ${stats.removedDueToError}`);
      if (stats.timeouts > 0) {
        logger.info(`Total timeouts: ${stats.timeouts}`);
      }
    }
  };

  const cachedData = await getFromCache(cacheKey);

  if (cachedData && cachedData.length >= maxSupernodes) {
    logger.info("Returning cached supernodes.");
    return cachedData.slice(0, maxSupernodes);
  }

  let fullSupernodeList = supernodeList;
  if (typeof supernodeList[0] === "string") {
    const { validMasternodeListFullDF } = await checkSupernodeList();
    fullSupernodeList = validMasternodeListFullDF.filter((supernode) =>
      supernodeList.includes(supernode.extKey)
    );
  }

  const filteredSupernodes = [];
  let completed = false;
  const { default: pLimit } = await import('p-limit');
  const limit = pLimit(150);

  const checkSupernode = async (supernode) => {
    stats.totalProcessed++;
    if (completed) return;
    const cacheKey = `supernode_${supernode.extKey}`;
    const cachedResult = await getFromCache(cacheKey);

    if (cachedResult) return cachedResult;

    try {
      const ipAddressPort = supernode.ipaddress_port;
      if (!ipAddressPort) return null;
      const ipAddress = ipAddressPort.split(":")[0];
      const pingResponse = await ping.promise.probe(ipAddress, {
        timeout: Math.ceil(maxResponseTimeInMilliseconds / 1000),
      });
      if (pingResponse.time > maxResponseTimeInMilliseconds) {
        stats.removedDueToPing++;
        return null;
      }
      const performanceResponse = await axios.get(`http://${ipAddress}:7123/liveness_ping`, {
        timeout: maxResponseTimeInMilliseconds,
      });
      if (performanceResponse.data.performance_ratio_score < minPerformanceRatio) {
        stats.removedDueToPerformance++;
        return null;
      }
      const result = { pastelID: supernode.extKey, url: `http://${ipAddress}:7123` };
      await storeInCache(cacheKey, result);
      return result;
    } catch (error) {
      stats.removedDueToError++;
      return null;
    }
  };

  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => {
      stats.timeouts++;
      reject(new Error("Operation timed out"));
    }, totalTimeoutMs)
  );

  try {
    await Promise.race([
      timeoutPromise,
      Promise.all(fullSupernodeList.map(supernode =>
        limit(() => checkSupernode(supernode).then(result => {
          if (result) {
            filteredSupernodes.push(result);
            if (filteredSupernodes.length >= maxSupernodes) {
              completed = true;
            }
          }
        }))
      ))
    ]);
  } catch (error) {
    if (error.message !== "Operation timed out") {
      throw error;
    }
  }

  await storeInCache(cacheKey, filteredSupernodes);
  logResults();
  return filteredSupernodes.slice(0, maxSupernodes);
}

module.exports = {
  fetchCurrentPSLMarketPrice,
  estimatedMarketPriceOfInferenceCreditsInPSLTerms,
  prettyJSON,
  logActionWithPayload,
  transformCreditPackPurchaseRequestResponse,
  computeSHA3256Hexdigest,
  getSHA256HashOfInputData,
  compressDataWithZstd,
  decompressDataWithZstd,
  calculateXORDistance,
  pythonCompatibleStringify,
  extractResponseFieldsFromCreditPackTicketMessageDataAsJSON,
  computeSHA3256HashOfSQLModelResponseFields,
  prepareModelForValidation,
  prepareModelForEndpoint,
  removeSequelizeFields,
  validateTimestampFields,
  validatePastelBlockHeightFields,
  validateHashFields,
  validatePastelIDSignatureFields,
  filterSupernodes,
  getClosestSupernodePastelIDFromList,
  checkIfPastelIDIsValid,
  getSupernodeUrlFromPastelID,
  getClosestSupernodeToPastelIDURL,
  getNClosestSupernodesToPastelIDURLs,
  validateCreditPackTicketMessageData,
  validateInferenceResponseFields,
  validateInferenceResultFields,
  validateInferenceData,
  logger,
};


---
./validation_schemas.js
---
require("dotenv").config();
const Joi = require("joi");

const supernodeListSchema = Joi.object({
  txid_vout: Joi.string().required(),
  supernode_status: Joi.string().required(),
  protocol_version: Joi.number().required(),
  supernode_psl_address: Joi.string().required(),
  lastseentime: Joi.number().required(),
  activeseconds: Joi.number().required(),
  activedays: Joi.number().required(),
  lastpaidtime: Joi.number().required(),
  lastpaidblock: Joi.number().required(),
  ipaddress_port: Joi.string().required(),
  rank: Joi.number().required(),
  pubkey: Joi.string().required(),
  extAddress: Joi.string().required(),
  extP2P: Joi.string().required(),
  extKey: Joi.string().required(),
});

const messageSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(), // Validate as UUID v4
  sending_sn_pastelid: Joi.string().required(),
  receiving_sn_pastelid: Joi.string().required(),
  sending_sn_txid_vout: Joi.string().required(),
  receiving_sn_txid_vout: Joi.string().required(),
  message_type: Joi.string().required(),
  message_body: Joi.string().required(),
  signature: Joi.string().required(),
  timestamp: Joi.date().iso(),
});

const userMessageSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  from_pastelid: Joi.string().required(),
  to_pastelid: Joi.string().required(),
  message_body: Joi.string().required(),
  message_signature: Joi.string().required(),
  timestamp: Joi.date().iso(),
});

const creditPackPurchaseRequestSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  requesting_end_user_pastelid: Joi.string().required(),
  requested_initial_credits_in_credit_pack: Joi.number().integer().required(),
  list_of_authorized_pastelids_allowed_to_use_credit_pack:
    Joi.string().required(),
  credit_usage_tracking_psl_address: Joi.string().required(),
  request_timestamp_utc_iso_string: Joi.string().required(),
  request_pastel_block_height: Joi.number().integer().required(),
  credit_purchase_request_message_version_string: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  requesting_end_user_pastelid_signature_on_request_hash:
    Joi.string().required(),
});

const creditPackPurchaseRequestRejectionSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  rejection_reason_string: Joi.string().required(),
  rejection_timestamp_utc_iso_string: Joi.string().required(),
  rejection_pastel_block_height: Joi.number().integer().required(),
  credit_purchase_request_rejection_message_version_string:
    Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_rejection_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_rejection_hash:
    Joi.string().required(),
});

const creditPackPurchaseRequestPreliminaryPriceQuoteSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  credit_usage_tracking_psl_address: Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  preliminary_quoted_price_per_credit_in_psl: Joi.number().required(),
  preliminary_total_cost_of_credit_pack_in_psl: Joi.number().required(),
  preliminary_price_quote_timestamp_utc_iso_string: Joi.string().required(),
  preliminary_price_quote_pastel_block_height: Joi.number()
    .integer()
    .required(),
  preliminary_price_quote_message_version_string: Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_preliminary_price_quote_hash:
    Joi.string().required(),
});

const creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema = Joi.object(
  {
    id: Joi.string().guid({ version: "uuidv4" }).required(),
    sha3_256_hash_of_credit_pack_purchase_request_fields:
      Joi.string().required(),
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_fields:
      Joi.string().required(),
    credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
    agree_with_preliminary_price_quote: Joi.boolean().required(),
    credit_usage_tracking_psl_address: Joi.string().required(),
    preliminary_quoted_price_per_credit_in_psl: Joi.number().required(),
    preliminary_price_quote_response_timestamp_utc_iso_string:
      Joi.string().required(),
    preliminary_price_quote_response_pastel_block_height: Joi.number()
      .integer()
      .required(),
    preliminary_price_quote_response_message_version_string:
      Joi.string().required(),
    requesting_end_user_pastelid: Joi.string().required(),
    sha3_256_hash_of_credit_pack_purchase_request_preliminary_price_quote_response_fields:
      Joi.string().required(),
    requesting_end_user_pastelid_signature_on_preliminary_price_quote_response_hash:
      Joi.string().required(),
  }
);

const creditPackPurchaseRequestResponseTerminationSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  termination_reason_string: Joi.string().required(),
  termination_timestamp_utc_iso_string: Joi.string().required(),
  termination_pastel_block_height: Joi.number().integer().required(),
  credit_purchase_request_termination_message_version_string:
    Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_termination_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_termination_hash:
    Joi.string().required(),
});

const creditPackPurchaseRequestResponseSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  psl_cost_per_credit: Joi.number().required(),
  proposed_total_cost_of_credit_pack_in_psl: Joi.number().required(),
  credit_usage_tracking_psl_address: Joi.string().required(),
  request_response_timestamp_utc_iso_string: Joi.string().required(),
  request_response_pastel_block_height: Joi.number().integer().required(),
  best_block_merkle_root: Joi.string().required(),
  best_block_height: Joi.number().integer().required(),
  credit_purchase_request_response_message_version_string:
    Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  list_of_blacklisted_supernode_pastelids: Joi.string().required(),
  list_of_potentially_agreeing_supernodes: Joi.string().required(),
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms:
    Joi.string().required(),
  list_of_supernode_pastelids_agreeing_to_credit_pack_purchase_terms_selected_for_signature_inclusion:
    Joi.string().required(),
  selected_agreeing_supernodes_signatures_dict: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_response_hash:
    Joi.string().required(),
});

const creditPackPurchaseRequestConfirmationSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields:
    Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  requesting_end_user_pastelid: Joi.string().required(),
  txid_of_credit_purchase_burn_transaction: Joi.string().required(),
  credit_purchase_request_confirmation_utc_iso_string: Joi.string().required(),
  credit_purchase_request_confirmation_pastel_block_height: Joi.number()
    .integer()
    .required(),
  credit_purchase_request_confirmation_message_version_string:
    Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
    Joi.string().required(),
  requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
    Joi.string().required(),
});

const creditPackPurchaseRequestConfirmationResponseSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
    Joi.string().required(),
  credit_pack_confirmation_outcome_string: Joi.string().required(),
  pastel_api_credit_pack_ticket_registration_txid: Joi.string().required(),
  credit_pack_confirmation_failure_reason_if_applicable: Joi.string().allow(""),
  credit_purchase_request_confirmation_response_utc_iso_string:
    Joi.string().required(),
  credit_purchase_request_confirmation_response_pastel_block_height:
    Joi.number().integer().required(),
  credit_purchase_request_confirmation_response_message_version_string:
    Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_response_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_confirmation_response_hash:
    Joi.string().required(),
});

const creditPackRequestStatusCheckSchema = Joi.object({
  id: Joi.string().guid({ version: "uuidv4" }).required(),
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  requesting_end_user_pastelid: Joi.string().required(),
  requesting_end_user_pastelid_signature_on_sha3_256_hash_of_credit_pack_purchase_request_fields:
    Joi.string().required(),
});

const creditPackPurchaseRequestStatusSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_response_fields:
    Joi.string().required(),
  status: Joi.string().required(),
  status_details: Joi.string().required(),
  status_update_timestamp_utc_iso_string: Joi.string().required(),
  status_update_pastel_block_height: Joi.number().integer().required(),
  credit_purchase_request_status_message_version_string:
    Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_status_fields:
    Joi.string().required(),
  responding_supernode_signature_on_credit_pack_purchase_request_status_hash:
    Joi.string().required(),
});

const creditPackStorageRetryRequestSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_response_fields:
    Joi.string().required(),
  credit_pack_purchase_request_fields_json_b64: Joi.string().required(),
  requesting_end_user_pastelid: Joi.string().required(),
  closest_agreeing_supernode_to_retry_storage_pastelid: Joi.string().required(),
  credit_pack_storage_retry_request_timestamp_utc_iso_string:
    Joi.string().required(),
  credit_pack_storage_retry_request_pastel_block_height: Joi.number()
    .integer()
    .required(),
  credit_pack_storage_retry_request_message_version_string:
    Joi.string().required(),
  sha3_256_hash_of_credit_pack_storage_retry_request_fields:
    Joi.string().required(),
  requesting_end_user_pastelid_signature_on_credit_pack_storage_retry_request_hash:
    Joi.string().required(),
});

const creditPackStorageRetryRequestResponseSchema = Joi.object({
  sha3_256_hash_of_credit_pack_purchase_request_fields: Joi.string().required(),
  sha3_256_hash_of_credit_pack_purchase_request_confirmation_fields:
    Joi.string().required(),
  credit_pack_storage_retry_confirmation_outcome_string:
    Joi.string().required(),
  pastel_api_credit_pack_ticket_registration_txid: Joi.string().required(),
  credit_pack_storage_retry_confirmation_failure_reason_if_applicable:
    Joi.string().required(),
  credit_pack_storage_retry_confirmation_response_utc_iso_string:
    Joi.string().required(),
  credit_pack_storage_retry_confirmation_response_pastel_block_height:
    Joi.number().integer().required(),
  credit_pack_storage_retry_confirmation_response_message_version_string:
    Joi.string().required(),
  closest_agreeing_supernode_to_retry_storage_pastelid: Joi.string().required(),
  sha3_256_hash_of_credit_pack_storage_retry_confirmation_response_fields:
    Joi.string().required(),
  closest_agreeing_supernode_to_retry_storage_pastelid_signature_on_credit_pack_storage_retry_confirmation_response_hash:
    Joi.string().required(),
});

const inferenceAPIUsageRequestSchema = Joi.object({
  inference_request_id: Joi.string().guid({ version: "uuidv4" }).required(),
  requesting_pastelid: Joi.string().required(),
  credit_pack_ticket_pastel_txid: Joi.string().required(),
  requested_model_canonical_string: Joi.string().required(),
  model_inference_type_string: Joi.string().required(),
  model_parameters_json_b64: Joi.string().required(),
  model_input_data_json_b64: Joi.string().required(),
  inference_request_utc_iso_string: Joi.string().required(),
  inference_request_pastel_block_height: Joi.number().integer().required(),
  status: Joi.string().required(),
  inference_request_message_version_string: Joi.string().required(),
  sha3_256_hash_of_inference_request_fields: Joi.string().required(),
  requesting_pastelid_signature_on_request_hash: Joi.string().required(),
});

const inferenceAPIUsageResponseSchema = Joi.object({
  inference_response_id: Joi.string().required(),
  inference_request_id: Joi.string().required(),
  proposed_cost_of_request_in_inference_credits: Joi.number().required(),
  remaining_credits_in_pack_after_request_processed: Joi.number().required(),
  credit_usage_tracking_psl_address: Joi.string().required(),
  request_confirmation_message_amount_in_patoshis: Joi.number()
    .integer()
    .required(),
  max_block_height_to_include_confirmation_transaction: Joi.number()
    .integer()
    .required(),
  inference_request_response_utc_iso_string: Joi.string().required(),
  inference_request_response_pastel_block_height: Joi.number()
    .integer()
    .required(),
  inference_request_response_message_version_string: Joi.string().required(),
  sha3_256_hash_of_inference_request_response_fields: Joi.string().required(),
  supernode_pastelid_and_signature_on_inference_request_response_hash:
    Joi.string().required(),
});

const inferenceAPIOutputResultSchema = Joi.object({
  inference_result_id: Joi.string().required(),
  inference_request_id: Joi.string().required(),
  inference_response_id: Joi.string().required(),
  responding_supernode_pastelid: Joi.string().required(),
  inference_result_json_base64: Joi.string().required(),
  inference_result_file_type_strings: Joi.string().required(),
  inference_result_utc_iso_string: Joi.string().required(),
  inference_result_pastel_block_height: Joi.number().integer().required(),
  inference_result_message_version_string: Joi.string().required(),
  sha3_256_hash_of_inference_result_fields: Joi.string().required(),
  responding_supernode_signature_on_inference_result_id:
    Joi.string().required(),
});

const inferenceConfirmationSchema = Joi.object({
  inference_request_id: Joi.string().required(),
  requesting_pastelid: Joi.string().required(),
  confirmation_transaction: Joi.object().required(),
});

module.exports = {
  supernodeListSchema,
  messageSchema,
  userMessageSchema,
  creditPackPurchaseRequestSchema,
  creditPackPurchaseRequestRejectionSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteSchema,
  creditPackPurchaseRequestPreliminaryPriceQuoteResponseSchema,
  creditPackPurchaseRequestResponseTerminationSchema,
  creditPackPurchaseRequestResponseSchema,
  creditPackPurchaseRequestConfirmationSchema,
  creditPackPurchaseRequestConfirmationResponseSchema,
  creditPackRequestStatusCheckSchema,
  creditPackPurchaseRequestStatusSchema,
  creditPackStorageRetryRequestSchema,
  creditPackStorageRetryRequestResponseSchema,
  inferenceAPIUsageRequestSchema,
  inferenceAPIUsageResponseSchema,
  inferenceAPIOutputResultSchema,
  inferenceConfirmationSchema,
};


---
